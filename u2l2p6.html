<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>مدينة ثلاثية الأبعاد مع متجر خضار - للهاتف</title>
    <!-- Three.js library for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Basic reset and font */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif; /* Using Inter font */
        }
        
        /* Body styling with gradient background */
        body {
            overflow: hidden; /* Prevent scrolling */
            background: linear-gradient(to bottom, #1a2980, #26d0ce); /* Blue gradient */
            color: #fff;
            height: 100vh;
            perspective: 1000px; /* For potential 3D effects on UI elements */
            display: flex; /* Use flexbox for main layout */
            flex-direction: column; /* Stack elements vertically on small screens */
            align-items: center; /* Center content horizontally */
            justify-content: center; /* Center content vertically */
        }
        
        /* Main container for layout */
        .container {
            display: flex;
            flex-direction: row; /* Default to row for larger screens */
            height: 100vh; /* Full viewport height */
            width: 100%; /* Full viewport width */
            padding: 20px;
            gap: 20px; /* Space between info panel and scene */
            justify-content: center; /* Center content */
            align-items: flex-start; /* Align items to the start */
        }
        
        /* Info panel styling */
        .info-panel {
            width: 350px; /* Slightly wider for better content display */
            background: rgba(0, 0, 0, 0.7); /* Semi-transparent dark background */
            border-radius: 15px; /* Rounded corners */
            padding: 20px;
            backdrop-filter: blur(10px); /* Frosted glass effect */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle white border */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); /* Soft shadow */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
            display: none; /* Hidden by default, will be shown by JS when near store */
            opacity: 0; /* Start with 0 opacity for fade effect */
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out; /* Smooth transition for showing/hiding */
            transform: translateX(-20px); /* Start slightly off-screen for animation */
        }

        /* Class to show the info panel */
        .info-panel.show {
            opacity: 1;
            display: block; /* Ensure it's block when shown */
            transform: translateX(0); /* Slide into view */
        }

        /* Custom Scrollbar Styles (for Webkit browsers like Chrome, Safari) */
        .info-panel::-webkit-scrollbar {
            width: 8px; /* Width of the scrollbar */
        }

        .info-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1); /* Track color */
            border-radius: 10px;
        }

        .info-panel::-webkit-scrollbar-thumb {
            background-color: rgba(76, 175, 80, 0.6); /* Scrollbar color */
            border-radius: 10px;
            border: 2px solid rgba(0, 0, 0, 0.2); /* Border around the thumb */
        }

        .info-panel::-webkit-scrollbar-thumb:hover {
            background-color: #4CAF50; /* Darker on hover */
        }
        
        /* Scene container styling */
        .scene-container {
            flex: 1; /* Takes remaining space */
            min-width: 300px; /* Minimum width for the scene */
            border-radius: 15px; /* Rounded corners */
            overflow: hidden; /* Hide overflow */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); /* Stronger shadow for scene */
            position: relative;
            height: 100%; /* Ensure it takes full height of container */
        }
        
        /* Canvas styling - Apply touch-action: none here */
        #cityScene {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none; /* Disable default touch actions specifically for the canvas */
            cursor: grab; /* Default cursor for camera interaction */
        }
        #cityScene:active {
            cursor: grabbing; /* Cursor when dragging */
        }
        
        /* Heading styles */
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #4CAF50; /* Green color */
            font-size: 28px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5); /* Glowing effect */
        }
        
        h2 {
            color: #4CAF50;
            margin: 15px 0 10px;
            border-bottom: 2px solid #4CAF50; /* Underline effect */
            padding-bottom: 5px;
            font-size: 22px; /* Slightly larger for headings */
        }
        
        /* Controls section styling */
        .controls {
            background: rgba(0, 30, 0, 0.4); /* Dark green semi-transparent */
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            justify-content: space-between; /* Space out text and key */
            font-size: 15px; /* Slightly larger text */
        }
        
        .key {
            background: rgba(255, 255, 255, 0.2); /* Light semi-transparent background */
            border: 1px solid rgba(255, 255, 255, 0.3); /* Subtle border */
            padding: 5px 10px;
            border-radius: 5px;
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Small shadow for keys */
        }
        
        /* Vegetable list grid */
        .vegetable-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); /* Responsive grid, slightly wider min */
            gap: 12px; /* Slightly more gap */
            margin-top: 10px;
        }
        
        .vegetable-item {
            background: rgba(76, 175, 80, 0.2); /* Green semi-transparent */
            padding: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease; /* Smooth hover effect */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Initial shadow */
        }
        
        .vegetable-item:hover {
            transform: translateY(-3px); /* Lift on hover */
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3); /* Enhanced shadow on hover */
        }
        
        .veg-icon {
            width: 28px; /* Larger icon */
            height: 28px;
            border-radius: 50%;
            margin-right: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px; /* Emoji size */
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3); /* Inner shadow for icons */
        }
        
        /* Specific vegetable icon colors (kept as is) */
        .apple { background: #FF3B30; } /* Red */
        .orange { background: #FF9500; } /* Orange */
        .mango { background: #FFCC00; } /* Yellow-Orange */
        .tomato { background: #FF3B30; } /* Red */
        .cucumber { background: #34C759; } /* Green */
        .carrot { background: #FF9500; } /* Orange */
        .pepper { background: #FF2D55; } /* Red-Pink */
        .potato { background: #C69C6D; } /* Brown */
        .eggplant { background: #5856D6; } /* Purple */
        .cabbage { background: #34C759; } /* Green */
        .onion { background: #FFD60A; } /* Yellow */
        
        /* Stats section */
        .stats {
            display: flex;
            justify-content: space-around; /* Evenly spaced */
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .stat-item {
            text-align: center;
            padding: 5px;
        }
        
        .stat-value {
            font-size: 26px; /* Slightly larger */
            font-weight: bold;
            color: #4CAF50;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }
        
        .stat-label {
            font-size: 13px; /* Slightly larger */
            opacity: 0.9;
        }
        
        /* Overlay for title and subtitle */
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            text-align: right; /* Align text to the right for Arabic */
        }
        
        .title {
            font-size: 26px; /* Slightly larger */
            margin-bottom: 10px;
            color: #4CAF50;
            text-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
        }
        
        .subtitle {
            font-size: 16px;
            opacity: 0.8;
            line-height: 1.5;
        }
        
        /* Loading screen */
        .loading {
            position: fixed; /* Use fixed to cover entire viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95); /* Darker overlay */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 26px; /* Larger text */
            color: white;
            text-align: center;
            z-index: 9999; /* On top of everything */
            animation: fadeIn 0.5s ease-out; /* Fade in animation */
        }
        
        .progress-bar {
            width: 300px;
            height: 12px; /* Slightly thicker */
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            margin-top: 25px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A); /* Green gradient for progress */
            width: 0%;
            transition: width 0.3s ease-out;
            border-radius: 6px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: none; /* Hidden by default, shown on mobile */
            justify-content: space-between;
            padding: 0 30px;
            z-index: 100;
            pointer-events: none; /* Allow interaction with canvas behind */
        }
        
        .movement-controls, .camera-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto; /* Re-enable pointer events for controls */
        }
        
        .control-row {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .control-btn {
            width: 75px; /* Slightly larger buttons */
            height: 75px;
            background: rgba(255, 255, 255, 0.25); /* More visible background */
            border: 2px solid rgba(255, 255, 255, 0.6); /* Stronger border */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 10px;
            color: white;
            font-size: 28px; /* Larger icon */
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(8px); /* More blur */
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); /* Stronger shadow */
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5); /* Text shadow for better visibility */
        }
        
        .control-btn:active {
            background: rgba(76, 175, 80, 0.6); /* More opaque green on active */
            transform: scale(0.92); /* More noticeable press effect */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
        }
        
        /* Joystick base */
        .joystick {
            width: 130px; /* Slightly larger joystick */
            height: 130px;
            background: rgba(0, 0, 0, 0.35); /* More visible background */
            border-radius: 50%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid rgba(255, 255, 255, 0.4);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.6), 0 5px 15px rgba(0, 0, 0, 0.5); /* Inner and outer shadow */
        }
        
        /* Joystick handle */
        .joystick-handle {
            width: 55px; /* Slightly larger handle */
            height: 55px;
            background: rgba(255, 255, 255, 0.9); /* Brighter handle */
            border-radius: 50%;
            position: absolute;
            cursor: move;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.6); /* Stronger handle shadow */
            transition: transform 0.1s ease-out; /* Smooth reset */
        }
        
        /* Camera joystick (same styling as movement joystick) */
        .camera-joystick {
            /* Inherits from .joystick */
        }
        
        .camera-handle {
            /* Inherits from .joystick-handle */
        }
        
        /* Mobile info text */
        .mobile-info {
            position: absolute;
            bottom: 180px; /* Position above controls */
            left: 20px;
            background: rgba(0, 0, 0, 0.75); /* Darker background */
            padding: 12px 18px; /* More padding */
            border-radius: 12px; /* More rounded */
            font-size: 15px; /* Slightly larger font */
            display: none; /* Hidden by default */
            max-width: 85%; /* Wider for text */
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            text-align: right; /* Align text to the right for Arabic */
        }
        
        /* Calculator Section Styling */
        .calculator-section {
            background: rgba(0, 30, 0, 0.4);
            padding: 18px; /* More padding */
            border-radius: 12px; /* More rounded */
            margin-top: 25px; /* More margin */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .calculator-section h2 {
            margin-top: 0;
            margin-bottom: 18px; /* More margin */
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px; /* More padding */
            font-size: 24px; /* Larger font */
            text-align: center;
        }

        .item-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px; /* More margin */
            gap: 15px; /* Increased space between elements in the row */
        }

        .item-name {
            flex-basis: 35%;
            font-size: 17px; /* Larger font */
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: right; /* Align text to the right */
        }

        .input-group {
            display: flex;
            flex-direction: column;
            flex-basis: 30%;
            gap: 5px; /* Small gap between label and input */
        }

        .input-group label {
            font-size: 13px; /* Slightly larger label */
            color: rgba(255, 255, 255, 0.85); /* More visible label */
            text-align: center;
            margin-bottom: 3px;
        }

        .quantity-input, .price-input {
            padding: 10px; /* More padding */
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.4); /* More prominent border */
            background: rgba(255, 255, 255, 0.15); /* Slightly lighter background */
            color: #fff;
            font-size: 15px; /* Larger font */
            text-align: center;
            -moz-appearance: textfield;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        /* Hide arrows for Chrome, Safari, Edge */
        .quantity-input::-webkit-outer-spin-button,
        .quantity-input::-webkit-inner-spin-button,
        .price-input::-webkit-outer-spin-button,
        .price-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .quantity-input::placeholder, .price-input::placeholder {
            color: rgba(255, 255, 255, 0.7); /* More visible placeholder */
        }
        .quantity-input:focus, .price-input:focus {
            outline: none;
            border-color: #4CAF50; /* Highlight on focus */
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3); /* Glow effect on focus */
        }

        .total-section {
            margin-top: 25px; /* More margin */
            text-align: center;
            padding-top: 18px; /* More padding */
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .action-button {
            background: linear-gradient(to right, #4CAF50, #8BC34A); /* Green gradient button */
            color: white;
            padding: 14px 30px; /* More padding */
            border: none;
            border-radius: 30px; /* More rounded */
            cursor: pointer;
            font-size: 19px; /* Larger font */
            font-weight: bold;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35); /* Stronger shadow */
            transition: all 0.3s ease;
            margin-bottom: 18px; /* More margin */
            width: 100%; /* Full width button */
            letter-spacing: 0.5px; /* Slight letter spacing */
        }

        .action-button:hover {
            background: linear-gradient(to right, #8BC34A, #4CAF50);
            transform: translateY(-3px); /* More noticeable lift */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        .action-button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }

        .total-display {
            font-size: 26px; /* Larger font */
            font-weight: bold;
            color: #FFEB3B; /* Yellow for total amount */
            text-shadow: 0 0 10px rgba(255, 235, 59, 0.6); /* Stronger glow */
        }

        /* Store Sign Animation */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.03); opacity: 0.95; }
            100% { transform: scale(1); opacity: 1; }
        }
        .store-sign-animated {
            animation: pulse 2s infinite ease-in-out;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 900px) {
            .container {
                flex-direction: column; /* Stack info panel and scene */
                padding: 15px;
                gap: 15px;
                height: auto; /* Allow container to grow based on content */
            }
            
            .info-panel {
                width: 100%;
                margin-right: 0;
                max-height: 45vh; /* Adjusted max-height to make scrollbar appear more readily */
                transform: translateX(0); /* No initial transform on mobile */
            }
            
            .scene-container {
                height: 55vh; /* Give more height to the scene on mobile */
                min-height: 300px; /* Ensure a minimum height */
            }

            .mobile-controls {
                display: flex; /* Show mobile controls */
            }
            
            .mobile-info {
                display: block; /* Show mobile info */
            }
            
            .overlay {
                font-size: 14px;
                max-width: 90%; /* Wider overlay */
                left: 15px;
                top: 15px;
                padding: 12px; /* Slightly less padding */
            }
            
            .overlay .title {
                font-size: 20px;
            }
            
            .overlay .subtitle {
                font-size: 14px;
            }
        }
        
        @media (max-width: 600px) {
            .info-panel {
                max-height: 40vh; /* Further adjust max-height for very small screens */
            }
            
            .container {
                padding: 10px;
                gap: 10px;
            }
            
            .mobile-info {
                bottom: 160px; /* Adjust position */
                font-size: 13px;
                left: 10px;
                padding: 10px 12px;
            }
            
            .control-btn {
                width: 65px; /* Smaller buttons */
                height: 65px;
                font-size: 24px;
                margin: 0 8px;
            }
            
            .joystick, .camera-joystick {
                width: 110px; /* Smaller joysticks */
                height: 110px;
            }
            
            .joystick-handle, .camera-handle {
                width: 45px; /* Smaller handles */
                height: 45px;
            }
            .item-row {
                flex-direction: column; /* Stack items vertically on small screens */
                align-items: flex-start;
                gap: 6px; /* Reduced gap */
            }
            .item-name, .input-group {
                flex-basis: 100%; /* Take full width */
                width: 100%;
            }
            .quantity-input, .price-input {
                text-align: right; /* Align text right for better readability on small screens */
                font-size: 14px;
                padding: 8px;
            }
            .input-group label {
                text-align: right; /* Align labels right */
            }
            h1 {
                font-size: 24px;
            }
            h2 {
                font-size: 20px;
            }
            .action-button {
                font-size: 17px;
                padding: 12px 20px;
            }
            .total-display {
                font-size: 22px;
            }
        }
    </style>
</head>
<body>
    <div class="overlay">
        <div class="title">مدينة الخضار ثلاثية الأبعاد</div>
        <div class="subtitle">تجول في المدينة وتفقد متجر الخضار! استخدم عناصر التحكم بالأسفل للحركة</div>
    </div>
    
    <div class="mobile-info">
        اسحب بإصبعك على الشاشة للنظر حولك، واستخدم أزرار التحكم للحركة
    </div>
    
    <div class="loading">
        جارٍ تحميل المدينة...
        <div class="progress-bar">
            <div class="progress" id="loadingProgress"></div>
        </div>
    </div>
    
    <div class="container">
        <div class="info-panel">
            <h1>متجر الخضار الافتراضي</h1>
            
            <h2>عن المتجر</h2>
            <p>مرحبًا بكم في متجر الخضار الافتراضي! هنا يمكنك العثور على أفضل أنواع الخضروات والفواكه الطازجة مباشرة من المزارع المحلية. نتعهد بجودة المنتجات وأسعار مناسبة للجميع.</p>
            
            <h2>الخضروات والفواكه المتوفرة</h2>
            <div class="vegetable-list">
                <div class="vegetable-item">
                    <div class="veg-icon apple">🍎</div>
                    <span>تفاح</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon orange">🍊</div>
                    <span>برتقال</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon mango">🥭</div>
                    <span>مانجو</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon tomato">🍅</div>
                    <span>طماطم</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon cucumber">🥒</div>
                    <span>خيار</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon carrot">🥕</div>
                    <span>جزر</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon pepper">🌶️</div>
                    <span>فلفل</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon potato">🥔</div>
                    <span>بطاطس</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon eggplant">🍆</div>
                    <span>باذنجان</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon cabbage">🥬</div>
                    <span>كرنب</span>
                </div>
                <div class="vegetable-item">
                    <div class="veg-icon onion">🧅</div>
                    <span>بصل</span>
                </div>
            </div>

            <!-- New Calculator Section -->
            <div class="calculator-section">
                <h2>حاسبة المشتريات</h2>
                <div id="itemsContainer">
                    <!-- Item rows will be dynamically generated by JavaScript -->
                </div>
                <div class="total-section">
                    <button id="calculateTotalBtn" class="action-button">احسب المجموع</button>
                    <div class="total-display">
                        المجموع الكلي: <span id="totalAmount">0.00</span> د.أ
                    </div>
                </div>
            </div>
            
            <h2>تحكم في التجول</h2>
            <div class="controls">
                <div class="control-item">
                    <span>التجول للأمام</span>
                    <div class="key">W</div>
                </div>
                <div class="control-item">
                    <span>التجول للخلف</span>
                    <div class="key">S</div>
                </div>
                <div class="control-item">
                    <span>التحرك لليسار</span>
                    <div class="key">A</div>
                </div>
                <div class="control-item">
                    <span>التحرك لليمين</span>
                    <div class="key">D</div>
                </div>
                <div class="control-item">
                    <span>النظر حولك</span>
                    <div class="key">ماوس</div>
                </div>
                <div class="control-item">
                    <span>التحكم بالهاتف</span>
                    <div class="key">لمس الشاشة</div>
                </div>
            </div>
            
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value">11</div>
                    <div class="stat-label">نوع خضار/فاكهة</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">متوفر</div>
                    <div class="stat-label">الآن</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">365</div>
                    <div class="stat-label">يوم فتح</div>
                </div>
            </div>
        </div>
        
        <div class="scene-container">
            <canvas id="cityScene"></canvas>
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="movement-controls">
            <div class="control-row">
                <div class="control-btn" id="forwardBtn">↑</div>
            </div>
            <div class="control-row">
                <div class="control-btn" id="leftBtn">←</div>
                <div class="control-btn" id="backwardBtn">↓</div>
                <div class="control-btn" id="rightBtn">→</div>
            </div>
        </div>
        
        <div class="camera-controls">
            <div class="joystick" id="cameraJoystick">
                <div class="joystick-handle" id="cameraHandle"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Simulate loading progress for better user experience
        const loadingProgress = document.getElementById('loadingProgress');
        const loadingElement = document.querySelector('.loading');
        
        let progress = 0;
        const interval = setInterval(() => {
            progress += Math.random() * 10; // Increment progress randomly
            if (progress >= 100) {
                progress = 100;
                clearInterval(interval);
                setTimeout(() => {
                    loadingElement.style.display = 'none'; // Hide loading screen
                    initScene(); // Initialize the 3D scene
                }, 500); // Short delay before hiding
            }
            loadingProgress.style.width = `${progress}%`; // Update progress bar width
        }, 200);
        
        function initScene() {
            // --- Three.js Scene Setup ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100); // Fog for depth perception
            
            const canvas = document.getElementById('cityScene');
            // WebGLRenderer with antialiasing for smoother edges
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true }); 
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows for better realism
            renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI screens
            
            // Camera setup: PerspectiveCamera for 3D view
            const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            // Initial camera position: facing the store (store is at Z = -20)
            camera.position.set(0, 5, 20); 
            
            // --- Lighting ---
            // Soft ambient light to illuminate all objects
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambientLight);
            
            // Directional light (simulating the sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8); 
            sunLight.position.set(100, 100, 50); // Position of the sun
            sunLight.castShadow = true; // Sun casts shadows
            // Configure shadow map resolution for sharper shadows
            sunLight.shadow.mapSize.width = 2048; 
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 200;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);
            
            // --- Ground ---
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x32CD32, // Brighter green for grass
                roughness: 0.8, // Less shiny
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be flat
            ground.receiveShadow = true; // Ground receives shadows
            scene.add(ground);
            
            // --- Road ---
            const roadGeometry = new THREE.PlaneGeometry(20, 100);
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 }); // Darker grey for road
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.01; // Slightly above ground to avoid z-fighting (flickering)
            road.receiveShadow = true;
            scene.add(road);
            
            // Road markings (yellow dashed lines)
            for (let i = -45; i < 50; i += 5) {
                const markingGeometry = new THREE.PlaneGeometry(1, 0.2);
                const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF00 }); // Yellow markings
                const marking = new THREE.Mesh(markingGeometry, markingMaterial);
                marking.rotation.x = -Math.PI / 2;
                marking.position.set(0, 0.02, i); // Slightly above road
                marking.receiveShadow = true;
                scene.add(marking);
            }
            
            // Function to create generic buildings
            function createBuilding(width, height, depth, color, x, z) {
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({ color });
                const building = new THREE.Mesh(geometry, material);
                building.position.set(x, height/2, z);
                building.castShadow = true; // Building casts shadows
                building.receiveShadow = true; // Building receives shadows
                scene.add(building);
                
                // Add windows for realism (only for taller buildings)
                if (height > 5) {
                    const windowColor = 0xADD8E6; // Light blue for windows
                    const windowSpacing = 2; // Vertical spacing between windows
                    const windowWidth = 0.5;
                    const windowHeight = 1;
                    const windowDepth = 0.1;
                    const windowMaterial = new THREE.MeshStandardMaterial({ color: windowColor, roughness: 0.2, metalness: 0.5 });
                    
                    // Add windows to front and back faces
                    for (let y = 2; y < height - 1; y += windowSpacing) {
                        // Front windows (positive Z side of building)
                        for (let offset of [-width/4, width/4]) {
                            const window = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
                            window.position.set(x + offset, y, z + depth/2 + windowDepth/2);
                            scene.add(window);
                        }
                        // Back windows (negative Z side of building)
                        for (let offset of [-width/4, width/4]) {
                            const window = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
                            window.position.set(x + offset, y, z - depth/2 - windowDepth/2);
                            scene.add(window);
                        }
                    }

                    // Add windows to left and right faces
                    for (let y = 2; y < height - 1; y += windowSpacing) {
                        // Left windows (negative X side of building)
                        for (let offset of [-depth/4, depth/4]) {
                            const window = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
                            window.position.set(x - width/2 - windowDepth/2, y, z + offset);
                            scene.add(window);
                        }
                        // Right windows (positive X side of building)
                        for (let offset of [-depth/4, depth/4]) {
                            const window = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
                            window.position.set(x + width/2 + windowDepth/2, y, z + offset);
                            scene.add(window);
                        }
                    }
                }
                
                return building;
            }
            
            // Create city buildings
            const buildings = [];
            
            // Left side buildings
            for (let i = -40; i < 40; i += 8) {
                const width = 6 + Math.random() * 4;
                const height = 5 + Math.random() * 10;
                const depth = 6 + Math.random() * 4;
                const color = new THREE.Color(Math.random() * 0x888888 + 0x777777); // Greyish random colors
                
                buildings.push(createBuilding(width, height, depth, color, -15, i));
            }
            
            // Right side buildings
            for (let i = -40; i < 40; i += 8) {
                const width = 6 + Math.random() * 4;
                const height = 5 + Math.random() * 10;
                const depth = 6 + Math.random() * 4;
                const color = new THREE.Color(Math.random() * 0x888888 + 0x777777);
                
                buildings.push(createBuilding(width, height, depth, color, 15, i));
            }
            
            // Function to create the vegetable store with specific fruits/vegetables
            function createVegetableStore() {
                // Main store building dimensions
                const storeWidth = 20;
                const storeHeight = 10;
                const storeDepth = 15;
                const storeColor = 0x66BB6A; // A more vibrant green for the store
                const store = createBuilding(storeWidth, storeHeight, storeDepth, storeColor, 0, -20);
                
                // Define Z positions for front and back of the store
                const storeFrontZ = store.position.z + storeDepth / 2; // Front of the store (facing positive Z)
                
                // Store roof (pitched roof for a more distinct look)
                const roofGeometry = new THREE.ConeGeometry(storeWidth * 0.7, 5, 4); // Wider base, taller
                const roofMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D }); // Sienna brown
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, storeHeight + 2.5, store.position.z); // Center the roof over the building
                roof.rotation.y = Math.PI / 4; // Rotate for a diamond-like appearance
                roof.castShadow = true;
                scene.add(roof);
                
                // Entrance Awning
                const awningGeometry = new THREE.BoxGeometry(storeWidth * 0.6, 1, 3);
                const awningMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 }); // Gold color
                const awning = new THREE.Mesh(awningGeometry, awningMaterial);
                awning.position.set(0, storeHeight * 0.7, storeFrontZ + 1.5);
                awning.castShadow = true;
                scene.add(awning);
            
                // Store Sign (animated)
                const signGeometry = new THREE.BoxGeometry(12, 2, 0.5);
                const signMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF }); // White sign background
                const sign = new THREE.Mesh(signGeometry, signMaterial);
                sign.position.set(0, storeHeight + 0.5, storeFrontZ + 0.2);
                sign.castShadow = true;
                // Add a class to the sign's material for CSS animation (handled in CSS)
                sign.material.name = 'store-sign-animated'; // A custom property to identify for animation
                scene.add(sign);
            
                // Text for the sign (simple placeholder, actual text rendering is complex in Three.js)
                // For a more advanced text, you'd typically use TextGeometry with a FontLoader.
                // Here, we'll just add a simple plane that *looks* like text is on it.
                const textGeo = new THREE.PlaneGeometry(10, 1.5);
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0x4CAF50, transparent: true, opacity: 0.9 });
                const textMesh = new THREE.Mesh(textGeo, textMaterial);
                textMesh.position.set(0, storeHeight + 0.5, storeFrontZ + 0.25);
                scene.add(textMesh);

                // Glass Door
                const doorWidth = 3; 
                const doorHeight = 6; 
                const doorDepth = 0.1; // Thinness of the glass
                
                // Glass material: transparent, slightly blue/green tint, reflective
                const glassMaterial = new THREE.MeshStandardMaterial({
                    color: 0xAADDFF, // Light blue tint for glass
                    transparent: true,
                    opacity: 0.5, // Semi-transparent
                    roughness: 0.1, // Very smooth for reflective quality
                    metalness: 0.9, // Highly metallic for reflections
                    side: THREE.DoubleSide // Render both sides of the plane
                });

                const glassDoor = new THREE.Mesh(
                    new THREE.BoxGeometry(doorWidth, doorHeight, doorDepth),
                    glassMaterial
                );
                glassDoor.position.set(0, doorHeight / 2, storeFrontZ + doorDepth / 2);
                glassDoor.castShadow = true;
                scene.add(glassDoor);

                // Door Frame (simple thin boxes around the glass)
                const frameThickness = 0.2;
                const frameColor = 0x333333; // Dark grey for the frame

                // Top Frame
                const topFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(doorWidth + frameThickness * 2, frameThickness, doorDepth),
                    new THREE.MeshStandardMaterial({ color: frameColor })
                );
                topFrame.position.set(0, doorHeight + frameThickness / 2, storeFrontZ + doorDepth / 2);
                scene.add(topFrame);

                // Bottom Frame
                const bottomFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(doorWidth + frameThickness * 2, frameThickness, doorDepth),
                    new THREE.MeshStandardMaterial({ color: frameColor })
                );
                bottomFrame.position.set(0, frameThickness / 2, storeFrontZ + doorDepth / 2);
                scene.add(bottomFrame);

                // Left Frame
                const leftFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(frameThickness, doorHeight, doorDepth),
                    new THREE.MeshStandardMaterial({ color: frameColor })
                );
                leftFrame.position.set(-doorWidth / 2 - frameThickness / 2, doorHeight / 2, storeFrontZ + doorDepth / 2);
                scene.add(leftFrame);

                // Right Frame
                const rightFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(frameThickness, doorHeight, doorDepth),
                    new THREE.MeshStandardMaterial({ color: frameColor })
                );
                rightFrame.position.set(doorWidth / 2 + frameThickness / 2, doorHeight / 2, storeFrontZ + doorDepth / 2);
                scene.add(rightFrame);
            
                // Display Stands (simple boxes)
                function createStand(x, z, width, depth, height, color) {
                    const standGeometry = new THREE.BoxGeometry(width, height, depth);
                    const standMaterial = new THREE.MeshStandardMaterial({ color: color });
                    const stand = new THREE.Mesh(standGeometry, standMaterial);
                    stand.position.set(x, height / 2, z);
                    stand.castShadow = true;
                    stand.receiveShadow = true;
                    scene.add(stand);
                    return stand;
                }
            
                // Create specific fruits/vegetables with more distinct shapes
                const fruitsAndVeggies = [];
            
                // Apple (Red sphere with a small brown stem)
                function createApple(x, y, z) {
                    const appleBody = new THREE.Mesh(
                        new THREE.SphereGeometry(0.6, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xFF3B30, roughness: 0.5 })
                    );
                    appleBody.position.set(x, y, z);
                    appleBody.castShadow = true;
                    
                    const stem = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.08, 0.4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    stem.position.set(x, y + 0.6, z);
                    stem.castShadow = true;
                    
                    fruitsAndVeggies.push(appleBody, stem);
                    scene.add(appleBody, stem);
                }
            
                // Orange (Orange sphere, slightly squashed)
                function createOrange(x, y, z) {
                    const orange = new THREE.Mesh(
                        new THREE.SphereGeometry(0.65, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xFF9500, roughness: 0.6 })
                    );
                    orange.scale.y = 0.9; // Slightly squashed
                    orange.position.set(x, y, z);
                    orange.castShadow = true;
                    fruitsAndVeggies.push(orange);
                    scene.add(orange);
                }
            
                // Mango (Elongated shape - approximated with a stretched sphere)
                function createMango(x, y, z) {
                    const mango = new THREE.Mesh(
                        new THREE.SphereGeometry(0.7, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xFFCC00, roughness: 0.5 }) // Yellowish
                    );
                    mango.scale.set(0.8, 1.2, 0.8); // Elongated
                    mango.rotation.z = Math.PI / 8; // Slight tilt
                    mango.position.set(x, y, z);
                    mango.castShadow = true;
                    fruitsAndVeggies.push(mango);
                    scene.add(mango);
                }
            
                // Tomato (Red sphere)
                function createTomato(x, y, z) {
                    const tomato = new THREE.Mesh(
                        new THREE.SphereGeometry(0.55, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xFF3B30, roughness: 0.4 })
                    );
                    tomato.position.set(x, y, z);
                    tomato.castShadow = true;
                    fruitsAndVeggies.push(tomato);
                    scene.add(tomato);
                }
            
                // Positioning fruits/vegetables on stands
                const standY = 0.5; // Height of the stand
                const vegYOffset = standY + 0.6; // Position above the stand
                
                // New Z position for the stands, further back inside the store
                const standZPosition = store.position.z - 6; 
                
                const stand1 = createStand(-4, standZPosition, 3, 3, standY, 0x8B4513);
                for (let i = 0; i < 5; i++) {
                    createApple(stand1.position.x + Math.random() * 1.5 - 0.75, vegYOffset, stand1.position.z + Math.random() * 1.5 - 0.75);
                }
            
                const stand2 = createStand(0, standZPosition, 3, 3, standY, 0x8B4513);
                for (let i = 0; i < 5; i++) {
                    createOrange(stand2.position.x + Math.random() * 1.5 - 0.75, vegYOffset, stand2.position.z + Math.random() * 1.5 - 0.75);
                }
            
                const stand3 = createStand(4, standZPosition, 3, 3, standY, 0x8B4513);
                for (let i = 0; i < 5; i++) {
                    createMango(stand3.position.x + Math.random() * 1.5 - 0.75, vegYOffset, stand3.position.z + Math.random() * 1.5 - 0.75);
                }
            
                const stand4 = createStand(8, standZPosition, 3, 3, standY, 0x8B4513);
                for (let i = 0; i < 5; i++) {
                    createTomato(stand4.position.x + Math.random() * 1.5 - 0.75, vegYOffset, stand4.position.z + Math.random() * 1.5 - 0.75);
                }
            
                return store;
            }
            
            const vegetableStore = createVegetableStore();
            
            // Add trees
            function createTree(x, z) {
                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.5, 3, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, 1.5, z);
                trunk.castShadow = true;
                scene.add(trunk);
                
                // Leaves (more detailed shape using a Dodecahedron)
                const leavesGeometry = new THREE.DodecahedronGeometry(2); // More organic shape
                const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 }); // Forest green
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(x, 4.5, z);
                leaves.castShadow = true;
                scene.add(leaves);
                
                return { trunk, leaves };
            }
            
            // Create trees along the road, avoiding the store's Z-range
            const trees = [];
            // Store's Z-range: -20 (center) +/- 15/2 (depth/2) = -27.5 to -12.5
            const storeMinZ = -27.5;
            const storeMaxZ = -12.5;

            for (let i = -35; i < 35; i += 7) {
                // Check if the current Z position is outside the store's Z range
                if (i < storeMinZ || i > storeMaxZ) {
                    trees.push(createTree(-8, i));
                    trees.push(createTree(8, i));
                }
            }
            
            // --- Camera controls state ---
            const moveState = { forward: false, backward: false, left: false, right: false };
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            const movementSpeed = 0.2; // Speed of camera movement
            const rotationSpeed = 0.005; // Speed of camera rotation
            
            // --- Keyboard controls for desktop movement ---
            document.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': moveState.forward = true; break;
                    case 's': moveState.backward = true; break;
                    case 'a': moveState.left = true; break;
                    case 'd': moveState.right = true; break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': moveState.forward = false; break;
                    case 's': moveState.backward = false; break;
                    case 'a': moveState.left = false; break;
                    case 'd': moveState.right = false; break;
                }
            });
            
            // --- Mobile movement buttons (touchstart/touchend for continuous movement) ---
            document.getElementById('forwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent default browser touch behavior (e.g., scrolling)
                moveState.forward = true;
            });
            document.getElementById('forwardBtn').addEventListener('touchend', () => moveState.forward = false);
            
            document.getElementById('backwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                moveState.backward = true;
            });
            document.getElementById('backwardBtn').addEventListener('touchend', () => moveState.backward = false);
            
            document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                moveState.left = true;
            });
            document.getElementById('leftBtn').addEventListener('touchend', () => moveState.left = false);
            
            document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                moveState.right = true;
            });
            document.getElementById('rightBtn').addEventListener('touchend', () => moveState.right = false);
            
            // --- Mouse and touch camera controls for rotation ---
            let previousMouseX = 0;
            let previousMouseY = 0;
            let mouseMoved = false;
            let isDragging = false;
            
            // Mouse controls for desktop camera rotation
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
                mouseMoved = false;
                canvas.style.cursor = 'grabbing'; // Change cursor to indicate dragging
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab'; // Reset cursor
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                // Skip first move to prevent jump
                if (!mouseMoved) {
                    previousMouseX = e.clientX;
                    previousMouseY = e.clientY;
                    mouseMoved = true;
                    return;
                }
                
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;
                
                // Rotate camera around Y (yaw) and X (pitch) axes
                camera.rotation.y -= deltaX * rotationSpeed;
                // Limit vertical rotation to prevent flipping
                camera.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x - deltaY * rotationSpeed)); 
                
                previousMouseX = e.clientX;
                previousMouseY = e.clientY; 
            });
            
            // Touch controls for camera rotation (single touch for rotation)
            let touchId = null; // To track a single touch for camera rotation
            let previousTouchX = 0;
            let previousTouchY = 0;
            
            canvas.addEventListener('touchstart', (e) => {
                // Only track the first touch if no touch is currently tracked
                if (e.touches.length === 1 && touchId === null) { 
                    const touch = e.touches[0];
                    touchId = touch.identifier;
                    previousTouchX = touch.clientX;
                    previousTouchY = touch.clientY;
                }
            }, { passive: false }); // Use passive: false to allow e.preventDefault()
            
            canvas.addEventListener('touchmove', (e) => {
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    if (touch.identifier === touchId) { // Only process the tracked touch
                        const deltaX = touch.clientX - previousTouchX;
                        const deltaY = touch.clientY - previousTouchY;
                        
                        camera.rotation.y -= deltaX * rotationSpeed;
                        camera.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x - deltaY * rotationSpeed));
                        
                        previousTouchX = touch.clientX;
                        previousTouchY = touch.clientY;
                        e.preventDefault(); // Prevent scrolling/zooming
                        break;
                    }
                }
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        touchId = null; // Reset tracked touch when it ends
                        break;
                    }
                }
            });
            
            // --- Camera joystick for mobile (alternative to direct screen drag) ---
            const cameraJoystick = document.getElementById('cameraJoystick');
            const cameraHandle = document.getElementById('cameraHandle');
            let joystickActive = false;
            let joystickCenterX = 0;
            let joystickCenterY = 0;
            let joystickRadius = 0;
            
            // Initialize joystick position and size
            function initJoystick() {
                const rect = cameraJoystick.getBoundingClientRect();
                joystickCenterX = rect.left + rect.width / 2;
                joystickCenterY = rect.top + rect.height / 2;
                joystickRadius = rect.width / 2 - cameraHandle.clientWidth / 2; // Radius for handle movement
            }
            
            window.addEventListener('resize', initJoystick); // Re-initialize on resize
            initJoystick(); // Initial setup
            
            cameraHandle.addEventListener('touchstart', (e) => {
                joystickActive = true;
                e.preventDefault(); // Prevent default touch behavior
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (!joystickActive) return;
                
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    // Check if this touch is within the joystick area or the one that started the drag
                    // This allows dragging the handle even if touch moves outside its initial bounds
                    if (touch.identifier === e.touches[0].identifier) { // Track the first touch
                        const touchX = touch.clientX;
                        const touchY = touch.clientY;
                        
                        // Calculate distance from center
                        const dx = touchX - joystickCenterX;
                        const dy = touchY - joystickCenterY;
                        const distance = Math.min(Math.sqrt(dx*dx + dy*dy), joystickRadius);
                        
                        // Calculate angle
                        const angle = Math.atan2(dy, dx);
                        
                        // Position handle within the joystick boundary
                        const handleX = Math.cos(angle) * distance;
                        const handleY = Math.sin(angle) * distance;
                        cameraHandle.style.transform = `translate(${handleX}px, ${handleY}px)`;
                        
                        // Rotate camera based on joystick handle position
                        // Scale rotation speed for joystick to make it less sensitive
                        camera.rotation.y -= dx * rotationSpeed * 0.2; 
                        camera.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x - dy * rotationSpeed * 0.2));
                        
                        e.preventDefault(); // Prevent scrolling
                        break;
                    }
                }
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                // Ensure the touch that started the joystick drag has ended
                let touchEnded = false;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].target === cameraHandle) {
                        touchEnded = true;
                        break;
                    }
                }

                if (joystickActive && touchEnded) {
                    joystickActive = false;
                    cameraHandle.style.transform = 'translate(0, 0)'; // Reset handle position
                }
            });
            
            // Get reference to the info panel
            const infoPanel = document.querySelector('.info-panel');
            // Get reference to the store sign for animation
            const storeSignMesh = scene.children.find(obj => obj.material && obj.material.name === 'store-sign-animated');
            
            // Define the store door's approximate position (center of the door)
            const storeDepth = 15;
            const storeZ = -20;
            const storeFrontZ = storeZ + storeDepth / 2; // -12.5
            const doorDepth = 0.1;
            // Using camera's fixed Y (5) for simpler 2D distance calculation in XZ plane
            const doorTriggerPosition = new THREE.Vector3(0, 5, storeFrontZ + doorDepth / 2); 
            const doorTriggerRadius = 7; // Radius around the door to activate the panel

            // --- Animation and rendering loop ---
            function animate() {
                requestAnimationFrame(animate);
                
                // Reset velocity for current frame
                velocity.x = 0;
                velocity.z = 0;
                
                // Apply movement based on moveState (keyboard/mobile buttons)
                if (moveState.forward) {
                    velocity.z -= movementSpeed;
                }
                if (moveState.backward) {
                    velocity.z += movementSpeed;
                }
                if (moveState.left) {
                    velocity.x -= movementSpeed;
                }
                if (moveState.right) {
                    velocity.x += movementSpeed;
                }
                
                // Apply camera's current rotation to the movement direction
                direction.set(velocity.x, 0, velocity.z);
                direction.applyQuaternion(camera.quaternion);
                direction.y = 0; // Keep movement on the horizontal plane (prevent flying up/down)
                
                // Update camera position
                camera.position.add(direction);
                
                // Keep camera above ground level (fixed height)
                camera.position.y = 5;
                
                // Boundary checks to keep camera within the city limits
                camera.position.x = Math.max(-45, Math.min(45, camera.position.x));
                camera.position.z = Math.max(-45, Math.min(45, camera.position.z));

                // Check distance to store door and toggle info panel visibility
                const distanceToDoor = camera.position.distanceTo(doorTriggerPosition);
                if (distanceToDoor < doorTriggerRadius) {
                    infoPanel.classList.add('show'); // Add 'show' class to fade in and display
                } else {
                    infoPanel.classList.remove('show'); // Remove 'show' class to fade out and hide
                }

                // Apply pulsating animation to the store sign
                if (storeSignMesh) {
                    // This is a simple JS-driven animation. For more complex CSS animations,
                    // you'd typically apply CSS classes to HTML elements.
                    // Here, we simulate the CSS 'pulse' animation by scaling the mesh.
                    const scale = 1 + Math.sin(Date.now() * 0.002) * 0.03; // Scale between 0.97 and 1.03
                    storeSignMesh.scale.set(scale, scale, 1);
                }
                
                renderer.render(scene, camera); // Render the scene
            }
            
            // Handle window resize for responsiveness
            window.addEventListener('resize', () => {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix(); // Update camera projection
                renderer.setSize(canvas.clientWidth, canvas.clientHeight); // Resize renderer
                initJoystick(); // Re-initialize joystick position and size
            });
            
            // Start the animation loop when the scene is initialized
            animate();

            // --- Calculator Logic ---
            const itemsContainer = document.getElementById('itemsContainer');
            const calculateTotalBtn = document.getElementById('calculateTotalBtn');
            const totalAmountSpan = document.getElementById('totalAmount');

            // Define the fruits/vegetables for the calculator
            const products = [
                { name: 'تفاح', emoji: '🍎', id: 'apple' },
                { name: 'برتقال', emoji: '🍊', id: 'orange' },
                { name: 'مانجو', emoji: '🥭', id: 'mango' },
                { name: 'طماطم', emoji: '🍅', id: 'tomato' },
                { name: 'خيار', emoji: '🥒', id: 'cucumber' },
                { name: 'جزر', emoji: '🥕', id: 'carrot' },
                { name: 'فلفل', emoji: '🌶️', id: 'pepper' },
                { name: 'بطاطس', emoji: '🥔', id: 'potato' },
                { name: 'باذنجان', emoji: '🍆', id: 'eggplant' },
                { name: 'كرنب', emoji: '🥬', id: 'cabbage' },
                { name: 'بصل', emoji: '🧅', id: 'onion' }
            ];

            // Function to create an item row for the calculator
            function createItemRow(product) {
                const itemRow = document.createElement('div');
                itemRow.className = 'item-row';
                itemRow.setAttribute('data-item-id', product.id);

                itemRow.innerHTML = `
                    <span class="item-name">${product.name} ${product.emoji}</span>
                    <div class="input-group">
                        <label for="${product.id}-quantity">الكمية (كجم)</label>
                        <input type="number" id="${product.id}-quantity" class="quantity-input" placeholder="0.0" min="0" step="0.1" value="0">
                    </div>
                    <div class="input-group">
                        <label for="${product.id}-price">السعر/كجم</label>
                        <input type="number" id="${product.id}-price" class="price-input" placeholder="0.00" min="0" step="0.01" value="0.00">
                    </div>
                `;
                itemsContainer.appendChild(itemRow);
            }

            // Populate the calculator with all products
            products.forEach(product => createItemRow(product));

            // Function to calculate the total amount
            function calculateTotal() {
                let total = 0;
                const itemRows = itemsContainer.querySelectorAll('.item-row');

                itemRows.forEach(row => {
                    const quantityInput = row.querySelector('.quantity-input');
                    const priceInput = row.querySelector('.price-input');

                    // Ensure values are parsed as floats, default to 0 if invalid
                    const quantity = parseFloat(quantityInput.value) || 0;
                    const price = parseFloat(priceInput.value) || 0;

                    total += quantity * price;
                });

                totalAmountSpan.textContent = total.toFixed(2); // Display total with 2 decimal places
            }

            // Attach event listener to the calculate button
            calculateTotalBtn.addEventListener('click', calculateTotal);

            // Optional: Automatically calculate total when input values change
            // This provides real-time feedback as the user types
            itemsContainer.addEventListener('input', (event) => {
                if (event.target.classList.contains('quantity-input') || event.target.classList.contains('price-input')) {
                    calculateTotal();
                }
            });

            // Initial calculation when the page loads
            calculateTotal();
        }
    </script>
</body>
</html>

