<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>لعبة الدراجة النارية التعليمية</title>
    <!-- تضمين مكتبة three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- تضمين Tailwind CSS لتصميم جميل وسريع -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- تضمين مكتبة MathJax لعرض الرموز الرياضية بشكل صحيح -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* إعادة تعيين الأنماط الافتراضية للمتصفح */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation; /* يمنع سلوكيات اللمس الافتراضية مثل التكبير والتصغير */
        }
        
        /* خط Tajawal لدعم اللغة العربية */
        @import url('https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700&display=swap');
        body {
            font-family: 'Tajawal', sans-serif;
            direction: rtl;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            perspective: 1000px;
        }

        /* شاشة البدء */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 10, 30, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            padding: 20px;
            transition: opacity 0.8s ease-out;
            backdrop-filter: blur(5px);
        }

        #startScreen h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        #startScreen p {
            font-size: clamp(1rem, 2vw, 1.2rem);
            margin-bottom: 30px;
            max-width: 80%;
            color: #e0f7ff;
            line-height: 1.6;
        }

        .start-btn {
            padding: 15px 40px;
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            background: linear-gradient(to bottom, #ff8c00, #ff4500);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to bottom, #ff9d00, #ff5500);
        }

        .start-btn:active {
            transform: scale(0.95);
        }

        .floatingMotorcycle {
            font-size: 5rem;
            margin-bottom: 30px;
            animation: float 3s infinite ease-in-out;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.7));
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-20px);
            }
        }

        .container {
            width: 100%;
            height: 100%;
            padding: 0;
            position: relative;
            transform-style: preserve-3d;
            animation: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.1);
            overflow: hidden;
            border: none;
            box-shadow: none;
            margin: 0;
            transform-style: preserve-3d;
            transition: all 0.5s;
            flex-grow: 1;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .game-stats {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: none;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            color: white;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 10;
            padding: 5px; /* تصغير المساحة الداخلية */
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            backdrop-filter: blur(5px);
            gap: 5px; /* تصغير المسافة بين العناصر */
        }

        .game-stats span {
            padding: 5px 10px; /* تصغير المساحة الداخلية للأيقونات */
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 0 2px; /* تصغير المسافة بين الأيقونات */
            min-width: 90px; /* تقليل العرض الأدنى */
            display: inline-flex;
            justify-content: center;
            font-size: 0.9rem; /* تصغير حجم الخط */
        }

        .game-stats #speedDisplay {
            font-weight: bold;
            color: #ffeb3b;
        }

        .game-stats #scoreDisplay {
            color: #4caf50;
            font-weight: bold;
        }
        
        /* نمط الزر الموسيقى */
        #musicToggleBtn {
            padding: 8px 12px !important; /* تصغير حجم الزر */
            background: linear-gradient(to bottom, #5cb85c, #4cae4c);
            font-size: 1.2rem; /* حجم الأيقونة */
            min-width: 40px !important; /* تقليل العرض الأدنى */
            min-height: 40px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid #ff8c00;
            text-align: center;
            z-index: 100;
            display: none;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.5);
            width: 90%;
            max-width: 500px;
            animation: gameOverAppear 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(10px);
        }

        @keyframes gameOverAppear {
            0% {
                transform: translate(-50%, -60%);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        #gameOver h2 {
            font-size: clamp(2rem, 5vw, 2.5rem);
            color: #ffc107;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255, 193, 7, 0.7);
        }

        #finalScore {
            font-size: clamp(1.8rem, 4vw, 2.2rem);
            color: #fff;
            margin: 20px 0;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
        }

        #highScore {
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            color: #ccc;
            margin-bottom: 20px;
        }

        #gameOver p {
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(255, 0, 0, 0.2);
            border-radius: 8px;
        }

        .controls-container {
            display: flex;
            flex-direction: column; /* جعل العناصر تتكدس عموديًا */
            justify-content: center;
            align-items: center;
            gap: 15px; /* مسافة بين العناصر */
            padding: 15px 0;
            width: 100%;
            position: fixed;
            bottom: 0;
            z-index: 1000;
            display: none;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .control-btn {
            padding: 15px 40px;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            min-width: 150px;
        }

        .control-btn:hover {
            transform: scale(1.05);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        #boostBtn {
            background: linear-gradient(to bottom, #ffd700, #ff8c00);
        }

        #jumpBtn {
            background: linear-gradient(to bottom, #1e90ff, #0077cc);
        }

        /* أنماط شريط التمرير المخصص للموسيقى */
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease-in-out;
        }
        .slider-thumb::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease-in-out;
        }

        #touchLeft, #touchRight {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            z-index: 5;
        }

        #touchLeft {
            left: 0;
        }

        #touchRight {
            right: 0;
        }

        .collectible-effect {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 20;
            display: none;
            animation: collectPulse 0.6s ease-out;
        }

        @keyframes collectPulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .collision-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.8) 0%, rgba(255, 0, 0, 0) 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 20;
            display: none;
            animation: collisionFlash 0.5s ease-out;
        }

        @keyframes collisionFlash {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .road {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 60%;
            background: linear-gradient(to top, #8B4513, #5D2906);
            z-index: -1;
            border-top: 4px solid #654321;
        }

        .road-lines {
            position: absolute;
            bottom: 50%;
            width: 100%;
            height: 10px;
            background: repeating-linear-gradient(to right, transparent, transparent 30px, #ffd700 30px, #ffd700 60px);
            z-index: -1;
        }

        /* تم تعديل هذا النمط ليكون ضمن الـ flexbox */
        .instructions {
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1rem;
            margin-top: 5px; /* إضافة مسافة من الأعلى */
        }
        
        /* إزالة الأنماط الخاصة بعناصر التحكم في الموسيقى القديمة */
        #musicControls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            width: auto;
            max-width: none;
        }
        
        /* حاوية السؤال التعليمي */
        #questionScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            display: none;
        }
        
        .question-container {
            background: white;
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            text-align: center;
        }
        
        .question-container h1 {
            color: #1a2a6c;
            margin-bottom: 1rem;
        }
        
        .question-container .math-symbol {
            font-size: 2.5rem;
            font-weight: bold;
            margin: 0 10px;
        }
        
        .options-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        
        .option-btn {
            padding: 15px 30px;
            background: #1e90ff;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 100px;
        }
        
        .option-btn:hover {
            background: #0077cc;
            transform: scale(1.05);
        }
        
        .result-message {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 20px 0;
            display: none;
        }
        
        .correct {
            color: #4CAF50;
        }
        
        .incorrect {
            color: #f44336;
        }

        @media (max-width: 768px) {
            .game-stats {
                font-size: 0.8rem; /* تصغير حجم الخط على الجوال */
                flex-wrap: wrap;
                justify-content: center;
                gap: 5px;
            }

            .game-stats span {
                padding: 4px 8px; /* تصغير المساحة الداخلية على الجوال */
                margin: 5px;
                min-width: 80px; /* تقليل العرض الأدنى على الجوال */
                font-size: 0.7rem; /* تصغير حجم الخط على الجوال */
            }

            #gameOver {
                padding: 20px;
                width: 95%;
            }

            .control-btn {
                padding: 12px 25px;
                min-width: 120px;
                font-size: 0.9rem;
            }
            
            .question-container {
                padding: 1rem;
            }
            
            .option-btn {
                padding: 10px 20px;
                font-size: 1.2rem;
                min-width: 80px;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <div class="floatingMotorcycle">🏍️</div>
        <h1>🚀 لعبة الدراجة النارية التعليمية</h1>
        <p>تحدٍ جديد! عندما تصطدم بعائق، ستحل سؤالًا تعليميًا. إذا أجبت بشكل صحيح، ستواصل اللعب. إذا أخطأت، تنتهي اللعبة!</p>
        <button id="startGameBtn" class="start-btn">ابدأ اللعب</button>
    </div>

    <div class="container">
        <div id="gameContainer">
            <div id="touchLeft"></div>
            <div id="touchRight"></div>
            <div class="road"></div>
            <div class="road-lines"></div>

            <div class="game-stats flex-row items-center gap-4">
                <span id="scoreDisplay">النقاط: 0</span>
                <span id="shieldDisplay">الدرع: 0</span>
                <span id="speedDisplay">السرعة: 0</span>
                <span id="timerDisplay">الوقت: 60</span>
                <button id="musicToggleBtn" class="control-btn rounded-full min-w-0">🎶</button>
            </div>

            <div id="gameOver">
                <h2>انتهت اللعبة!</h2>
                <p id="gameOverReason">لقد اصطدمت بعائق</p>
                <div id="finalScore">النقاط: 0</div>
                <div id="highScore">أفضل نتيجة: 0</div>
                <button id="restart-btn" class="start-btn">العب مرة أخرى</button>
            </div>
            <div class="collectible-effect" id="collectEffect"></div>
            <div class="collision-effect" id="collisionEffect"></div>
        </div>

        <div class="controls-container">
            <div class="flex flex-row items-center justify-center gap-4 w-full">
                <button id="jumpBtn" class="control-btn">القفز</button>
                <button id="boostBtn" class="control-btn">التسارع</button>
            </div>
            <div class="instructions">استخدم الجانب الأيسر للتحرك لليسار، الجانب الأيمن للتحرك لليمين</div>
        </div>
    </div>
    
    <!-- شاشة السؤال التعليمي -->
    <div id="questionScreen">
        <div class="question-container">
            <h1 id="question-title">سؤال: مقارنة الأعداد النسبية</h1>
            <div id="question-container" class="mb-8">
                <p class="text-xl sm:text-2xl text-gray-700">قارن بين العددين النسبيين:</p>
                <div class="flex justify-center items-center my-4">
                    <span id="number1" class="text-4xl font-semibold text-blue-600"></span>
                    <span class="math-symbol mx-4 text-gray-500"> □ </span>
                    <span id="number2" class="text-4xl font-semibold text-blue-600"></span>
                </div>
            </div>

            <div id="options-container" class="options-container">
                <!-- الخيارات سيتم إضافتها هنا بواسطة JavaScript -->
            </div>

            <div id="result-message" class="result-message"></div>
        </div>
    </div>

    <script>
        // العناصر الأساسية للعبة
        let scene, camera, renderer, motorcycle;
        let obstacles = [], collectibles = [], roadMarkings = [], sceneryObjects = [];
        let score = 0, timer = 60, gameActive = false, highScore = 0;
        let baseSpeed = 0.0003; // السرعة الأساسية الثابتة
        let currentSpeed = baseSpeed; // السرعة الحالية تبدأ بالسرعة الأساسية
        let maxBoostSpeed = baseSpeed * 2.5; // السرعة القصوى عند التعزيز
        let acceleration = 0.00002; // معدل التسارع عند التعزيز
        let laneWidth = 4;
        let targetLanePosition = 0;
        let isJumping = false;
        let jumpProgress = 0;
        const jumpHeight = 2; // زيادة الارتفاع لقفز أعلى
        const jumpDuration = 1000;
        let shieldActive = false, boostActive = false;
        let shieldCount = 0, boostCount = 0;
        let touchStartX = null;
        let touchStartY = null;
        let timerInterval = null;
        let animationFrameId = null;
        let steeringAngle = 0;
        const maxSteeringAngle = Math.PI / 6; // 30 درجة
        let steeringSpeed = 0.06;
        let steeringReturnSpeed = 0.02;

        // متغيرات المسار والموضع للطريق المنحني
        let curve;
        let t = 0;
        const curveLength = 1000;

        // عناصر واجهة المستخدم
        const restartBtn = document.getElementById('restart-btn');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');
        const highScoreDisplay = document.getElementById('highScore');
        const gameContainer = document.getElementById('gameContainer');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const shieldDisplay = document.getElementById('shieldDisplay');
        const speedDisplay = document.getElementById('speedDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const gameStatsContainer = document.querySelector('.game-stats');
        const startScreen = document.getElementById('startScreen');
        const startGameBtn = document.getElementById('startGameBtn');
        const gameOverReason = document.getElementById('gameOverReason');
        const jumpBtn = document.getElementById('jumpBtn');
        const boostBtn = document.getElementById('boostBtn');
        const controlsContainer = document.querySelector('.controls-container');
        const touchLeft = document.getElementById('touchLeft');
        const touchRight = document.getElementById('touchRight');
        const collectEffect = document.getElementById('collectEffect');
        const collisionEffect = document.getElementById('collisionEffect');
        
        // عناصر السؤال التعليمي
        const questionScreen = document.getElementById('questionScreen');
        const number1El = document.getElementById('number1');
        const number2El = document.getElementById('number2');
        const optionsContainer = document.getElementById('options-container');
        const resultMessageEl = document.getElementById('result-message');
        const questionTitle = document.getElementById('question-title');
        
        // قائمة برموز المقارنة
        const comparisonSymbols = ['<', '>', '='];
        
        // دالة لتوليد عدد صحيح عشوائي بين min و max
        const getRandomInteger = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        
        // دالة لتوليد عدد عشوائي بين min و max
        const getRandomNumber = (min, max) => Math.random() * (max - min) + min;

        // دالة لتوليد كسر عادي
        const generateFraction = () => {
            const numerator = getRandomInteger(-10, 10);
            let denominator = getRandomInteger(1, 10);
            if (denominator === 0) { // تجنب القسمة على صفر
                denominator = 1;
            }
            const value = numerator / denominator;
            const latex = `$$\\frac{${numerator}}{${denominator}}$$`;
            return { value, latex };
        };

        // دالة لتوليد كسر عشري
        const generateDecimal = () => {
            const integerPart = getRandomInteger(-10, 10);
            let decimalPart = getRandomInteger(0, 999);
            if (integerPart === 0 && decimalPart === 0) {
                decimalPart = getRandomInteger(1, 999);
            }
            const value = parseFloat(`${integerPart}.${decimalPart}`);
            const latex = `$$${value}$$`;
            return { value, latex };
        };
        
        // دالة لتوليد عدد كسري
        const generateMixedNumber = () => {
            const wholeNumber = getRandomInteger(-10, 10);
            const numerator = getRandomInteger(1, 9);
            let denominator = getRandomInteger(numerator + 1, 10);
            if (denominator === 0) {
                denominator = 1;
            }
            const value = wholeNumber + (numerator / denominator);
            const latex = `$$${wholeNumber}\\frac{${numerator}}{${denominator}}$$`;
            return { value, latex };
        }

        // دالة لاختيار وتوليد نوع عشوائي من الأعداد النسبية
        const generateRandomRationalNumber = () => {
            const numberTypes = ['fraction', 'decimal', 'mixed'];
            const selectedType = numberTypes[getRandomInteger(0, numberTypes.length - 1)];
            
            switch (selectedType) {
                case 'fraction':
                    return generateFraction();
                case 'decimal':
                    return generateDecimal();
                case 'mixed':
                    return generateMixedNumber();
                default:
                    return generateFraction();
            }
        };
        
        // دالة لخلط المصفوفة
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };

        // دالة لتوليد السؤال والخيارات
        const generateQuestion = () => {
            const number1 = generateRandomRationalNumber();
            const number2 = generateRandomRationalNumber();
            
            // عرض الأعداد على الشاشة باستخدام تنسيق LaTeX
            number1El.innerHTML = number1.latex;
            number2El.innerHTML = number2.latex;
            
            // تشغيل MathJax لعرض الصيغ الرياضية
            MathJax.typesetPromise([number1El, number2El]);

            let correctAnswer;
            if (number1.value < number2.value) {
                correctAnswer = '<';
            } else if (number1.value > number2.value) {
                correctAnswer = '>';
            } else {
                correctAnswer = '=';
            }

            // إضافة الإجابات الخاطئة
            const wrongAnswers = comparisonSymbols.filter(symbol => symbol !== correctAnswer);
            const allAnswers = shuffleArray([correctAnswer, ...wrongAnswers]);

            optionsContainer.innerHTML = ''; // مسح الخيارات السابقة
            resultMessageEl.textContent = ''; // مسح رسالة النتيجة
            resultMessageEl.classList.remove('correct', 'incorrect');

            allAnswers.forEach(symbol => {
                const button = document.createElement('button');
                button.textContent = symbol;
                button.classList.add('option-btn');
                button.addEventListener('click', () => checkAnswer(button, symbol, correctAnswer));
                optionsContainer.appendChild(button);
            });
            
            return correctAnswer;
        };

        // دالة للتحقق من الإجابة
        const checkAnswer = (button, selectedSymbol, correctAnswer) => {
            const buttons = optionsContainer.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = true; // تعطيل الأزرار بعد الاختيار
            });

            if (selectedSymbol === correctAnswer) {
                resultMessageEl.textContent = 'إجابة صحيحة! 🎉';
                resultMessageEl.classList.add('correct');
                resultMessageEl.style.display = 'block';
                button.classList.remove('option-btn');
                button.classList.add('option-btn', 'bg-green-500');
                
                // الانتقال إلى مكان آمن بعد الإجابة الصحيحة
                setTimeout(() => {
                    moveToSafePosition();
                    questionScreen.style.display = 'none';
                    gameActive = true;
                    animate();
                }, 1500);
            } else {
                resultMessageEl.textContent = 'إجابة خاطئة! 😔';
                resultMessageEl.classList.add('incorrect');
                resultMessageEl.style.display = 'block';
                button.classList.remove('option-btn');
                button.classList.add('option-btn', 'bg-red-500');
                
                // إظهار الإجابة الصحيحة
                const correctButton = Array.from(buttons).find(btn => btn.textContent === correctAnswer);
                if (correctButton) {
                    correctButton.classList.remove('option-btn');
                    correctButton.classList.add('option-btn', 'bg-green-500');
                }
                
                // إنهاء اللعبة بعد الإجابة الخاطئة
                setTimeout(() => {
                    endGame(false, "إجابة خاطئة على السؤال!");
                }, 1500);
            }
        };
        
        // --- متغيرات ووظائف الموسيقى المدمجة ---
        let musicAudioContext;
        let melodyInterval;
        let bassInterval;
        let drumInterval;
        let isMusicPlaying = false;
        let musicEnabled = true;

        const musicToggleBtn = document.getElementById('musicToggleBtn');
        
        // تعريف الكوردات والنوتات المرتبطة بها بالهرتز
        const chords = {
            "Cmaj": [130.81, 164.81, 196.00], // C4, E4, G4
            "Gmaj": [196.00, 246.94, 293.66], // G4, B4, D5
            "Amin": [220.00, 261.63, 329.63], // A4, C5, E5
            "Fmaj": [174.61, 220.00, 261.63]  // F4, A4, C5
        };
        const chordProgression = ["Cmaj", "Amin", "Fmaj", "Gmaj"];
        const bassNotes = {
            "Cmaj": 65.41,  // C2
            "Gmaj": 97.99,  // G2
            "Amin": 110.00, // A2
            "Fmaj": 87.31   // F2
        };

        /**
         * دالة لتشغيل نوتة باستخدام Web Audio API.
         */
        function playMusicNote(frequency, type = 'sine', duration = 0.5, volume = 0.3, release = 0.3) {
            if (!musicAudioContext || !isMusicPlaying) return;
            
            const oscillator = musicAudioContext.createOscillator();
            const gainNode = musicAudioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(musicAudioContext.destination);
            
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            
            const now = musicAudioContext.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.02); // هجوم سريع
            gainNode.gain.linearRampToValueAtTime(volume * 0.7, now + 0.1); // اضمحلال
            gainNode.gain.linearRampToValueAtTime(0, now + duration + release); // تلاشي

            oscillator.start(now);
            oscillator.stop(now + duration + release);
        }

        /**
         * دالة لتوليد وتشغيل صوت طبلة الركل (kick drum).
         */
        function playKick() {
            if (!musicAudioContext || !isMusicPlaying) return;
            const now = musicAudioContext.currentTime;
            
            const osc = musicAudioContext.createOscillator();
            const gain = musicAudioContext.createGain();
            osc.connect(gain);
            gain.connect(musicAudioContext.destination);
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
            
            gain.gain.setValueAtTime(1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
            
            osc.start(now);
            osc.stop(now + 0.5);
        }

        /**
         * دالة لتوليد وتشغيل صوت طبلة الفخ (snare).
         */
        function playSnare() {
            if (!musicAudioContext || !isMusicPlaying) return;
            const now = musicAudioContext.currentTime;
            
            const noise = musicAudioContext.createBufferSource();
            const buffer = musicAudioContext.createBuffer(1, musicAudioContext.sampleRate, musicAudioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < buffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;
            const noiseGain = musicAudioContext.createGain();
            noise.connect(noiseGain);
            noiseGain.connect(musicAudioContext.destination);
            noiseGain.gain.setValueAtTime(0.5, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            noise.start(now);
            noise.stop(now + 0.2);

            const osc = musicAudioContext.createOscillator();
            const oscGain = musicAudioContext.createGain();
            osc.connect(oscGain);
            oscGain.connect(musicAudioContext.destination);
            osc.type = 'triangle';
            osc.frequency.value = 220; // A3
            oscGain.gain.setValueAtTime(0.5, now);
            oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        }
        
        /**
         * دالة لتوليد وتشغيل صوت hi-hat.
         */
        function playHiHat() {
            if (!musicAudioContext || !isMusicPlaying) return;
            const now = musicAudioContext.currentTime;

            const noise = musicAudioContext.createBufferSource();
            const buffer = musicAudioContext.createBuffer(1, musicAudioContext.sampleRate, musicAudioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < buffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;
            const gain = musicAudioContext.createGain();
            noise.connect(gain);
            gain.connect(musicAudioContext.destination);
            
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
            
            noise.start(now);
            noise.stop(now + 0.05);
        }

        /**
         * توليد وتشغيل حلقة موسيقى اللعبة.
         */
        function toggleMusic() {
            // سرعة الموسيقى ثابتة (120 BPM)
            const tempo = 120;
            const intervalTime = (60 / tempo) * 1000;

            if (isMusicPlaying) {
                // إيقاف الموسيقى
                clearInterval(melodyInterval);
                clearInterval(bassInterval);
                clearInterval(drumInterval);
                isMusicPlaying = false;
                musicToggleBtn.textContent = '🎶';
            } else {
                // تشغيل الموسيقى
                if (!musicAudioContext) {
                    musicAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                let melodyIndex = 0;
                const beatsPerChord = 4;

                // حلقة اللحن
                melodyInterval = setInterval(() => {
                    const chordName = chordProgression[Math.floor(melodyIndex / beatsPerChord) % chordProgression.length];
                    const chordNotes = chords[chordName];
                    const noteFrequency = chordNotes[Math.floor(Math.random() * chordNotes.length)];
                    
                    const randomVolume = 0.3 + Math.random() * 0.2;
                    const randomDuration = 0.2 + Math.random() * 0.2;

                    playMusicNote(noteFrequency, 'triangle', randomDuration, randomVolume);
                    melodyIndex++;
                }, intervalTime / 4);

                // حلقة البيس
                let bassIndex = 0;
                bassInterval = setInterval(() => {
                    const chordName = chordProgression[bassIndex % chordProgression.length];
                    const bassFrequency = bassNotes[chordName];
                    playMusicNote(bassFrequency, 'sine', 1, 0.2);
                    bassIndex++;
                }, intervalTime);

                // حلقة الطبول
                let drumIndex = 0;
                drumInterval = setInterval(() => {
                    if (drumIndex % 4 === 0) {
                        playKick();
                    }
                    if (drumIndex % 4 === 2) {
                        playSnare();
                    }
                    if (drumIndex % 2 === 0) {
                        playHiHat();
                    }
                    drumIndex++;
                }, intervalTime / 4);

                isMusicPlaying = true;
                musicToggleBtn.textContent = '🔇';
            }
        }
        
        // --- نهاية متغيرات ووظائف الموسيقى المدمجة ---
        
        // إنشاء مؤثرات صوتية للعبة
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = false;

        function playSound(frequency, type = 'sine', duration = 0.1, volume = 0.3) {
            if (!soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            
            // إضافة تلاشي بسيط لتجنب النقرات
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // دالة جديدة لتشغيل صوت اصطدام ناعم
        function playCollisionSound() {
            if (!soundEnabled) return;
            // صوت ناعم وباسي
            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = 'sine'; // موجة جيبية ناعمة
            oscillator1.frequency.setValueAtTime(100, audioContext.currentTime);
            gainNode1.gain.setValueAtTime(0.7, audioContext.currentTime);
            gainNode1.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            oscillator1.start(audioContext.currentTime);
            oscillator1.stop(audioContext.currentTime + 0.3);

            // صوت "نقرة" قصيرة لإضافة بعض التأثير
            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = 'sine';
            oscillator2.frequency.setValueAtTime(200, audioContext.currentTime);
            gainNode2.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode2.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
            oscillator2.start(audioContext.currentTime);
            oscillator2.stop(audioContext.currentTime + 0.1);
        }

        // دالة جديدة لتشغيل صوت طبلة لبداية اللعبة
        function playStartDrumSound() {
            if (!soundEnabled) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'triangle'; // موجة مثلثية لطابع الطبلة
            
            // تغيير التردد لإنشاء صوت "طبل"
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(50, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.8, audioContext.currentTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.4);
        }

        // تنظيف الكائنات من المشهد
        function clearSceneObjects(objectsArray) {
            for (let i = objectsArray.length - 1; i >= 0; i--) {
                scene.remove(objectsArray[i]);
            }
            objectsArray.length = 0;
        }

        // تهيئة المشهد
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2a6c);
            scene.fog = new THREE.Fog(0x1a2a6c, 50, 200);

            if (!gameContainer) return;

            camera = new THREE.PerspectiveCamera(75, gameContainer.offsetWidth / gameContainer.offsetHeight, 0.1, 1000);
            camera.position.set(0, 10, 15);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
            updateRendererSize();
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameContainer.appendChild(renderer.domElement);

            // إضافة الإضاءة
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x404040, 1);
            scene.add(hemiLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 30, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // إنشاء المسار المنحني والأرض
            createGroundAndPath();
            createMotorcycle();
            createObstacles();
            createCollectibles();
            createScenery();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            if (restartBtn) {
                restartBtn.addEventListener('click', restartGame);
            }

            if (startGameBtn) {
                startGameBtn.addEventListener('click', function() {
                    soundEnabled = true;
                    if (startScreen) {
                        startScreen.style.opacity = '0';
                        setTimeout(() => {
                            startScreen.style.display = 'none';
                            startGame();
                        }, 800);
                    }
                });
            }

            // إضافة مستمعي الأحداث للموسيقى
            musicToggleBtn.addEventListener('click', toggleMusic);

            initTouchControls();
            initButtonControls();

            highScore = localStorage.getItem('motorcycleHighScore') || 0;
            if (highScoreDisplay) highScoreDisplay.textContent = `أفضل نتيجة: ${highScore}`;

            renderer.render(scene, camera);
        }

        // تحديث حجم العارض عند تغيير حجم النافذة
        function updateRendererSize() {
            const gameContainer = document.getElementById('gameContainer');
            if (!gameContainer) return;
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (width > 0 && height > 0) {
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        }

        // إنشاء الأرض والطريق
        function createGroundAndPath() {
            const roadPoints = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(20, 0, -20),
                new THREE.Vector3(40, 0, -10),
                new THREE.Vector3(60, 0, -40),
                new THREE.Vector3(80, 0, -20),
                new THREE.Vector3(100, 0, -50),
                new THREE.Vector3(120, 0, -30),
                new THREE.Vector3(140, 0, -70),
                new THREE.Vector3(160, 0, -50),
                new THREE.Vector3(180, 0, -90),
                new THREE.Vector3(200, 0, -70),
                new THREE.Vector3(220, 0, -50),
                new THREE.Vector3(240, 0, -80),
                new THREE.Vector3(260, 0, -60),
                new THREE.Vector3(280, 0, -100),
                new THREE.Vector3(300, 0, -80),
                new THREE.Vector3(320, 0, -120),
                new THREE.Vector3(340, 0, -100),
                new THREE.Vector3(360, 0, -140),
                new THREE.Vector3(380, 0, -120),
                new THREE.Vector3(400, 0, -160),
                new THREE.Vector3(420, 0, -140),
                new THREE.Vector3(440, 0, -180),
                new THREE.Vector3(460, 0, -160),
                new THREE.Vector3(480, 0, -200),
                new THREE.Vector3(500, 0, -180),
            ];
            curve = new THREE.CatmullRomCurve3(roadPoints);
            const segments = 200;

            clearSceneObjects(roadMarkings);

            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x558b2f, roughness: 1, metalness: 0 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.2;
            ground.receiveShadow = true;
            scene.add(ground);

            const roadWidth = laneWidth;
            const positions = [];
            const indices = [];
            const uvs = [];

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const side = new THREE.Vector3().crossVectors(up, tangent).normalize();

                const left = point.clone().add(side.clone().multiplyScalar(-roadWidth / 2));
                const right = point.clone().add(side.clone().multiplyScalar(roadWidth / 2));

                positions.push(left.x, left.y, left.z);
                positions.push(right.x, right.y, right.z);
                uvs.push(0, t * 10);
                uvs.push(1, t * 10);

                if (i < segments) {
                    const base = i * 2;
                    indices.push(base, base + 1, base + 2);
                    indices.push(base + 1, base + 3, base + 2);
                }
            }

            const roadGeometry = new THREE.BufferGeometry();
            roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            roadGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            roadGeometry.setIndex(new THREE.Uint16BufferAttribute(indices, 1));
            roadGeometry.computeVertexNormals();

            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9, metalness: 0, side: THREE.DoubleSide });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.receiveShadow = true;
            scene.add(road);
            roadMarkings.push(road);

            const centerlineMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
            for (let i = 0; i < segments; i += 2) {
                const t = i / segments;
                const startPoint = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

                const dashGeometry = new THREE.PlaneGeometry(0.5, 2);
                const dash = new THREE.Mesh(dashGeometry, centerlineMaterial);
                const pointOnCurve = curve.getPointAt(t + 0.01);
                const directionVector = pointOnCurve.clone().sub(startPoint).normalize();

                dash.position.copy(startPoint);
                dash.position.y = 0.01;
                dash.lookAt(startPoint.clone().add(directionVector));
                scene.add(dash);
                roadMarkings.push(dash);
            }
        }

        // إنشاء كائنات المناظر الطبيعية
        function createScenery() {
            clearSceneObjects(sceneryObjects);
            const numObjects = 50;
            const treeColors = [0x228B22, 0x006400, 0x556B2F]; // تم إزالة الصخور الزخرفية بناءً على طلب المستخدم

            for (let i = 0; i < numObjects; i++) {
                let sceneryObj;
                // إنشاء شجرة فقط
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                const leavesGeometry = new THREE.ConeGeometry(2, 3, 16);
                const leavesMaterial = new THREE.MeshStandardMaterial({ color: treeColors[i % treeColors.length], roughness: 0.6 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 2.5;

                sceneryObj = new THREE.Group();
                sceneryObj.add(trunk);
                sceneryObj.add(leaves);
                sceneryObj.position.y = 1;
                sceneryObj.castShadow = true;
                
                const t = Math.random();
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

                const side = Math.random() > 0.5 ? 1 : -1;
                const offset = (Math.random() * 30 + 15) * side;

                sceneryObj.position.copy(point.clone().add(normal.clone().multiplyScalar(offset)));
                sceneryObj.lookAt(point.clone().add(tangent));
                sceneryObj.userData.t = t;
                
                scene.add(sceneryObj);
                sceneryObjects.push(sceneryObj);
            }
        }

        // تهيئة عناصر التحكم باللمس
        function initTouchControls() {
            if (touchLeft && touchRight) {
                // تبديل الاتجاهات لتعويض RTL
                touchLeft.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        targetLanePosition = Math.min(1, targetLanePosition + 1);
                        steeringAngle = Math.max(-maxSteeringAngle, steeringAngle - steeringSpeed);
                    }
                });
                touchRight.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        targetLanePosition = Math.max(-1, targetLanePosition - 1);
                        steeringAngle = Math.min(maxSteeringAngle, steeringAngle + steeringSpeed);
                    }
                });
                // تحسين touchmove للسحب المستمر، مع تبديل
                touchLeft.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        steeringAngle = Math.max(-maxSteeringAngle, steeringAngle - steeringSpeed * 0.5);
                    }
                });
                touchRight.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        steeringAngle = Math.min(maxSteeringAngle, steeringAngle + steeringSpeed * 0.5);
                    }
                });
            }

            // اكتشاف السحب للأعلى للقفز
            if (gameContainer) {
                gameContainer.addEventListener('touchstart', (e) => {
                    if (gameActive) {
                        touchStartY = e.touches[0].clientY;
                    }
                });
                gameContainer.addEventListener('touchend', (e) => {
                    if (gameActive && touchStartY !== null) {
                        const touchEndY = e.changedTouches[0].clientY;
                        const deltaY = touchEndY - touchStartY;
                        if (deltaY < -50) { // سحب للأعلى
                            performJump();
                        }
                        touchStartY = null;
                    }
                });
            }
        }

        // تهيئة عناصر التحكم بالأزرار
        function initButtonControls() {
            if (jumpBtn) {
                jumpBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (gameActive && !isJumping) {
                        performJump();
                    }
                });
            }

            if (boostBtn) {
                boostBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        activateBoost();
                    }
                });
            }
        }

        // إنشاء الدراجة النارية
        function createMotorcycle() {
            const scale = 0.5;
            motorcycle = new THREE.Group();

            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.9, roughness: 0.2 });
            const secondaryBodyMaterial = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.9, roughness: 0.1 });
            const engineMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.1 });
            const tireMaterial = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 10 });
            const seatMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });

            // جسم الدراجة
            const bodyMain = new THREE.Mesh(new THREE.BoxGeometry(1.5 * scale, 0.6 * scale, 2.5 * scale), bodyMaterial);
            bodyMain.position.set(0, 0.4 * scale, 0);
            motorcycle.add(bodyMain);

            // خزان الوقود
            const tankGeometry = new THREE.BoxGeometry(1.2 * scale, 0.5 * scale, 1.0 * scale);
            const tank = new THREE.Mesh(tankGeometry, bodyMaterial);
            tank.position.set(0, 0.8 * scale, 0.8 * scale);
            motorcycle.add(tank);

            // المقعد
            const seatGeometry = new THREE.BoxGeometry(1.0 * scale, 0.2 * scale, 1.2 * scale);
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.set(0, 0.8 * scale, -0.2 * scale);
            motorcycle.add(seat);

            // المحرك
            const engineGeometry = new THREE.BoxGeometry(1.0 * scale, 0.8 * scale, 1.2 * scale);
            const engineMesh = new THREE.Mesh(engineGeometry, engineMaterial);
            engineMesh.position.set(0, -0.1 * scale, 0.1 * scale);
            motorcycle.add(engineMesh);

            // العجلات الأمامية والخلفية
            const tireGeometry = new THREE.TorusGeometry(0.8 * scale, 0.3 * scale, 16, 32);
            const frontWheel = new THREE.Mesh(tireGeometry, tireMaterial);
            frontWheel.rotation.y = Math.PI / 2;
            frontWheel.position.set(0, -0.6 * scale, 2.0 * scale);
            motorcycle.add(frontWheel);
            
            const backWheel = new THREE.Mesh(tireGeometry, tireMaterial);
            backWheel.rotation.y = Math.PI / 2;
            backWheel.position.set(0, -0.6 * scale, -2.0 * scale);
            motorcycle.add(backWheel);

            // الشوكات والمقود
            const forkGeometry = new THREE.CylinderGeometry(0.1 * scale, 0.1 * scale, 2.5 * scale, 8);
            const forkMaterial = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 1.0, roughness: 0.1 });
            const leftFork = new THREE.Mesh(forkGeometry, forkMaterial);
            leftFork.position.set(-0.5 * scale, 0.5 * scale, 1.9 * scale);
            leftFork.rotation.x = Math.PI / 6;
            motorcycle.add(leftFork);

            const rightFork = new THREE.Mesh(forkGeometry, forkMaterial);
            rightFork.position.set(0.5 * scale, 0.5 * scale, 1.9 * scale);
            rightFork.rotation.x = Math.PI / 6;
            motorcycle.add(rightFork);

            const handlebarGeometry = new THREE.CylinderGeometry(0.08 * scale, 0.08 * scale, 1.5 * scale, 8);
            handlebarGeometry.rotateZ(Math.PI / 2);
            const handlebar = new THREE.Mesh(handlebarGeometry, forkMaterial);
            handlebar.position.set(0, 1.2 * scale, 1.5 * scale);
            handlebar.rotation.x = Math.PI / 8;
            handlebar.name = 'handlebar';
            motorcycle.add(handlebar);

            // الأضواء الأمامية والخلفية
            const headlightGeometry = new THREE.SphereGeometry(0.4 * scale, 32, 32);
            const headlightMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5, metalness: 0.8, roughness: 0.2 });
            const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            headlight.position.set(0, 0.8 * scale, 2.2 * scale);
            motorcycle.add(headlight);

            const taillightGeometry = new THREE.BoxGeometry(0.4 * scale, 0.2 * scale, 0.1 * scale);
            const taillightMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3, metalness: 0.8, roughness: 0.2 });
            const taillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
            taillight.position.set(0, 0.7 * scale, -2.5 * scale);
            motorcycle.add(taillight);

            // السائق
            const riderGroup = new THREE.Group();
            riderGroup.name = 'rider';
            const suitMaterial = new THREE.MeshStandardMaterial({ color: 0x00bfff, metalness: 0.2, roughness: 0.8 });
            const helmetMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.2 });
            const limbMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500, metalness: 0.2, roughness: 0.8 });

            const headGeometry = new THREE.BoxGeometry(0.8 * scale, 0.8 * scale, 0.8 * scale);
            const head = new THREE.Mesh(headGeometry, helmetMaterial);
            head.position.set(0, 1.5 * scale, 0.2 * scale);
            riderGroup.add(head);

            const bodyGeometryRider = new THREE.BoxGeometry(1.0 * scale, 1.5 * scale, 0.8 * scale);
            const bodyRider = new THREE.Mesh(bodyGeometryRider, suitMaterial);
            bodyRider.position.set(0, 0.8 * scale, 0);
            riderGroup.add(bodyRider);

            const armGeometry = new THREE.CylinderGeometry(0.15 * scale, 0.15 * scale, 1.0 * scale, 8);
            const leftArm = new THREE.Mesh(armGeometry, limbMaterial);
            leftArm.position.set(-0.6 * scale, 0.9 * scale, 0.7 * scale);
            leftArm.rotation.z = Math.PI / 4;
            riderGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, limbMaterial);
            rightArm.position.set(0.6 * scale, 0.9 * scale, 0.7 * scale);
            rightArm.rotation.z = -Math.PI / 4;
            riderGroup.add(rightArm);

            const legGeometry = new THREE.CylinderGeometry(0.18 * scale, 0.18 * scale, 1.2 * scale, 8);
            const leftLeg = new THREE.Mesh(legGeometry, limbMaterial);
            leftLeg.position.set(-0.3 * scale, 0.1 * scale, 0);
            leftLeg.rotation.x = Math.PI / 2;
            riderGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, limbMaterial);
            rightLeg.position.set(0.3 * scale, 0.1 * scale, 0);
            rightLeg.rotation.x = Math.PI / 2;
            riderGroup.add(rightLeg);
            
            motorcycle.add(riderGroup);

            // الدرع
            const shieldGeometry = new THREE.SphereGeometry(1.5 * scale, 32, 32);
            const shieldMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700, transparent: true, opacity: 0.3, wireframe: true });
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.name = 'shield';
            shield.position.y = 0.5 * scale;
            shield.visible = false;
            motorcycle.add(shield);

            motorcycle.castShadow = true;

            const pathFollower = new THREE.Group();
            pathFollower.name = "pathFollower";
            pathFollower.add(motorcycle);
            scene.add(pathFollower);
            motorcycle.position.y = 0;
        }

        // إنشاء العوائق
        function createObstacles() {
            clearSceneObjects(obstacles);
            const obstacleTypes = ['cone', 'barrier', 'spike', 'pipe'];
            for (let i = 0; i < 30; i++) {
                const obstacleType = Math.floor(Math.random() * obstacleTypes.length);
                let obstacle;
                let geometry, material;

                if (obstacleType === 0) { // حاجز مخروطي (cone)
                    geometry = new THREE.ConeGeometry(0.6, 1.5, 16);
                    material = new THREE.MeshStandardMaterial({ color: 0xffa500, // لون برتقالي
                        roughness: 0.8 });
                    obstacle = new THREE.Mesh(geometry, material);
                    // إضافة شريط أبيض
                    const stripeGeometry = new THREE.CylinderGeometry(0.65, 0.65, 0.2, 16);
                    const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.y = -0.5;
                    obstacle.add(stripe);
                    obstacle.position.y = 0.75;
                    obstacle.userData = { isJumpable: false, type: 'cone' };

                } else if (obstacleType === 1) { // حاجز على شكل صندوق (barrier)
                    geometry = new THREE.BoxGeometry(2, 0.8, 0.5);
                    const texture = new THREE.CanvasTexture(createStripePattern());
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.repeat.set(2, 1);
                    material = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.position.y = 0.4;
                    obstacle.userData = { isJumpable: true, type: 'barrier' };

                } else if (obstacleType === 2) { // حاجز على شكل سن مدبب (spike)
                    geometry = new THREE.ConeGeometry(0.4, 1, 8);
                    material = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.7, roughness: 0.5 });
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.position.y = 0.5;
                    obstacle.userData = { isJumpable: false, type: 'spike' };

                } else { // حاجز على شكل أنبوب (pipe)
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16);
                    material = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.9, roughness: 0.1 });
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.rotation.x = Math.PI / 2;
                    obstacle.position.y = 0.5;
                    obstacle.userData = { isJumpable: true, type: 'pipe' };
                }

                obstacle.castShadow = true;
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
        }

        // دالة لإنشاء نقش مخطط
        function createStripePattern() {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const context = canvas.getContext('2d');
            context.fillStyle = '#ffcc00'; // أصفر
            context.fillRect(0, 0, 16, 16);
            context.fillStyle = '#000000'; // أسود
            context.fillRect(0, 0, 8, 16);
            return canvas;
        }

        // إنشاء الكائنات القابلة للجمع
        function createCollectibles() {
            clearSceneObjects(collectibles);
            const collectibleTypes = ['shield', 'boost', 'time', 'ring'];

            for (let i = 0; i < 30; i++) {
                const collectibleType = Math.floor(Math.random() * collectibleTypes.length);
                let collectible;

                if (collectibleType === 0) { // درع
                    const geometry = new THREE.TorusGeometry(0.4, 0.1, 16, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.5 });
                    collectible = new THREE.Mesh(geometry, material);
                    collectible.userData = { type: 'shield' };
                } else if (collectibleType === 1) { // تسارع
                    const geometry = new THREE.ConeGeometry(0.4, 0.8, 4);
                    const material = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3 });
                    collectible = new THREE.Mesh(geometry, material);
                    collectible.rotation.x = Math.PI;
                    collectible.userData = { type: 'boost' };
                } else if (collectibleType === 2) { // وقت
                    const geometry = new THREE.RingGeometry(0.3, 0.5, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5, side: THREE.DoubleSide });
                    collectible = new THREE.Mesh(geometry, material);
                    collectible.rotation.x = Math.PI / 2;
                    collectible.userData = { type: 'time' };
                } else { // الحلقات الذهبية
                    const geometry = new THREE.TorusGeometry(0.5, 0.1, 16, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.8 });
                    collectible = new THREE.Mesh(geometry, material);
                    collectible.userData = { type: 'ring' };
                }

                collectible.position.y = 7;
                scene.add(collectible);
                collectibles.push(collectible);
            }
        }

        function onWindowResize() {
            updateRendererSize();
        }

        // التعامل مع ضغطات المفاتيح
        function handleKeyDown(event) {
            if (!gameActive) return;
            if (event.key === 'ArrowLeft') {
                targetLanePosition = Math.max(-1, targetLanePosition - 1);
                steeringAngle = Math.min(maxSteeringAngle, steeringAngle + steeringSpeed);
            } else if (event.key === 'ArrowRight') {
                targetLanePosition = Math.min(1, targetLanePosition + 1);
                steeringAngle = Math.max(-maxSteeringAngle, steeringAngle - steeringSpeed);
            } else if (event.key === ' ' || event.key === 'ArrowUp') {
                performJump();
            } else if (event.key === 'Enter') {
                activateBoost();
            }
        }

        function handleKeyUp(event) {
            // لا حاجة حاليًا
        }
        
        function performJump() {
            if (!isJumping) {
                isJumping = true;
                jumpProgress = 0;
                // صوت القفز
                playSound(440, 'sine', 0.1, 0.5); 
            }
        }

        // بدء اللعبة
        function startGame() {
            if (timerInterval) clearInterval(timerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            gameActive = true;
            score = 0;
            timer = 60;
            currentSpeed = baseSpeed; // السرعة الأساسية
            t = 0;
            steeringAngle = 0;
            const pathFollower = scene.getObjectByName("pathFollower");
            if (pathFollower) {
                pathFollower.position.set(0, 0, 0);
            }
            targetLanePosition = 0;
            shieldCount = 0;
            boostCount = 0;
            isJumping = false;

            if (gameOverScreen) gameOverScreen.style.display = 'none';
            if (gameStatsContainer) gameStatsContainer.style.display = 'flex';
            if (controlsContainer) controlsContainer.style.display = 'flex';
            if (shieldDisplay) shieldDisplay.textContent = `الدرع: ${shieldCount}`;
            if (speedDisplay) speedDisplay.textContent = `السرعة: ${Math.round(currentSpeed * 10000)}`;
            if (scoreDisplay) scoreDisplay.textContent = `النقاط: ${score}`;
            if (timerDisplay) timerDisplay.textContent = `الوقت: ${timer}`;
            if (gameOverReason) gameOverReason.textContent = "";

            const shieldMesh = motorcycle.getObjectByName('shield');
            if (shieldMesh) shieldMesh.visible = false;
            shieldActive = false;
            boostActive = false;

            document.body.style.background = 'linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c)';

            placeObjectsOnCurve();
            animate();
            startTimer();
            toggleMusic(); // بدء تشغيل الموسيقى عند بدء اللعبة
        }

        // بدء المؤقت
        function startTimer() {
            timerInterval = setInterval(() => {
                if (gameActive) {
                    timer--;
                    if (timerDisplay) timerDisplay.textContent = `الوقت: ${timer}`;
                    if (timer <= 0) {
                        clearInterval(timerInterval);
                        endGame(true, "انتهى الوقت!");
                    }
                } else {
                    clearInterval(timerInterval);
                }
            }, 1000);
        }

        // إنهاء اللعبة
        function endGame(isWin, reason = "اصطدام!") {
            gameActive = false;
            if (timerInterval) clearInterval(timerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            toggleMusic(); // إيقاف الموسيقى عند انتهاء اللعبة

            if (finalScoreDisplay) finalScoreDisplay.textContent = `النقاط: ${score}`;
            if (gameStatsContainer) gameStatsContainer.style.display = 'none';
            if (controlsContainer) controlsContainer.style.display = 'none';
            if (gameOverReason) gameOverReason.textContent = reason;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('motorcycleHighScore', highScore);
                if (highScoreDisplay) {
                    highScoreDisplay.textContent = `أفضل نتيجة جديدة: ${highScore}`;
                    highScoreDisplay.style.color = '#ffc107';
                    highScoreDisplay.style.fontWeight = 'bold';
                }
            } else {
                if (highScoreDisplay) {
                    highScoreDisplay.textContent = `أفضل نتيجة: ${highScore}`;
                    highScoreDisplay.style.color = '#ccc';
                }
            }

            if (gameOverScreen) gameOverScreen.style.display = 'block';

            // صوت انتهاء اللعبة
            playStartDrumSound();
        }

        // إعادة تشغيل اللعبة
        function restartGame() {
            if (gameOverScreen) gameOverScreen.style.display = 'none';
            gameActive = false;
            if (timerInterval) clearInterval(timerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            startGame();
        }

        // تفعيل الدرع الواقي
        function activateShield() {
            if (shieldCount > 0 && gameActive && !shieldActive) {
                shieldCount--;
                shieldActive = true;
                const shieldMesh = motorcycle.getObjectByName('shield');
                if (shieldMesh) shieldMesh.visible = true;
                if (shieldDisplay) shieldDisplay.textContent = `الدرع: ${shieldCount}`;
                setTimeout(() => {
                    if (gameActive) {
                        shieldActive = false;
                        if (shieldMesh) shieldMesh.visible = false;
                    }
                }, 5000);
            }
        }

        // تفعيل التسارع
        function activateBoost() {
            if (boostCount > 0 && gameActive && !boostActive) {
                boostCount--;
                boostActive = true;
                // صوت التسارع
                playSound(600, 'triangle', 0.1, 0.6); 
                document.body.style.background = 'linear-gradient(135deg, #ffeb3b, #ff8c00)';
                setTimeout(() => {
                    if (gameActive) {
                        boostActive = false;
                        document.body.style.background = 'linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c)';
                    }
                }, 3000);
            }
        }

        // وضع الكائنات على المسار
        function placeObjectsOnCurve() {
            obstacles.forEach(obstacle => {
                const t = Math.random() * 0.9 + 0.1;
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();
                let laneIndex = Math.floor(Math.random() * 3) - 1;
                if (Math.random() < 0.5) laneIndex = laneIndex === 0 ? (Math.random() > 0.5 ? 1 : -1) : laneIndex; // تقليل احتمال الوسط
                const offset = laneIndex * laneWidth * 0.5;
                obstacle.position.copy(point.clone().add(normal.multiplyScalar(offset)));
                obstacle.rotation.y = Math.atan2(tangent.z, tangent.x) + Math.PI / 2;
                obstacle.userData.t = t;
            });

            collectibles.forEach(collectible => {
                const t = Math.random() * 0.9 + 0.1;
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();
                const offset = (Math.floor(Math.random() * 3) - 1) * laneWidth * 0.5;
                collectible.position.copy(point.clone().add(normal.multiplyScalar(offset)));
                collectible.rotation.y = Math.atan2(tangent.z, tangent.x) + Math.PI / 2;
                collectible.userData.t = t;
            });
            
            sceneryObjects.forEach(sceneryObj => {
                const t = Math.random();
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

                const side = Math.random() > 0.5 ? 1 : -1;
                const offset = (Math.random() * 30 + 15) * side;

                sceneryObj.position.copy(point.clone().add(normal.clone().multiplyScalar(offset)));
                sceneryObj.position.y = sceneryObj.geometry instanceof THREE.DodecahedronGeometry ? 0.5 : 1;
                sceneryObj.lookAt(point.clone().add(tangent));
                sceneryObj.userData.t = t;
            });
        }

        // عرض تأثير الجمع
        function showCollectEffect(x, y) {
            collectEffect.style.display = 'block';
            collectEffect.style.left = `${x - 20}px`;
            collectEffect.style.top = `${y - 20}px`;
            setTimeout(() => {
                collectEffect.style.display = 'none';
            }, 600);
        }

        // عرض تأثير الاصطدام
        function showCollisionEffect(x, y) {
            collisionEffect.style.display = 'block';
            collisionEffect.style.left = `${x - 50}px`;
            collisionEffect.style.top = `${y - 50}px`;
            setTimeout(() => {
                collisionEffect.style.display = 'none';
            }, 500);
        }
        
        // نقل الدراجة إلى مكان آمن بعد الإجابة الصحيحة
        function moveToSafePosition() {
            t += 0.05; // نقل الدراجة للأمام قليلاً
            const position = curve.getPointAt(t);
            const tangent = curve.getTangentAt(t).normalize();
            const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();
            
            const motorcyclePosition = position.clone().add(normal.clone().multiplyScalar(0));
            motorcyclePosition.y = 0.8;
            
            const pathFollower = scene.getObjectByName("pathFollower");
            if (pathFollower) {
                pathFollower.position.copy(motorcyclePosition);
                pathFollower.lookAt(motorcyclePosition.clone().add(tangent));
            }
        }

        // حلقة الرسوم المتحركة
        function animate() {
            if (!gameActive) {
                return;
            }

            animationFrameId = requestAnimationFrame(animate);

            // إدارة السرعة
            if (boostActive) {
                currentSpeed += acceleration;
                if (currentSpeed > maxBoostSpeed) {
                    currentSpeed = maxBoostSpeed;
                }
            } else {
                if (currentSpeed > baseSpeed) {
                    currentSpeed -= acceleration;
                    if (currentSpeed < baseSpeed) {
                        currentSpeed = baseSpeed;
                    }
                }
            }

            if (speedDisplay) speedDisplay.textContent = `السرعة: ${Math.round(currentSpeed * 10000)}`;

            t += currentSpeed;
            if (t > 1) {
                t = 0;
                placeObjectsOnCurve();
            }

            const position = curve.getPointAt(t);
            const tangent = curve.getTangentAt(t).normalize();
            const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

            const targetLaneOffset = targetLanePosition * laneWidth * 0.5;
            const currentLaneOffset = motorcycle.parent.position.clone().sub(position).dot(normal);
            const newLaneOffset = currentLaneOffset + (targetLaneOffset - currentLaneOffset) * 0.3;

            const motorcyclePosition = position.clone().add(normal.clone().multiplyScalar(newLaneOffset));

            if (Math.abs(newLaneOffset) > (laneWidth * 1.5)) { // زيادة الحد للسماح بالمرور الجانبي
                console.log("Out of lane at offset:", newLaneOffset);
                endGame(false, "أحسنت وصلت نهاية المسار!");
                return;
            }

            if (isJumping) {
                jumpProgress += 16 / jumpDuration;
                const jumpY = Math.sin(jumpProgress * Math.PI) * jumpHeight;
                motorcyclePosition.y = jumpY + 0.8;
                if (jumpProgress >= 1) {
                    isJumping = false;
                    jumpProgress = 0;
                }
            } else {
                motorcyclePosition.y = 0.8;
            }

            motorcycle.parent.position.copy(motorcyclePosition);
            motorcycle.parent.lookAt(motorcycle.parent.position.clone().add(tangent));

            // تطبيق دوران المقود
            const handlebar = motorcycle.getObjectByName('handlebar');
            if (handlebar) {
                handlebar.rotation.z = -steeringAngle * 2;
            }

            // العودة التدريجية للمقود إلى المنتصف
            if (steeringAngle > 0) {
                steeringAngle = Math.max(0, steeringAngle - steeringReturnSpeed);
            } else if (steeringAngle < 0) {
                steeringAngle = Math.min(0, steeringAngle + steeringReturnSpeed);
            }

            const cameraOffset = new THREE.Vector3(0, 3, -5).applyQuaternion(motorcycle.parent.quaternion);
            camera.position.copy(motorcycle.parent.position).add(cameraOffset);
            camera.lookAt(motorcycle.parent.position);

            const motorcycleBbox = new THREE.Box3().setFromObject(motorcycle);

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.rotation.y += currentSpeed * 50;
                const obstacleBbox = new THREE.Box3().setFromObject(obstacle);

                const distance = Math.abs(obstacle.userData.t - t);
                const sideDistance = motorcycle.parent.position.clone().sub(obstacle.position).dot(normal); // حساب المسافة الجانبية

                if (motorcycleBbox.intersectsBox(obstacleBbox) && distance < 0.02) {
                    if (Math.abs(sideDistance) > 0.5) { // تجاهل إذا كان المرور جانبي (مسافة > 0.5)
                        console.log("Ignored collision due to side distance:", sideDistance);
                        continue;
                    }
                    console.log("Collision with obstacle:", obstacle.userData.type, "at distance:", distance, "side:", sideDistance);
                    
                    const isJumpable = obstacle.userData.isJumpable;
                    if (isJumpable && isJumping) {
                        // تجاوز الحاجز بالقفز
                    } else if (shieldActive) {
                        obstacle.position.x = -1000;
                        score += 50;
                        scoreDisplay.textContent = `النقاط: ${score}`;
                    } else {
                        // عرض تأثير الاصطدام
                        const screenPosition = obstacle.position.clone().project(camera);
                        const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
                        showCollisionEffect(x, y);
                        // صوت الاصطدام
                        playCollisionSound();
                        
                        // إيقاف اللعبة وعرض السؤال
                        gameActive = false;
                        cancelAnimationFrame(animationFrameId);
                        generateQuestion();
                        questionScreen.style.display = 'flex';
                        return;
                    }
                }

                if (obstacle.userData.t < t - 0.2) {
                    const newT = t + Math.random() * 0.2 + 0.2;
                    const newPoint = curve.getPointAt(newT % 1);
                    const newTangent = curve.getTangentAt(newT % 1).normalize();
                    const newNormal = new THREE.Vector3(0, 1, 0).cross(newTangent).normalize();
                    let laneIndex = Math.floor(Math.random() * 3) - 1;
                    if (Math.random() < 0.5) laneIndex = laneIndex === 0 ? (Math.random() > 0.5 ? 1 : -1) : laneIndex; // تقليل احتمال الوسط
                    const newOffset = laneIndex * laneWidth * 0.5;
                    obstacle.position.copy(newPoint.clone().add(newNormal.multiplyScalar(newOffset)));
                    obstacle.rotation.y = Math.atan2(newTangent.z, newTangent.x) + Math.PI / 2;
                    obstacle.userData.t = newT;
                    score += 10;
                    scoreDisplay.textContent = `النقاط: ${score}`;
                }
            }

            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                collectible.rotation.y += 0.05;
                const collectibleBbox = new THREE.Box3().setFromObject(collectible);
                
                if (motorcycleBbox.intersectsBox(collectibleBbox)) {
                    if (collectible.userData.type === 'shield') {
                        shieldCount++;
                        if (shieldDisplay) shieldDisplay.textContent = `الدرع: ${shieldCount}`;
                    } else if (collectible.userData.type === 'boost') {
                        boostCount++;
                    } else if (collectible.userData.type === 'time') {
                        timer += 5;
                        if (timerDisplay) timerDisplay.textContent = `الوقت: ${timer}`;
                    } else if (collectible.userData.type === 'ring') {
                        score += 100;
                        scoreDisplay.textContent = `النقاط: ${score}`;
                    }
                    
                    // صوت جمع القطع
                    playSound(880, 'sine', 0.1, 0.4); 

                    // عرض تأثير الجمع
                    const screenPosition = collectible.position.clone().project(camera);
                    const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
                    showCollectEffect(x, y);

                    collectible.position.x = -1000;
                    score += 25;
                    scoreDisplay.textContent = `النقاط: ${score}`;
                }

                if (collectible.userData.t < t - 0.1) {
                    const newT = t + Math.random() * 0.2 + 0.1;
                    const newPoint = curve.getPointAt(newT % 1);
                    const newTangent = curve.getTangentAt(newT % 1).normalize();
                    const newNormal = new THREE.Vector3(0, 1, 0).cross(newTangent).normalize();
                    const newOffset = (Math.floor(Math.random() * 3) - 1) * laneWidth * 0.5;

                    collectible.position.copy(newPoint.clone().add(newNormal.multiplyScalar(newOffset)));
                    collectible.rotation.y = Math.atan2(newTangent.z, newTangent.x) + Math.PI / 2;
                    collectible.userData.t = newT;
                }
            }

            for (let i = sceneryObjects.length - 1; i >= 0; i--) {
                const sceneryObj = sceneryObjects[i];
                if (sceneryObj.userData.t < t - 0.1) {
                    const newT = t + Math.random() * 0.5 + 0.1;
                    const point = curve.getPointAt(newT % 1);
                    const tangent = curve.getTangentAt(newT % 1).normalize();
                    const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

                    const side = Math.random() > 0.5 ? 1 : -1;
                    const offset = (Math.random() * 30 + 15) * side;

                    sceneryObj.position.copy(point.clone().add(normal.clone().multiplyScalar(offset)));
                    sceneryObj.position.y = sceneryObj.geometry instanceof THREE.DodecahedronGeometry ? 0.5 : 1;
                    sceneryObj.lookAt(point.clone().add(tangent));
                    sceneryObj.userData.t = newT;
                }
            }

            renderer.render(scene, camera);
        }

        window.onload = function() {
            init();
        };
    </script>
</body>
</html>
