<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¯Ø±Ø§Ø¬Ø© Ø§Ù„Ù†Ø§Ø±ÙŠØ© Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©</title>
    <!-- ØªØ¶Ù…ÙŠÙ† Ù…ÙƒØªØ¨Ø© three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- ØªØ¶Ù…ÙŠÙ† Tailwind CSS Ù„ØªØµÙ…ÙŠÙ… Ø¬Ù…ÙŠÙ„ ÙˆØ³Ø±ÙŠØ¹ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- ØªØ¶Ù…ÙŠÙ† Ù…ÙƒØªØ¨Ø© MathJax Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„Ù…ØªØµÙØ­ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation; /* ÙŠÙ…Ù†Ø¹ Ø³Ù„ÙˆÙƒÙŠØ§Øª Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù…Ø«Ù„ Ø§Ù„ØªÙƒØ¨ÙŠØ± ÙˆØ§Ù„ØªØµØºÙŠØ± */
        }
        
        /* Ø®Ø· Tajawal Ù„Ø¯Ø¹Ù… Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© */
        @import url('https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700&display=swap');
        body {
            font-family: 'Tajawal', sans-serif;
            direction: rtl;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            perspective: 1000px;
        }

        /* Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø¡ */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 10, 30, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            padding: 20px;
            transition: opacity 0.8s ease-out;
            backdrop-filter: blur(5px);
        }

        #startScreen h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        #startScreen p {
            font-size: clamp(1rem, 2vw, 1.2rem);
            margin-bottom: 30px;
            max-width: 80%;
            color: #e0f7ff;
            line-height: 1.6;
        }

        .start-btn {
            padding: 15px 40px;
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            background: linear-gradient(to bottom, #ff8c00, #ff4500);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to bottom, #ff9d00, #ff5500);
        }

        .start-btn:active {
            transform: scale(0.95);
        }

        .floatingMotorcycle {
            font-size: 5rem;
            margin-bottom: 30px;
            animation: float 3s infinite ease-in-out;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.7));
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-20px);
            }
        }

        .container {
            width: 100%;
            height: 100%;
            padding: 0;
            position: relative;
            transform-style: preserve-3d;
            animation: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.1);
            overflow: hidden;
            border: none;
            box-shadow: none;
            margin: 0;
            transform-style: preserve-3d;
            transition: all 0.5s;
            flex-grow: 1;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .game-stats {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: none;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            color: white;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 10;
            padding: 5px; /* ØªØµØºÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ© */
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            backdrop-filter: blur(5px);
            gap: 5px; /* ØªØµØºÙŠØ± Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù†Ø§ØµØ± */
        }

        .game-stats span {
            padding: 5px 10px; /* ØªØµØºÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ© Ù„Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª */
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 0 2px; /* ØªØµØºÙŠØ± Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª */
            min-width: 90px; /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø¯Ù†Ù‰ */
            display: inline-flex;
            justify-content: center;
            font-size: 0.9rem; /* ØªØµØºÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ø®Ø· */
        }

        .game-stats #speedDisplay {
            font-weight: bold;
            color: #ffeb3b;
        }

        .game-stats #scoreDisplay {
            color: #4caf50;
            font-weight: bold;
        }
        
        /* Ù†Ù…Ø· Ø§Ù„Ø²Ø± Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ */
        #musicToggleBtn {
            padding: 8px 12px !important; /* ØªØµØºÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ø²Ø± */
            background: linear-gradient(to bottom, #5cb85c, #4cae4c);
            font-size: 1.2rem; /* Ø­Ø¬Ù… Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© */
            min-width: 40px !important; /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø¯Ù†Ù‰ */
            min-height: 40px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid #ff8c00;
            text-align: center;
            z-index: 100;
            display: none;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.5);
            width: 90%;
            max-width: 500px;
            animation: gameOverAppear 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(10px);
        }

        @keyframes gameOverAppear {
            0% {
                transform: translate(-50%, -60%);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        #gameOver h2 {
            font-size: clamp(2rem, 5vw, 2.5rem);
            color: #ffc107;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255, 193, 7, 0.7);
        }

        #finalScore {
            font-size: clamp(1.8rem, 4vw, 2.2rem);
            color: #fff;
            margin: 20px 0;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
        }

        #highScore {
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            color: #ccc;
            margin-bottom: 20px;
        }

        #gameOver p {
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(255, 0, 0, 0.2);
            border-radius: 8px;
        }

        .controls-container {
            display: flex;
            flex-direction: column; /* Ø¬Ø¹Ù„ Ø§Ù„Ø¹Ù†Ø§ØµØ± ØªØªÙƒØ¯Ø³ Ø¹Ù…ÙˆØ¯ÙŠÙ‹Ø§ */
            justify-content: center;
            align-items: center;
            gap: 15px; /* Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù†Ø§ØµØ± */
            padding: 15px 0;
            width: 100%;
            position: fixed;
            bottom: 0;
            z-index: 1000;
            display: none;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .control-btn {
            padding: 15px 40px;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            min-width: 150px;
        }

        .control-btn:hover {
            transform: scale(1.05);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        #boostBtn {
            background: linear-gradient(to bottom, #ffd700, #ff8c00);
        }

        #jumpBtn {
            background: linear-gradient(to bottom, #1e90ff, #0077cc);
        }

        /* Ø£Ù†Ù…Ø§Ø· Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù…Ø®ØµØµ Ù„Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ */
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease-in-out;
        }
        .slider-thumb::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease-in-out;
        }

        #touchLeft, #touchRight {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            z-index: 5;
        }

        #touchLeft {
            left: 0;
        }

        #touchRight {
            right: 0;
        }

        .collectible-effect {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 20;
            display: none;
            animation: collectPulse 0.6s ease-out;
        }

        @keyframes collectPulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .collision-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.8) 0%, rgba(255, 0, 0, 0) 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 20;
            display: none;
            animation: collisionFlash 0.5s ease-out;
        }

        @keyframes collisionFlash {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .road {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 60%;
            background: linear-gradient(to top, #8B4513, #5D2906);
            z-index: -1;
            border-top: 4px solid #654321;
        }

        .road-lines {
            position: absolute;
            bottom: 50%;
            width: 100%;
            height: 10px;
            background: repeating-linear-gradient(to right, transparent, transparent 30px, #ffd700 30px, #ffd700 60px);
            z-index: -1;
        }

        /* ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù†Ù…Ø· Ù„ÙŠÙƒÙˆÙ† Ø¶Ù…Ù† Ø§Ù„Ù€ flexbox */
        .instructions {
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1rem;
            margin-top: 5px; /* Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø§ÙØ© Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰ */
        }
        
        /* Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© */
        #musicControls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            width: auto;
            max-width: none;
        }
        
        /* Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ */
        #questionScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            display: none;
        }
        
        .question-container {
            background: white;
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            text-align: center;
        }
        
        .question-container h1 {
            color: #1a2a6c;
            margin-bottom: 1rem;
        }
        
        .question-container .math-symbol {
            font-size: 2.5rem;
            font-weight: bold;
            margin: 0 10px;
        }
        
        .options-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        
        .option-btn {
            padding: 15px 30px;
            background: #1e90ff;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 100px;
        }
        
        .option-btn:hover {
            background: #0077cc;
            transform: scale(1.05);
        }
        
        .result-message {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 20px 0;
            display: none;
        }
        
        .correct {
            color: #4CAF50;
        }
        
        .incorrect {
            color: #f44336;
        }

        @media (max-width: 768px) {
            .game-stats {
                font-size: 0.8rem; /* ØªØµØºÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ */
                flex-wrap: wrap;
                justify-content: center;
                gap: 5px;
            }

            .game-stats span {
                padding: 4px 8px; /* ØªØµØºÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ */
                margin: 5px;
                min-width: 80px; /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ */
                font-size: 0.7rem; /* ØªØµØºÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ */
            }

            #gameOver {
                padding: 20px;
                width: 95%;
            }

            .control-btn {
                padding: 12px 25px;
                min-width: 120px;
                font-size: 0.9rem;
            }
            
            .question-container {
                padding: 1rem;
            }
            
            .option-btn {
                padding: 10px 20px;
                font-size: 1.2rem;
                min-width: 80px;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <div class="floatingMotorcycle">ğŸï¸</div>
        <h1>ğŸš€ Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¯Ø±Ø§Ø¬Ø© Ø§Ù„Ù†Ø§Ø±ÙŠØ© Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©</h1>
        <p>ØªØ­Ø¯Ù Ø¬Ø¯ÙŠØ¯! Ø¹Ù†Ø¯Ù…Ø§ ØªØµØ·Ø¯Ù… Ø¨Ø¹Ø§Ø¦Ù‚ØŒ Ø³ØªØ­Ù„ Ø³Ø¤Ø§Ù„Ù‹Ø§ ØªØ¹Ù„ÙŠÙ…ÙŠÙ‹Ø§. Ø¥Ø°Ø§ Ø£Ø¬Ø¨Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ØŒ Ø³ØªÙˆØ§ØµÙ„ Ø§Ù„Ù„Ø¹Ø¨. Ø¥Ø°Ø§ Ø£Ø®Ø·Ø£ØªØŒ ØªÙ†ØªÙ‡ÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø©!</p>
        <button id="startGameBtn" class="start-btn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
    </div>

    <div class="container">
        <div id="gameContainer">
            <div id="touchLeft"></div>
            <div id="touchRight"></div>
            <div class="road"></div>
            <div class="road-lines"></div>

            <div class="game-stats flex-row items-center gap-4">
                <span id="scoreDisplay">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</span>
                <span id="shieldDisplay">Ø§Ù„Ø¯Ø±Ø¹: 0</span>
                <span id="speedDisplay">Ø§Ù„Ø³Ø±Ø¹Ø©: 0</span>
                <span id="timerDisplay">Ø§Ù„ÙˆÙ‚Øª: 60</span>
                <button id="musicToggleBtn" class="control-btn rounded-full min-w-0">ğŸ¶</button>
            </div>

            <div id="gameOver">
                <h2>Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!</h2>
                <p id="gameOverReason">Ù„Ù‚Ø¯ Ø§ØµØ·Ø¯Ù…Øª Ø¨Ø¹Ø§Ø¦Ù‚</p>
                <div id="finalScore">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
                <div id="highScore">Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: 0</div>
                <button id="restart-btn" class="start-btn">Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
            </div>
            <div class="collectible-effect" id="collectEffect"></div>
            <div class="collision-effect" id="collisionEffect"></div>
        </div>

        <div class="controls-container">
            <div class="flex flex-row items-center justify-center gap-4 w-full">
                <button id="jumpBtn" class="control-btn">Ø§Ù„Ù‚ÙØ²</button>
                <button id="boostBtn" class="control-btn">Ø§Ù„ØªØ³Ø§Ø±Ø¹</button>
            </div>
            <div class="instructions">Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£ÙŠØ³Ø± Ù„Ù„ØªØ­Ø±Ùƒ Ù„Ù„ÙŠØ³Ø§Ø±ØŒ Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£ÙŠÙ…Ù† Ù„Ù„ØªØ­Ø±Ùƒ Ù„Ù„ÙŠÙ…ÙŠÙ†</div>
        </div>
    </div>
    
    <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ -->
    <div id="questionScreen">
        <div class="question-container">
            <h1 id="question-title">Ø³Ø¤Ø§Ù„: Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠØ©</h1>
            <div id="question-container" class="mb-8">
                <p class="text-xl sm:text-2xl text-gray-700">Ù‚Ø§Ø±Ù† Ø¨ÙŠÙ† Ø§Ù„Ø¹Ø¯Ø¯ÙŠÙ† Ø§Ù„Ù†Ø³Ø¨ÙŠÙŠÙ†:</p>
                <div class="flex justify-center items-center my-4">
                    <span id="number1" class="text-4xl font-semibold text-blue-600"></span>
                    <span class="math-symbol mx-4 text-gray-500"> â–¡ </span>
                    <span id="number2" class="text-4xl font-semibold text-blue-600"></span>
                </div>
            </div>

            <div id="options-container" class="options-container">
                <!-- Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø³ÙŠØªÙ… Ø¥Ø¶Ø§ÙØªÙ‡Ø§ Ù‡Ù†Ø§ Ø¨ÙˆØ§Ø³Ø·Ø© JavaScript -->
            </div>

            <div id="result-message" class="result-message"></div>
        </div>
    </div>

    <script>
        // Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ø¹Ø¨Ø©
        let scene, camera, renderer, motorcycle;
        let obstacles = [], collectibles = [], roadMarkings = [], sceneryObjects = [];
        let score = 0, timer = 60, gameActive = false, highScore = 0;
        let baseSpeed = 0.0003; // Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø«Ø§Ø¨ØªØ©
        let currentSpeed = baseSpeed; // Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ØªØ¨Ø¯Ø£ Ø¨Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        let maxBoostSpeed = baseSpeed * 2.5; // Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù‚ØµÙˆÙ‰ Ø¹Ù†Ø¯ Ø§Ù„ØªØ¹Ø²ÙŠØ²
        let acceleration = 0.00002; // Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ³Ø§Ø±Ø¹ Ø¹Ù†Ø¯ Ø§Ù„ØªØ¹Ø²ÙŠØ²
        let laneWidth = 4;
        let targetLanePosition = 0;
        let isJumping = false;
        let jumpProgress = 0;
        const jumpHeight = 2; // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ù„Ù‚ÙØ² Ø£Ø¹Ù„Ù‰
        const jumpDuration = 1000;
        let shieldActive = false, boostActive = false;
        let shieldCount = 0, boostCount = 0;
        let touchStartX = null;
        let touchStartY = null;
        let timerInterval = null;
        let animationFrameId = null;
        let steeringAngle = 0;
        const maxSteeringAngle = Math.PI / 6; // 30 Ø¯Ø±Ø¬Ø©
        let steeringSpeed = 0.06;
        let steeringReturnSpeed = 0.02;

        // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø± ÙˆØ§Ù„Ù…ÙˆØ¶Ø¹ Ù„Ù„Ø·Ø±ÙŠÙ‚ Ø§Ù„Ù…Ù†Ø­Ù†ÙŠ
        let curve;
        let t = 0;
        const curveLength = 1000;

        // Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const restartBtn = document.getElementById('restart-btn');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');
        const highScoreDisplay = document.getElementById('highScore');
        const gameContainer = document.getElementById('gameContainer');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const shieldDisplay = document.getElementById('shieldDisplay');
        const speedDisplay = document.getElementById('speedDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const gameStatsContainer = document.querySelector('.game-stats');
        const startScreen = document.getElementById('startScreen');
        const startGameBtn = document.getElementById('startGameBtn');
        const gameOverReason = document.getElementById('gameOverReason');
        const jumpBtn = document.getElementById('jumpBtn');
        const boostBtn = document.getElementById('boostBtn');
        const controlsContainer = document.querySelector('.controls-container');
        const touchLeft = document.getElementById('touchLeft');
        const touchRight = document.getElementById('touchRight');
        const collectEffect = document.getElementById('collectEffect');
        const collisionEffect = document.getElementById('collisionEffect');
        
        // Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ
        const questionScreen = document.getElementById('questionScreen');
        const number1El = document.getElementById('number1');
        const number2El = document.getElementById('number2');
        const optionsContainer = document.getElementById('options-container');
        const resultMessageEl = document.getElementById('result-message');
        const questionTitle = document.getElementById('question-title');
        
        // Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø±Ù…ÙˆØ² Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
        const comparisonSymbols = ['<', '>', '='];
        
        // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø¹Ø¯Ø¯ ØµØ­ÙŠØ­ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¨ÙŠÙ† min Ùˆ max
        const getRandomInteger = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        
        // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø¹Ø¯Ø¯ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¨ÙŠÙ† min Ùˆ max
        const getRandomNumber = (min, max) => Math.random() * (max - min) + min;

        // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ
        const generateFraction = () => {
            const numerator = getRandomInteger(-10, 10);
            let denominator = getRandomInteger(1, 10);
            if (denominator === 0) { // ØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰ ØµÙØ±
                denominator = 1;
            }
            const value = numerator / denominator;
            const latex = `$$\\frac{${numerator}}{${denominator}}$$`;
            return { value, latex };
        };

        // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ ÙƒØ³Ø± Ø¹Ø´Ø±ÙŠ
        const generateDecimal = () => {
            const integerPart = getRandomInteger(-10, 10);
            let decimalPart = getRandomInteger(0, 999);
            if (integerPart === 0 && decimalPart === 0) {
                decimalPart = getRandomInteger(1, 999);
            }
            const value = parseFloat(`${integerPart}.${decimalPart}`);
            const latex = `$$${value}$$`;
            return { value, latex };
        };
        
        // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø¹Ø¯Ø¯ ÙƒØ³Ø±ÙŠ
        const generateMixedNumber = () => {
            const wholeNumber = getRandomInteger(-10, 10);
            const numerator = getRandomInteger(1, 9);
            let denominator = getRandomInteger(numerator + 1, 10);
            if (denominator === 0) {
                denominator = 1;
            }
            const value = wholeNumber + (numerator / denominator);
            const latex = `$$${wholeNumber}\\frac{${numerator}}{${denominator}}$$`;
            return { value, latex };
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø§Ø®ØªÙŠØ§Ø± ÙˆØªÙˆÙ„ÙŠØ¯ Ù†ÙˆØ¹ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù…Ù† Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠØ©
        const generateRandomRationalNumber = () => {
            const numberTypes = ['fraction', 'decimal', 'mixed'];
            const selectedType = numberTypes[getRandomInteger(0, numberTypes.length - 1)];
            
            switch (selectedType) {
                case 'fraction':
                    return generateFraction();
                case 'decimal':
                    return generateDecimal();
                case 'mixed':
                    return generateMixedNumber();
                default:
                    return generateFraction();
            }
        };
        
        // Ø¯Ø§Ù„Ø© Ù„Ø®Ù„Ø· Ø§Ù„Ù…ØµÙÙˆÙØ©
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };

        // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØ§Ù„Ø®ÙŠØ§Ø±Ø§Øª
        const generateQuestion = () => {
            const number1 = generateRandomRationalNumber();
            const number2 = generateRandomRationalNumber();
            
            // Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªÙ†Ø³ÙŠÙ‚ LaTeX
            number1El.innerHTML = number1.latex;
            number2El.innerHTML = number2.latex;
            
            // ØªØ´ØºÙŠÙ„ MathJax Ù„Ø¹Ø±Ø¶ Ø§Ù„ØµÙŠØº Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
            MathJax.typesetPromise([number1El, number2El]);

            let correctAnswer;
            if (number1.value < number2.value) {
                correctAnswer = '<';
            } else if (number1.value > number2.value) {
                correctAnswer = '>';
            } else {
                correctAnswer = '=';
            }

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø©
            const wrongAnswers = comparisonSymbols.filter(symbol => symbol !== correctAnswer);
            const allAnswers = shuffleArray([correctAnswer, ...wrongAnswers]);

            optionsContainer.innerHTML = ''; // Ù…Ø³Ø­ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
            resultMessageEl.textContent = ''; // Ù…Ø³Ø­ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†ØªÙŠØ¬Ø©
            resultMessageEl.classList.remove('correct', 'incorrect');

            allAnswers.forEach(symbol => {
                const button = document.createElement('button');
                button.textContent = symbol;
                button.classList.add('option-btn');
                button.addEventListener('click', () => checkAnswer(button, symbol, correctAnswer));
                optionsContainer.appendChild(button);
            });
            
            return correctAnswer;
        };

        // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
        const checkAnswer = (button, selectedSymbol, correctAnswer) => {
            const buttons = optionsContainer.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = true; // ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±
            });

            if (selectedSymbol === correctAnswer) {
                resultMessageEl.textContent = 'Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! ğŸ‰';
                resultMessageEl.classList.add('correct');
                resultMessageEl.style.display = 'block';
                button.classList.remove('option-btn');
                button.classList.add('option-btn', 'bg-green-500');
                
                // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ù…ÙƒØ§Ù† Ø¢Ù…Ù† Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
                setTimeout(() => {
                    moveToSafePosition();
                    questionScreen.style.display = 'none';
                    gameActive = true;
                    animate();
                }, 1500);
            } else {
                resultMessageEl.textContent = 'Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©! ğŸ˜”';
                resultMessageEl.classList.add('incorrect');
                resultMessageEl.style.display = 'block';
                button.classList.remove('option-btn');
                button.classList.add('option-btn', 'bg-red-500');
                
                // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
                const correctButton = Array.from(buttons).find(btn => btn.textContent === correctAnswer);
                if (correctButton) {
                    correctButton.classList.remove('option-btn');
                    correctButton.classList.add('option-btn', 'bg-green-500');
                }
                
                // Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø®Ø§Ø·Ø¦Ø©
                setTimeout(() => {
                    endGame(false, "Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¤Ø§Ù„!");
                }, 1500);
            }
        };
        
        // --- Ù…ØªØºÙŠØ±Ø§Øª ÙˆÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ù…Ø¯Ù…Ø¬Ø© ---
        let musicAudioContext;
        let melodyInterval;
        let bassInterval;
        let drumInterval;
        let isMusicPlaying = false;
        let musicEnabled = true;

        const musicToggleBtn = document.getElementById('musicToggleBtn');
        
        // ØªØ¹Ø±ÙŠÙ Ø§Ù„ÙƒÙˆØ±Ø¯Ø§Øª ÙˆØ§Ù„Ù†ÙˆØªØ§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡Ø§ Ø¨Ø§Ù„Ù‡Ø±ØªØ²
        const chords = {
            "Cmaj": [130.81, 164.81, 196.00], // C4, E4, G4
            "Gmaj": [196.00, 246.94, 293.66], // G4, B4, D5
            "Amin": [220.00, 261.63, 329.63], // A4, C5, E5
            "Fmaj": [174.61, 220.00, 261.63]  // F4, A4, C5
        };
        const chordProgression = ["Cmaj", "Amin", "Fmaj", "Gmaj"];
        const bassNotes = {
            "Cmaj": 65.41,  // C2
            "Gmaj": 97.99,  // G2
            "Amin": 110.00, // A2
            "Fmaj": 87.31   // F2
        };

        /**
         * Ø¯Ø§Ù„Ø© Ù„ØªØ´ØºÙŠÙ„ Ù†ÙˆØªØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Web Audio API.
         */
        function playMusicNote(frequency, type = 'sine', duration = 0.5, volume = 0.3, release = 0.3) {
            if (!musicAudioContext || !isMusicPlaying) return;
            
            const oscillator = musicAudioContext.createOscillator();
            const gainNode = musicAudioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(musicAudioContext.destination);
            
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            
            const now = musicAudioContext.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.02); // Ù‡Ø¬ÙˆÙ… Ø³Ø±ÙŠØ¹
            gainNode.gain.linearRampToValueAtTime(volume * 0.7, now + 0.1); // Ø§Ø¶Ù…Ø­Ù„Ø§Ù„
            gainNode.gain.linearRampToValueAtTime(0, now + duration + release); // ØªÙ„Ø§Ø´ÙŠ

            oscillator.start(now);
            oscillator.stop(now + duration + release);
        }

        /**
         * Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ´ØºÙŠÙ„ ØµÙˆØª Ø·Ø¨Ù„Ø© Ø§Ù„Ø±ÙƒÙ„ (kick drum).
         */
        function playKick() {
            if (!musicAudioContext || !isMusicPlaying) return;
            const now = musicAudioContext.currentTime;
            
            const osc = musicAudioContext.createOscillator();
            const gain = musicAudioContext.createGain();
            osc.connect(gain);
            gain.connect(musicAudioContext.destination);
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
            
            gain.gain.setValueAtTime(1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
            
            osc.start(now);
            osc.stop(now + 0.5);
        }

        /**
         * Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ´ØºÙŠÙ„ ØµÙˆØª Ø·Ø¨Ù„Ø© Ø§Ù„ÙØ® (snare).
         */
        function playSnare() {
            if (!musicAudioContext || !isMusicPlaying) return;
            const now = musicAudioContext.currentTime;
            
            const noise = musicAudioContext.createBufferSource();
            const buffer = musicAudioContext.createBuffer(1, musicAudioContext.sampleRate, musicAudioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < buffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;
            const noiseGain = musicAudioContext.createGain();
            noise.connect(noiseGain);
            noiseGain.connect(musicAudioContext.destination);
            noiseGain.gain.setValueAtTime(0.5, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            noise.start(now);
            noise.stop(now + 0.2);

            const osc = musicAudioContext.createOscillator();
            const oscGain = musicAudioContext.createGain();
            osc.connect(oscGain);
            oscGain.connect(musicAudioContext.destination);
            osc.type = 'triangle';
            osc.frequency.value = 220; // A3
            oscGain.gain.setValueAtTime(0.5, now);
            oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        }
        
        /**
         * Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ´ØºÙŠÙ„ ØµÙˆØª hi-hat.
         */
        function playHiHat() {
            if (!musicAudioContext || !isMusicPlaying) return;
            const now = musicAudioContext.currentTime;

            const noise = musicAudioContext.createBufferSource();
            const buffer = musicAudioContext.createBuffer(1, musicAudioContext.sampleRate, musicAudioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < buffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;
            const gain = musicAudioContext.createGain();
            noise.connect(gain);
            gain.connect(musicAudioContext.destination);
            
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
            
            noise.start(now);
            noise.stop(now + 0.05);
        }

        /**
         * ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ´ØºÙŠÙ„ Ø­Ù„Ù‚Ø© Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ù„Ø¹Ø¨Ø©.
         */
        function toggleMusic() {
            // Ø³Ø±Ø¹Ø© Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø«Ø§Ø¨ØªØ© (120 BPM)
            const tempo = 120;
            const intervalTime = (60 / tempo) * 1000;

            if (isMusicPlaying) {
                // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰
                clearInterval(melodyInterval);
                clearInterval(bassInterval);
                clearInterval(drumInterval);
                isMusicPlaying = false;
                musicToggleBtn.textContent = 'ğŸ¶';
            } else {
                // ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰
                if (!musicAudioContext) {
                    musicAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                let melodyIndex = 0;
                const beatsPerChord = 4;

                // Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø­Ù†
                melodyInterval = setInterval(() => {
                    const chordName = chordProgression[Math.floor(melodyIndex / beatsPerChord) % chordProgression.length];
                    const chordNotes = chords[chordName];
                    const noteFrequency = chordNotes[Math.floor(Math.random() * chordNotes.length)];
                    
                    const randomVolume = 0.3 + Math.random() * 0.2;
                    const randomDuration = 0.2 + Math.random() * 0.2;

                    playMusicNote(noteFrequency, 'triangle', randomDuration, randomVolume);
                    melodyIndex++;
                }, intervalTime / 4);

                // Ø­Ù„Ù‚Ø© Ø§Ù„Ø¨ÙŠØ³
                let bassIndex = 0;
                bassInterval = setInterval(() => {
                    const chordName = chordProgression[bassIndex % chordProgression.length];
                    const bassFrequency = bassNotes[chordName];
                    playMusicNote(bassFrequency, 'sine', 1, 0.2);
                    bassIndex++;
                }, intervalTime);

                // Ø­Ù„Ù‚Ø© Ø§Ù„Ø·Ø¨ÙˆÙ„
                let drumIndex = 0;
                drumInterval = setInterval(() => {
                    if (drumIndex % 4 === 0) {
                        playKick();
                    }
                    if (drumIndex % 4 === 2) {
                        playSnare();
                    }
                    if (drumIndex % 2 === 0) {
                        playHiHat();
                    }
                    drumIndex++;
                }, intervalTime / 4);

                isMusicPlaying = true;
                musicToggleBtn.textContent = 'ğŸ”‡';
            }
        }
        
        // --- Ù†Ù‡Ø§ÙŠØ© Ù…ØªØºÙŠØ±Ø§Øª ÙˆÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ù…Ø¯Ù…Ø¬Ø© ---
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¤Ø«Ø±Ø§Øª ØµÙˆØªÙŠØ© Ù„Ù„Ø¹Ø¨Ø©
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = false;

        function playSound(frequency, type = 'sine', duration = 0.1, volume = 0.3) {
            if (!soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            
            // Ø¥Ø¶Ø§ÙØ© ØªÙ„Ø§Ø´ÙŠ Ø¨Ø³ÙŠØ· Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ù†Ù‚Ø±Ø§Øª
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§ØµØ·Ø¯Ø§Ù… Ù†Ø§Ø¹Ù…
        function playCollisionSound() {
            if (!soundEnabled) return;
            // ØµÙˆØª Ù†Ø§Ø¹Ù… ÙˆØ¨Ø§Ø³ÙŠ
            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = 'sine'; // Ù…ÙˆØ¬Ø© Ø¬ÙŠØ¨ÙŠØ© Ù†Ø§Ø¹Ù…Ø©
            oscillator1.frequency.setValueAtTime(100, audioContext.currentTime);
            gainNode1.gain.setValueAtTime(0.7, audioContext.currentTime);
            gainNode1.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            oscillator1.start(audioContext.currentTime);
            oscillator1.stop(audioContext.currentTime + 0.3);

            // ØµÙˆØª "Ù†Ù‚Ø±Ø©" Ù‚ØµÙŠØ±Ø© Ù„Ø¥Ø¶Ø§ÙØ© Ø¨Ø¹Ø¶ Ø§Ù„ØªØ£Ø«ÙŠØ±
            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = 'sine';
            oscillator2.frequency.setValueAtTime(200, audioContext.currentTime);
            gainNode2.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode2.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
            oscillator2.start(audioContext.currentTime);
            oscillator2.stop(audioContext.currentTime + 0.1);
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø·Ø¨Ù„Ø© Ù„Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©
        function playStartDrumSound() {
            if (!soundEnabled) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'triangle'; // Ù…ÙˆØ¬Ø© Ù…Ø«Ù„Ø«ÙŠØ© Ù„Ø·Ø§Ø¨Ø¹ Ø§Ù„Ø·Ø¨Ù„Ø©
            
            // ØªØºÙŠÙŠØ± Ø§Ù„ØªØ±Ø¯Ø¯ Ù„Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØª "Ø·Ø¨Ù„"
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(50, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.8, audioContext.currentTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.4);
        }

        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ù…Ù† Ø§Ù„Ù…Ø´Ù‡Ø¯
        function clearSceneObjects(objectsArray) {
            for (let i = objectsArray.length - 1; i >= 0; i--) {
                scene.remove(objectsArray[i]);
            }
            objectsArray.length = 0;
        }

        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø´Ù‡Ø¯
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2a6c);
            scene.fog = new THREE.Fog(0x1a2a6c, 50, 200);

            if (!gameContainer) return;

            camera = new THREE.PerspectiveCamera(75, gameContainer.offsetWidth / gameContainer.offsetHeight, 0.1, 1000);
            camera.position.set(0, 10, 15);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
            updateRendererSize();
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameContainer.appendChild(renderer.domElement);

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x404040, 1);
            scene.add(hemiLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 30, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ù†Ø­Ù†ÙŠ ÙˆØ§Ù„Ø£Ø±Ø¶
            createGroundAndPath();
            createMotorcycle();
            createObstacles();
            createCollectibles();
            createScenery();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            if (restartBtn) {
                restartBtn.addEventListener('click', restartGame);
            }

            if (startGameBtn) {
                startGameBtn.addEventListener('click', function() {
                    soundEnabled = true;
                    if (startScreen) {
                        startScreen.style.opacity = '0';
                        setTimeout(() => {
                            startScreen.style.display = 'none';
                            startGame();
                        }, 800);
                    }
                });
            }

            // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù„Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰
            musicToggleBtn.addEventListener('click', toggleMusic);

            initTouchControls();
            initButtonControls();

            highScore = localStorage.getItem('motorcycleHighScore') || 0;
            if (highScoreDisplay) highScoreDisplay.textContent = `Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: ${highScore}`;

            renderer.render(scene, camera);
        }

        // ØªØ­Ø¯ÙŠØ« Ø­Ø¬Ù… Ø§Ù„Ø¹Ø§Ø±Ø¶ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
        function updateRendererSize() {
            const gameContainer = document.getElementById('gameContainer');
            if (!gameContainer) return;
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (width > 0 && height > 0) {
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø±Ø¶ ÙˆØ§Ù„Ø·Ø±ÙŠÙ‚
        function createGroundAndPath() {
            const roadPoints = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(20, 0, -20),
                new THREE.Vector3(40, 0, -10),
                new THREE.Vector3(60, 0, -40),
                new THREE.Vector3(80, 0, -20),
                new THREE.Vector3(100, 0, -50),
                new THREE.Vector3(120, 0, -30),
                new THREE.Vector3(140, 0, -70),
                new THREE.Vector3(160, 0, -50),
                new THREE.Vector3(180, 0, -90),
                new THREE.Vector3(200, 0, -70),
                new THREE.Vector3(220, 0, -50),
                new THREE.Vector3(240, 0, -80),
                new THREE.Vector3(260, 0, -60),
                new THREE.Vector3(280, 0, -100),
                new THREE.Vector3(300, 0, -80),
                new THREE.Vector3(320, 0, -120),
                new THREE.Vector3(340, 0, -100),
                new THREE.Vector3(360, 0, -140),
                new THREE.Vector3(380, 0, -120),
                new THREE.Vector3(400, 0, -160),
                new THREE.Vector3(420, 0, -140),
                new THREE.Vector3(440, 0, -180),
                new THREE.Vector3(460, 0, -160),
                new THREE.Vector3(480, 0, -200),
                new THREE.Vector3(500, 0, -180),
            ];
            curve = new THREE.CatmullRomCurve3(roadPoints);
            const segments = 200;

            clearSceneObjects(roadMarkings);

            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x558b2f, roughness: 1, metalness: 0 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.2;
            ground.receiveShadow = true;
            scene.add(ground);

            const roadWidth = laneWidth;
            const positions = [];
            const indices = [];
            const uvs = [];

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const side = new THREE.Vector3().crossVectors(up, tangent).normalize();

                const left = point.clone().add(side.clone().multiplyScalar(-roadWidth / 2));
                const right = point.clone().add(side.clone().multiplyScalar(roadWidth / 2));

                positions.push(left.x, left.y, left.z);
                positions.push(right.x, right.y, right.z);
                uvs.push(0, t * 10);
                uvs.push(1, t * 10);

                if (i < segments) {
                    const base = i * 2;
                    indices.push(base, base + 1, base + 2);
                    indices.push(base + 1, base + 3, base + 2);
                }
            }

            const roadGeometry = new THREE.BufferGeometry();
            roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            roadGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            roadGeometry.setIndex(new THREE.Uint16BufferAttribute(indices, 1));
            roadGeometry.computeVertexNormals();

            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9, metalness: 0, side: THREE.DoubleSide });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.receiveShadow = true;
            scene.add(road);
            roadMarkings.push(road);

            const centerlineMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
            for (let i = 0; i < segments; i += 2) {
                const t = i / segments;
                const startPoint = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

                const dashGeometry = new THREE.PlaneGeometry(0.5, 2);
                const dash = new THREE.Mesh(dashGeometry, centerlineMaterial);
                const pointOnCurve = curve.getPointAt(t + 0.01);
                const directionVector = pointOnCurve.clone().sub(startPoint).normalize();

                dash.position.copy(startPoint);
                dash.position.y = 0.01;
                dash.lookAt(startPoint.clone().add(directionVector));
                scene.add(dash);
                roadMarkings.push(dash);
            }
        }

        // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…Ù†Ø§Ø¸Ø± Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©
        function createScenery() {
            clearSceneObjects(sceneryObjects);
            const numObjects = 50;
            const treeColors = [0x228B22, 0x006400, 0x556B2F]; // ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØµØ®ÙˆØ± Ø§Ù„Ø²Ø®Ø±ÙÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…

            for (let i = 0; i < numObjects; i++) {
                let sceneryObj;
                // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¬Ø±Ø© ÙÙ‚Ø·
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                const leavesGeometry = new THREE.ConeGeometry(2, 3, 16);
                const leavesMaterial = new THREE.MeshStandardMaterial({ color: treeColors[i % treeColors.length], roughness: 0.6 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 2.5;

                sceneryObj = new THREE.Group();
                sceneryObj.add(trunk);
                sceneryObj.add(leaves);
                sceneryObj.position.y = 1;
                sceneryObj.castShadow = true;
                
                const t = Math.random();
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

                const side = Math.random() > 0.5 ? 1 : -1;
                const offset = (Math.random() * 30 + 15) * side;

                sceneryObj.position.copy(point.clone().add(normal.clone().multiplyScalar(offset)));
                sceneryObj.lookAt(point.clone().add(tangent));
                sceneryObj.userData.t = t;
                
                scene.add(sceneryObj);
                sceneryObjects.push(sceneryObj);
            }
        }

        // ØªÙ‡ÙŠØ¦Ø© Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
        function initTouchControls() {
            if (touchLeft && touchRight) {
                // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª Ù„ØªØ¹ÙˆÙŠØ¶ RTL
                touchLeft.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        targetLanePosition = Math.min(1, targetLanePosition + 1);
                        steeringAngle = Math.max(-maxSteeringAngle, steeringAngle - steeringSpeed);
                    }
                });
                touchRight.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        targetLanePosition = Math.max(-1, targetLanePosition - 1);
                        steeringAngle = Math.min(maxSteeringAngle, steeringAngle + steeringSpeed);
                    }
                });
                // ØªØ­Ø³ÙŠÙ† touchmove Ù„Ù„Ø³Ø­Ø¨ Ø§Ù„Ù…Ø³ØªÙ…Ø±ØŒ Ù…Ø¹ ØªØ¨Ø¯ÙŠÙ„
                touchLeft.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        steeringAngle = Math.max(-maxSteeringAngle, steeringAngle - steeringSpeed * 0.5);
                    }
                });
                touchRight.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        steeringAngle = Math.min(maxSteeringAngle, steeringAngle + steeringSpeed * 0.5);
                    }
                });
            }

            // Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø³Ø­Ø¨ Ù„Ù„Ø£Ø¹Ù„Ù‰ Ù„Ù„Ù‚ÙØ²
            if (gameContainer) {
                gameContainer.addEventListener('touchstart', (e) => {
                    if (gameActive) {
                        touchStartY = e.touches[0].clientY;
                    }
                });
                gameContainer.addEventListener('touchend', (e) => {
                    if (gameActive && touchStartY !== null) {
                        const touchEndY = e.changedTouches[0].clientY;
                        const deltaY = touchEndY - touchStartY;
                        if (deltaY < -50) { // Ø³Ø­Ø¨ Ù„Ù„Ø£Ø¹Ù„Ù‰
                            performJump();
                        }
                        touchStartY = null;
                    }
                });
            }
        }

        // ØªÙ‡ÙŠØ¦Ø© Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        function initButtonControls() {
            if (jumpBtn) {
                jumpBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (gameActive && !isJumping) {
                        performJump();
                    }
                });
            }

            if (boostBtn) {
                boostBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (gameActive) {
                        activateBoost();
                    }
                });
            }
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø§Ø¬Ø© Ø§Ù„Ù†Ø§Ø±ÙŠØ©
        function createMotorcycle() {
            const scale = 0.5;
            motorcycle = new THREE.Group();

            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.9, roughness: 0.2 });
            const secondaryBodyMaterial = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.9, roughness: 0.1 });
            const engineMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.1 });
            const tireMaterial = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 10 });
            const seatMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });

            // Ø¬Ø³Ù… Ø§Ù„Ø¯Ø±Ø§Ø¬Ø©
            const bodyMain = new THREE.Mesh(new THREE.BoxGeometry(1.5 * scale, 0.6 * scale, 2.5 * scale), bodyMaterial);
            bodyMain.position.set(0, 0.4 * scale, 0);
            motorcycle.add(bodyMain);

            // Ø®Ø²Ø§Ù† Ø§Ù„ÙˆÙ‚ÙˆØ¯
            const tankGeometry = new THREE.BoxGeometry(1.2 * scale, 0.5 * scale, 1.0 * scale);
            const tank = new THREE.Mesh(tankGeometry, bodyMaterial);
            tank.position.set(0, 0.8 * scale, 0.8 * scale);
            motorcycle.add(tank);

            // Ø§Ù„Ù…Ù‚Ø¹Ø¯
            const seatGeometry = new THREE.BoxGeometry(1.0 * scale, 0.2 * scale, 1.2 * scale);
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.set(0, 0.8 * scale, -0.2 * scale);
            motorcycle.add(seat);

            // Ø§Ù„Ù…Ø­Ø±Ùƒ
            const engineGeometry = new THREE.BoxGeometry(1.0 * scale, 0.8 * scale, 1.2 * scale);
            const engineMesh = new THREE.Mesh(engineGeometry, engineMaterial);
            engineMesh.position.set(0, -0.1 * scale, 0.1 * scale);
            motorcycle.add(engineMesh);

            // Ø§Ù„Ø¹Ø¬Ù„Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© ÙˆØ§Ù„Ø®Ù„ÙÙŠØ©
            const tireGeometry = new THREE.TorusGeometry(0.8 * scale, 0.3 * scale, 16, 32);
            const frontWheel = new THREE.Mesh(tireGeometry, tireMaterial);
            frontWheel.rotation.y = Math.PI / 2;
            frontWheel.position.set(0, -0.6 * scale, 2.0 * scale);
            motorcycle.add(frontWheel);
            
            const backWheel = new THREE.Mesh(tireGeometry, tireMaterial);
            backWheel.rotation.y = Math.PI / 2;
            backWheel.position.set(0, -0.6 * scale, -2.0 * scale);
            motorcycle.add(backWheel);

            // Ø§Ù„Ø´ÙˆÙƒØ§Øª ÙˆØ§Ù„Ù…Ù‚ÙˆØ¯
            const forkGeometry = new THREE.CylinderGeometry(0.1 * scale, 0.1 * scale, 2.5 * scale, 8);
            const forkMaterial = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 1.0, roughness: 0.1 });
            const leftFork = new THREE.Mesh(forkGeometry, forkMaterial);
            leftFork.position.set(-0.5 * scale, 0.5 * scale, 1.9 * scale);
            leftFork.rotation.x = Math.PI / 6;
            motorcycle.add(leftFork);

            const rightFork = new THREE.Mesh(forkGeometry, forkMaterial);
            rightFork.position.set(0.5 * scale, 0.5 * scale, 1.9 * scale);
            rightFork.rotation.x = Math.PI / 6;
            motorcycle.add(rightFork);

            const handlebarGeometry = new THREE.CylinderGeometry(0.08 * scale, 0.08 * scale, 1.5 * scale, 8);
            handlebarGeometry.rotateZ(Math.PI / 2);
            const handlebar = new THREE.Mesh(handlebarGeometry, forkMaterial);
            handlebar.position.set(0, 1.2 * scale, 1.5 * scale);
            handlebar.rotation.x = Math.PI / 8;
            handlebar.name = 'handlebar';
            motorcycle.add(handlebar);

            // Ø§Ù„Ø£Ø¶ÙˆØ§Ø¡ Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© ÙˆØ§Ù„Ø®Ù„ÙÙŠØ©
            const headlightGeometry = new THREE.SphereGeometry(0.4 * scale, 32, 32);
            const headlightMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5, metalness: 0.8, roughness: 0.2 });
            const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            headlight.position.set(0, 0.8 * scale, 2.2 * scale);
            motorcycle.add(headlight);

            const taillightGeometry = new THREE.BoxGeometry(0.4 * scale, 0.2 * scale, 0.1 * scale);
            const taillightMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3, metalness: 0.8, roughness: 0.2 });
            const taillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
            taillight.position.set(0, 0.7 * scale, -2.5 * scale);
            motorcycle.add(taillight);

            // Ø§Ù„Ø³Ø§Ø¦Ù‚
            const riderGroup = new THREE.Group();
            riderGroup.name = 'rider';
            const suitMaterial = new THREE.MeshStandardMaterial({ color: 0x00bfff, metalness: 0.2, roughness: 0.8 });
            const helmetMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.2 });
            const limbMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500, metalness: 0.2, roughness: 0.8 });

            const headGeometry = new THREE.BoxGeometry(0.8 * scale, 0.8 * scale, 0.8 * scale);
            const head = new THREE.Mesh(headGeometry, helmetMaterial);
            head.position.set(0, 1.5 * scale, 0.2 * scale);
            riderGroup.add(head);

            const bodyGeometryRider = new THREE.BoxGeometry(1.0 * scale, 1.5 * scale, 0.8 * scale);
            const bodyRider = new THREE.Mesh(bodyGeometryRider, suitMaterial);
            bodyRider.position.set(0, 0.8 * scale, 0);
            riderGroup.add(bodyRider);

            const armGeometry = new THREE.CylinderGeometry(0.15 * scale, 0.15 * scale, 1.0 * scale, 8);
            const leftArm = new THREE.Mesh(armGeometry, limbMaterial);
            leftArm.position.set(-0.6 * scale, 0.9 * scale, 0.7 * scale);
            leftArm.rotation.z = Math.PI / 4;
            riderGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, limbMaterial);
            rightArm.position.set(0.6 * scale, 0.9 * scale, 0.7 * scale);
            rightArm.rotation.z = -Math.PI / 4;
            riderGroup.add(rightArm);

            const legGeometry = new THREE.CylinderGeometry(0.18 * scale, 0.18 * scale, 1.2 * scale, 8);
            const leftLeg = new THREE.Mesh(legGeometry, limbMaterial);
            leftLeg.position.set(-0.3 * scale, 0.1 * scale, 0);
            leftLeg.rotation.x = Math.PI / 2;
            riderGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, limbMaterial);
            rightLeg.position.set(0.3 * scale, 0.1 * scale, 0);
            rightLeg.rotation.x = Math.PI / 2;
            riderGroup.add(rightLeg);
            
            motorcycle.add(riderGroup);

            // Ø§Ù„Ø¯Ø±Ø¹
            const shieldGeometry = new THREE.SphereGeometry(1.5 * scale, 32, 32);
            const shieldMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700, transparent: true, opacity: 0.3, wireframe: true });
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.name = 'shield';
            shield.position.y = 0.5 * scale;
            shield.visible = false;
            motorcycle.add(shield);

            motorcycle.castShadow = true;

            const pathFollower = new THREE.Group();
            pathFollower.name = "pathFollower";
            pathFollower.add(motorcycle);
            scene.add(pathFollower);
            motorcycle.position.y = 0;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚
        function createObstacles() {
            clearSceneObjects(obstacles);
            const obstacleTypes = ['cone', 'barrier', 'spike', 'pipe'];
            for (let i = 0; i < 30; i++) {
                const obstacleType = Math.floor(Math.random() * obstacleTypes.length);
                let obstacle;
                let geometry, material;

                if (obstacleType === 0) { // Ø­Ø§Ø¬Ø² Ù…Ø®Ø±ÙˆØ·ÙŠ (cone)
                    geometry = new THREE.ConeGeometry(0.6, 1.5, 16);
                    material = new THREE.MeshStandardMaterial({ color: 0xffa500, // Ù„ÙˆÙ† Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ
                        roughness: 0.8 });
                    obstacle = new THREE.Mesh(geometry, material);
                    // Ø¥Ø¶Ø§ÙØ© Ø´Ø±ÙŠØ· Ø£Ø¨ÙŠØ¶
                    const stripeGeometry = new THREE.CylinderGeometry(0.65, 0.65, 0.2, 16);
                    const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.y = -0.5;
                    obstacle.add(stripe);
                    obstacle.position.y = 0.75;
                    obstacle.userData = { isJumpable: false, type: 'cone' };

                } else if (obstacleType === 1) { // Ø­Ø§Ø¬Ø² Ø¹Ù„Ù‰ Ø´ÙƒÙ„ ØµÙ†Ø¯ÙˆÙ‚ (barrier)
                    geometry = new THREE.BoxGeometry(2, 0.8, 0.5);
                    const texture = new THREE.CanvasTexture(createStripePattern());
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.repeat.set(2, 1);
                    material = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.position.y = 0.4;
                    obstacle.userData = { isJumpable: true, type: 'barrier' };

                } else if (obstacleType === 2) { // Ø­Ø§Ø¬Ø² Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Ø³Ù† Ù…Ø¯Ø¨Ø¨ (spike)
                    geometry = new THREE.ConeGeometry(0.4, 1, 8);
                    material = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.7, roughness: 0.5 });
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.position.y = 0.5;
                    obstacle.userData = { isJumpable: false, type: 'spike' };

                } else { // Ø­Ø§Ø¬Ø² Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Ø£Ù†Ø¨ÙˆØ¨ (pipe)
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16);
                    material = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.9, roughness: 0.1 });
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.rotation.x = Math.PI / 2;
                    obstacle.position.y = 0.5;
                    obstacle.userData = { isJumpable: true, type: 'pipe' };
                }

                obstacle.castShadow = true;
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù†Ù‚Ø´ Ù…Ø®Ø·Ø·
        function createStripePattern() {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const context = canvas.getContext('2d');
            context.fillStyle = '#ffcc00'; // Ø£ØµÙØ±
            context.fillRect(0, 0, 16, 16);
            context.fillStyle = '#000000'; // Ø£Ø³ÙˆØ¯
            context.fillRect(0, 0, 8, 16);
            return canvas;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø¬Ù…Ø¹
        function createCollectibles() {
            clearSceneObjects(collectibles);
            const collectibleTypes = ['shield', 'boost', 'time', 'ring'];

            for (let i = 0; i < 30; i++) {
                const collectibleType = Math.floor(Math.random() * collectibleTypes.length);
                let collectible;

                if (collectibleType === 0) { // Ø¯Ø±Ø¹
                    const geometry = new THREE.TorusGeometry(0.4, 0.1, 16, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.5 });
                    collectible = new THREE.Mesh(geometry, material);
                    collectible.userData = { type: 'shield' };
                } else if (collectibleType === 1) { // ØªØ³Ø§Ø±Ø¹
                    const geometry = new THREE.ConeGeometry(0.4, 0.8, 4);
                    const material = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3 });
                    collectible = new THREE.Mesh(geometry, material);
                    collectible.rotation.x = Math.PI;
                    collectible.userData = { type: 'boost' };
                } else if (collectibleType === 2) { // ÙˆÙ‚Øª
                    const geometry = new THREE.RingGeometry(0.3, 0.5, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5, side: THREE.DoubleSide });
                    collectible = new THREE.Mesh(geometry, material);
                    collectible.rotation.x = Math.PI / 2;
                    collectible.userData = { type: 'time' };
                } else { // Ø§Ù„Ø­Ù„Ù‚Ø§Øª Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©
                    const geometry = new THREE.TorusGeometry(0.5, 0.1, 16, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.8 });
                    collectible = new THREE.Mesh(geometry, material);
                    collectible.userData = { type: 'ring' };
                }

                collectible.position.y = 7;
                scene.add(collectible);
                collectibles.push(collectible);
            }
        }

        function onWindowResize() {
            updateRendererSize();
        }

        // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø¶ØºØ·Ø§Øª Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        function handleKeyDown(event) {
            if (!gameActive) return;
            if (event.key === 'ArrowLeft') {
                targetLanePosition = Math.max(-1, targetLanePosition - 1);
                steeringAngle = Math.min(maxSteeringAngle, steeringAngle + steeringSpeed);
            } else if (event.key === 'ArrowRight') {
                targetLanePosition = Math.min(1, targetLanePosition + 1);
                steeringAngle = Math.max(-maxSteeringAngle, steeringAngle - steeringSpeed);
            } else if (event.key === ' ' || event.key === 'ArrowUp') {
                performJump();
            } else if (event.key === 'Enter') {
                activateBoost();
            }
        }

        function handleKeyUp(event) {
            // Ù„Ø§ Ø­Ø§Ø¬Ø© Ø­Ø§Ù„ÙŠÙ‹Ø§
        }
        
        function performJump() {
            if (!isJumping) {
                isJumping = true;
                jumpProgress = 0;
                // ØµÙˆØª Ø§Ù„Ù‚ÙØ²
                playSound(440, 'sine', 0.1, 0.5); 
            }
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        function startGame() {
            if (timerInterval) clearInterval(timerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            gameActive = true;
            score = 0;
            timer = 60;
            currentSpeed = baseSpeed; // Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
            t = 0;
            steeringAngle = 0;
            const pathFollower = scene.getObjectByName("pathFollower");
            if (pathFollower) {
                pathFollower.position.set(0, 0, 0);
            }
            targetLanePosition = 0;
            shieldCount = 0;
            boostCount = 0;
            isJumping = false;

            if (gameOverScreen) gameOverScreen.style.display = 'none';
            if (gameStatsContainer) gameStatsContainer.style.display = 'flex';
            if (controlsContainer) controlsContainer.style.display = 'flex';
            if (shieldDisplay) shieldDisplay.textContent = `Ø§Ù„Ø¯Ø±Ø¹: ${shieldCount}`;
            if (speedDisplay) speedDisplay.textContent = `Ø§Ù„Ø³Ø±Ø¹Ø©: ${Math.round(currentSpeed * 10000)}`;
            if (scoreDisplay) scoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
            if (timerDisplay) timerDisplay.textContent = `Ø§Ù„ÙˆÙ‚Øª: ${timer}`;
            if (gameOverReason) gameOverReason.textContent = "";

            const shieldMesh = motorcycle.getObjectByName('shield');
            if (shieldMesh) shieldMesh.visible = false;
            shieldActive = false;
            boostActive = false;

            document.body.style.background = 'linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c)';

            placeObjectsOnCurve();
            animate();
            startTimer();
            toggleMusic(); // Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø¤Ù‚Øª
        function startTimer() {
            timerInterval = setInterval(() => {
                if (gameActive) {
                    timer--;
                    if (timerDisplay) timerDisplay.textContent = `Ø§Ù„ÙˆÙ‚Øª: ${timer}`;
                    if (timer <= 0) {
                        clearInterval(timerInterval);
                        endGame(true, "Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª!");
                    }
                } else {
                    clearInterval(timerInterval);
                }
            }, 1000);
        }

        // Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        function endGame(isWin, reason = "Ø§ØµØ·Ø¯Ø§Ù…!") {
            gameActive = false;
            if (timerInterval) clearInterval(timerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            toggleMusic(); // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©

            if (finalScoreDisplay) finalScoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
            if (gameStatsContainer) gameStatsContainer.style.display = 'none';
            if (controlsContainer) controlsContainer.style.display = 'none';
            if (gameOverReason) gameOverReason.textContent = reason;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('motorcycleHighScore', highScore);
                if (highScoreDisplay) {
                    highScoreDisplay.textContent = `Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø© Ø¬Ø¯ÙŠØ¯Ø©: ${highScore}`;
                    highScoreDisplay.style.color = '#ffc107';
                    highScoreDisplay.style.fontWeight = 'bold';
                }
            } else {
                if (highScoreDisplay) {
                    highScoreDisplay.textContent = `Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: ${highScore}`;
                    highScoreDisplay.style.color = '#ccc';
                }
            }

            if (gameOverScreen) gameOverScreen.style.display = 'block';

            // ØµÙˆØª Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
            playStartDrumSound();
        }

        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©
        function restartGame() {
            if (gameOverScreen) gameOverScreen.style.display = 'none';
            gameActive = false;
            if (timerInterval) clearInterval(timerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            startGame();
        }

        // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø¹ Ø§Ù„ÙˆØ§Ù‚ÙŠ
        function activateShield() {
            if (shieldCount > 0 && gameActive && !shieldActive) {
                shieldCount--;
                shieldActive = true;
                const shieldMesh = motorcycle.getObjectByName('shield');
                if (shieldMesh) shieldMesh.visible = true;
                if (shieldDisplay) shieldDisplay.textContent = `Ø§Ù„Ø¯Ø±Ø¹: ${shieldCount}`;
                setTimeout(() => {
                    if (gameActive) {
                        shieldActive = false;
                        if (shieldMesh) shieldMesh.visible = false;
                    }
                }, 5000);
            }
        }

        // ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ³Ø§Ø±Ø¹
        function activateBoost() {
            if (boostCount > 0 && gameActive && !boostActive) {
                boostCount--;
                boostActive = true;
                // ØµÙˆØª Ø§Ù„ØªØ³Ø§Ø±Ø¹
                playSound(600, 'triangle', 0.1, 0.6); 
                document.body.style.background = 'linear-gradient(135deg, #ffeb3b, #ff8c00)';
                setTimeout(() => {
                    if (gameActive) {
                        boostActive = false;
                        document.body.style.background = 'linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c)';
                    }
                }, 3000);
            }
        }

        // ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø±
        function placeObjectsOnCurve() {
            obstacles.forEach(obstacle => {
                const t = Math.random() * 0.9 + 0.1;
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();
                let laneIndex = Math.floor(Math.random() * 3) - 1;
                if (Math.random() < 0.5) laneIndex = laneIndex === 0 ? (Math.random() > 0.5 ? 1 : -1) : laneIndex; // ØªÙ‚Ù„ÙŠÙ„ Ø§Ø­ØªÙ…Ø§Ù„ Ø§Ù„ÙˆØ³Ø·
                const offset = laneIndex * laneWidth * 0.5;
                obstacle.position.copy(point.clone().add(normal.multiplyScalar(offset)));
                obstacle.rotation.y = Math.atan2(tangent.z, tangent.x) + Math.PI / 2;
                obstacle.userData.t = t;
            });

            collectibles.forEach(collectible => {
                const t = Math.random() * 0.9 + 0.1;
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();
                const offset = (Math.floor(Math.random() * 3) - 1) * laneWidth * 0.5;
                collectible.position.copy(point.clone().add(normal.multiplyScalar(offset)));
                collectible.rotation.y = Math.atan2(tangent.z, tangent.x) + Math.PI / 2;
                collectible.userData.t = t;
            });
            
            sceneryObjects.forEach(sceneryObj => {
                const t = Math.random();
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

                const side = Math.random() > 0.5 ? 1 : -1;
                const offset = (Math.random() * 30 + 15) * side;

                sceneryObj.position.copy(point.clone().add(normal.clone().multiplyScalar(offset)));
                sceneryObj.position.y = sceneryObj.geometry instanceof THREE.DodecahedronGeometry ? 0.5 : 1;
                sceneryObj.lookAt(point.clone().add(tangent));
                sceneryObj.userData.t = t;
            });
        }

        // Ø¹Ø±Ø¶ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¬Ù…Ø¹
        function showCollectEffect(x, y) {
            collectEffect.style.display = 'block';
            collectEffect.style.left = `${x - 20}px`;
            collectEffect.style.top = `${y - 20}px`;
            setTimeout(() => {
                collectEffect.style.display = 'none';
            }, 600);
        }

        // Ø¹Ø±Ø¶ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
        function showCollisionEffect(x, y) {
            collisionEffect.style.display = 'block';
            collisionEffect.style.left = `${x - 50}px`;
            collisionEffect.style.top = `${y - 50}px`;
            setTimeout(() => {
                collisionEffect.style.display = 'none';
            }, 500);
        }
        
        // Ù†Ù‚Ù„ Ø§Ù„Ø¯Ø±Ø§Ø¬Ø© Ø¥Ù„Ù‰ Ù…ÙƒØ§Ù† Ø¢Ù…Ù† Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
        function moveToSafePosition() {
            t += 0.05; // Ù†Ù‚Ù„ Ø§Ù„Ø¯Ø±Ø§Ø¬Ø© Ù„Ù„Ø£Ù…Ø§Ù… Ù‚Ù„ÙŠÙ„Ø§Ù‹
            const position = curve.getPointAt(t);
            const tangent = curve.getTangentAt(t).normalize();
            const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();
            
            const motorcyclePosition = position.clone().add(normal.clone().multiplyScalar(0));
            motorcyclePosition.y = 0.8;
            
            const pathFollower = scene.getObjectByName("pathFollower");
            if (pathFollower) {
                pathFollower.position.copy(motorcyclePosition);
                pathFollower.lookAt(motorcyclePosition.clone().add(tangent));
            }
        }

        // Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
        function animate() {
            if (!gameActive) {
                return;
            }

            animationFrameId = requestAnimationFrame(animate);

            // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø³Ø±Ø¹Ø©
            if (boostActive) {
                currentSpeed += acceleration;
                if (currentSpeed > maxBoostSpeed) {
                    currentSpeed = maxBoostSpeed;
                }
            } else {
                if (currentSpeed > baseSpeed) {
                    currentSpeed -= acceleration;
                    if (currentSpeed < baseSpeed) {
                        currentSpeed = baseSpeed;
                    }
                }
            }

            if (speedDisplay) speedDisplay.textContent = `Ø§Ù„Ø³Ø±Ø¹Ø©: ${Math.round(currentSpeed * 10000)}`;

            t += currentSpeed;
            if (t > 1) {
                t = 0;
                placeObjectsOnCurve();
            }

            const position = curve.getPointAt(t);
            const tangent = curve.getTangentAt(t).normalize();
            const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

            const targetLaneOffset = targetLanePosition * laneWidth * 0.5;
            const currentLaneOffset = motorcycle.parent.position.clone().sub(position).dot(normal);
            const newLaneOffset = currentLaneOffset + (targetLaneOffset - currentLaneOffset) * 0.3;

            const motorcyclePosition = position.clone().add(normal.clone().multiplyScalar(newLaneOffset));

            if (Math.abs(newLaneOffset) > (laneWidth * 1.5)) { // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø­Ø¯ Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠ
                console.log("Out of lane at offset:", newLaneOffset);
                endGame(false, "Ø£Ø­Ø³Ù†Øª ÙˆØµÙ„Øª Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø³Ø§Ø±!");
                return;
            }

            if (isJumping) {
                jumpProgress += 16 / jumpDuration;
                const jumpY = Math.sin(jumpProgress * Math.PI) * jumpHeight;
                motorcyclePosition.y = jumpY + 0.8;
                if (jumpProgress >= 1) {
                    isJumping = false;
                    jumpProgress = 0;
                }
            } else {
                motorcyclePosition.y = 0.8;
            }

            motorcycle.parent.position.copy(motorcyclePosition);
            motorcycle.parent.lookAt(motorcycle.parent.position.clone().add(tangent));

            // ØªØ·Ø¨ÙŠÙ‚ Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù…Ù‚ÙˆØ¯
            const handlebar = motorcycle.getObjectByName('handlebar');
            if (handlebar) {
                handlebar.rotation.z = -steeringAngle * 2;
            }

            // Ø§Ù„Ø¹ÙˆØ¯Ø© Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠØ© Ù„Ù„Ù…Ù‚ÙˆØ¯ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù†ØªØµÙ
            if (steeringAngle > 0) {
                steeringAngle = Math.max(0, steeringAngle - steeringReturnSpeed);
            } else if (steeringAngle < 0) {
                steeringAngle = Math.min(0, steeringAngle + steeringReturnSpeed);
            }

            const cameraOffset = new THREE.Vector3(0, 3, -5).applyQuaternion(motorcycle.parent.quaternion);
            camera.position.copy(motorcycle.parent.position).add(cameraOffset);
            camera.lookAt(motorcycle.parent.position);

            const motorcycleBbox = new THREE.Box3().setFromObject(motorcycle);

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.rotation.y += currentSpeed * 50;
                const obstacleBbox = new THREE.Box3().setFromObject(obstacle);

                const distance = Math.abs(obstacle.userData.t - t);
                const sideDistance = motorcycle.parent.position.clone().sub(obstacle.position).dot(normal); // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©

                if (motorcycleBbox.intersectsBox(obstacleBbox) && distance < 0.02) {
                    if (Math.abs(sideDistance) > 0.5) { // ØªØ¬Ø§Ù‡Ù„ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø±ÙˆØ± Ø¬Ø§Ù†Ø¨ÙŠ (Ù…Ø³Ø§ÙØ© > 0.5)
                        console.log("Ignored collision due to side distance:", sideDistance);
                        continue;
                    }
                    console.log("Collision with obstacle:", obstacle.userData.type, "at distance:", distance, "side:", sideDistance);
                    
                    const isJumpable = obstacle.userData.isJumpable;
                    if (isJumpable && isJumping) {
                        // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø§Ø¬Ø² Ø¨Ø§Ù„Ù‚ÙØ²
                    } else if (shieldActive) {
                        obstacle.position.x = -1000;
                        score += 50;
                        scoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
                    } else {
                        // Ø¹Ø±Ø¶ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
                        const screenPosition = obstacle.position.clone().project(camera);
                        const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
                        showCollisionEffect(x, y);
                        // ØµÙˆØª Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
                        playCollisionSound();
                        
                        // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ¹Ø±Ø¶ Ø§Ù„Ø³Ø¤Ø§Ù„
                        gameActive = false;
                        cancelAnimationFrame(animationFrameId);
                        generateQuestion();
                        questionScreen.style.display = 'flex';
                        return;
                    }
                }

                if (obstacle.userData.t < t - 0.2) {
                    const newT = t + Math.random() * 0.2 + 0.2;
                    const newPoint = curve.getPointAt(newT % 1);
                    const newTangent = curve.getTangentAt(newT % 1).normalize();
                    const newNormal = new THREE.Vector3(0, 1, 0).cross(newTangent).normalize();
                    let laneIndex = Math.floor(Math.random() * 3) - 1;
                    if (Math.random() < 0.5) laneIndex = laneIndex === 0 ? (Math.random() > 0.5 ? 1 : -1) : laneIndex; // ØªÙ‚Ù„ÙŠÙ„ Ø§Ø­ØªÙ…Ø§Ù„ Ø§Ù„ÙˆØ³Ø·
                    const newOffset = laneIndex * laneWidth * 0.5;
                    obstacle.position.copy(newPoint.clone().add(newNormal.multiplyScalar(newOffset)));
                    obstacle.rotation.y = Math.atan2(newTangent.z, newTangent.x) + Math.PI / 2;
                    obstacle.userData.t = newT;
                    score += 10;
                    scoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
                }
            }

            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                collectible.rotation.y += 0.05;
                const collectibleBbox = new THREE.Box3().setFromObject(collectible);
                
                if (motorcycleBbox.intersectsBox(collectibleBbox)) {
                    if (collectible.userData.type === 'shield') {
                        shieldCount++;
                        if (shieldDisplay) shieldDisplay.textContent = `Ø§Ù„Ø¯Ø±Ø¹: ${shieldCount}`;
                    } else if (collectible.userData.type === 'boost') {
                        boostCount++;
                    } else if (collectible.userData.type === 'time') {
                        timer += 5;
                        if (timerDisplay) timerDisplay.textContent = `Ø§Ù„ÙˆÙ‚Øª: ${timer}`;
                    } else if (collectible.userData.type === 'ring') {
                        score += 100;
                        scoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
                    }
                    
                    // ØµÙˆØª Ø¬Ù…Ø¹ Ø§Ù„Ù‚Ø·Ø¹
                    playSound(880, 'sine', 0.1, 0.4); 

                    // Ø¹Ø±Ø¶ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¬Ù…Ø¹
                    const screenPosition = collectible.position.clone().project(camera);
                    const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
                    showCollectEffect(x, y);

                    collectible.position.x = -1000;
                    score += 25;
                    scoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
                }

                if (collectible.userData.t < t - 0.1) {
                    const newT = t + Math.random() * 0.2 + 0.1;
                    const newPoint = curve.getPointAt(newT % 1);
                    const newTangent = curve.getTangentAt(newT % 1).normalize();
                    const newNormal = new THREE.Vector3(0, 1, 0).cross(newTangent).normalize();
                    const newOffset = (Math.floor(Math.random() * 3) - 1) * laneWidth * 0.5;

                    collectible.position.copy(newPoint.clone().add(newNormal.multiplyScalar(newOffset)));
                    collectible.rotation.y = Math.atan2(newTangent.z, newTangent.x) + Math.PI / 2;
                    collectible.userData.t = newT;
                }
            }

            for (let i = sceneryObjects.length - 1; i >= 0; i--) {
                const sceneryObj = sceneryObjects[i];
                if (sceneryObj.userData.t < t - 0.1) {
                    const newT = t + Math.random() * 0.5 + 0.1;
                    const point = curve.getPointAt(newT % 1);
                    const tangent = curve.getTangentAt(newT % 1).normalize();
                    const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

                    const side = Math.random() > 0.5 ? 1 : -1;
                    const offset = (Math.random() * 30 + 15) * side;

                    sceneryObj.position.copy(point.clone().add(normal.clone().multiplyScalar(offset)));
                    sceneryObj.position.y = sceneryObj.geometry instanceof THREE.DodecahedronGeometry ? 0.5 : 1;
                    sceneryObj.lookAt(point.clone().add(tangent));
                    sceneryObj.userData.t = newT;
                }
            }

            renderer.render(scene, camera);
        }

        window.onload = function() {
            init();
        };
    </script>
</body>
</html>
