<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ŸÖŸÜÿµÿßÿ™ ÿ∑ÿßÿ¶ÿ±ÿ© - ŸÇŸÅÿ≤ Ÿàÿ™ÿ¨ŸÜÿ® ÿßŸÑÿπŸÇÿ®ÿßÿ™</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://cdn.tailwindcss.com"></script>
<style>
/* General styling */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
body {
    background: radial-gradient(circle at top left, #1a2a6c, #1d3557, #0f1429);
    color: #fff;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    direction: rtl;
}
.game-container {
    width: 100%;
    max-width: 900px;
    height: 90vh;
    max-height: 700px;
    position: relative;
    box-shadow: 0 0 60px rgba(0, 0, 0, 0.9);
    border-radius: 20px;
    overflow: hidden;
    border: 2px solid rgba(76, 201, 240, 0.3);
}
/* Start and End Screens */
.start-screen, .end-screen, .question-modal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(12, 26, 58, 0.98), rgba(15, 20, 41, 0.98));
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
    padding: 20px;
    text-align: center;
}
.end-screen {
    background: linear-gradient(135deg, rgba(58, 12, 26, 0.95), rgba(41, 15, 20, 0.95));
    display: none;
}
.question-modal {
    background: linear-gradient(135deg, rgba(29, 53, 87, 0.95), rgba(45, 123, 157, 0.95));
    z-index: 120;
    display: none;
    padding: 15px;
}
.logo {
    font-size: 4.5rem;
    font-weight: 900;
    margin-bottom: 20px;
    background: linear-gradient(45deg, #4cc9f0, #4361ee, #7209b7);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 0 30px rgba(76, 201, 240, 0.6);
    animation: pulseGlow 2s infinite alternate;
}
@keyframes pulseGlow {
    0% {
        text-shadow: 0 0 20px rgba(76, 201, 240, 0.4);
    }
    100% {
        text-shadow: 0 0 40px rgba(76, 201, 240, 0.8);
    }
}
.subtitle {
    font-size: 1.8rem;
    margin-bottom: 30px;
    color: #f1faee;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
}
/* Character Selection */
.characters {
    display: flex;
    gap: 25px;
    margin: 20px 0;
    flex-wrap: wrap;
    justify-content: center;
}
.character {
    width: 80px;
    height: 80px;
    border-radius: 15px;
    background: linear-gradient(135deg, #1d3557, #457b9d);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 4px solid transparent;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
    position: relative;
    overflow: hidden;
}
.character::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.1);
    transform: translateX(-100%) skewX(-30deg);
    transition: transform 0.5s ease;
}
.character:hover::before {
    transform: translateX(100%) skewX(-30deg);
}
.character.active {
    border-color: #4cc9f0;
    box-shadow: 0 0 25px rgba(76, 201, 240, 0.9);
    transform: translateY(-8px) scale(1.05);
}
.character i {
    font-size: 3rem;
    color: #f1faee;
    margin-bottom: 5px;
}
.character span {
    font-size: 0.9rem;
    color: #f1faee;
    font-weight: 600;
}
.character:nth-child(2) i {
    color: #ff9e00;
}
.character:nth-child(3) i {
    color: #ff0054;
}
/* Buttons */
.btn {
    background: linear-gradient(45deg, #4361ee, #3a0ca3);
    color: white;
    border: none;
    padding: 16px 40px;
    font-size: 1.4rem;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 15px;
    box-shadow: 0 8px 25px rgba(67, 97, 238, 0.6);
    display: flex;
    align-items: center;
    gap: 10px;
    position: relative;
    overflow: hidden;
    z-index: 1;
}
.btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    transition: width 0.4s ease-out, height 0.4s ease-out, top 0.4s ease-out, left 0.4s ease-out;
    transform: translate(-50%, -50%);
    z-index: -1;
}
.btn:hover {
    transform: translateY(-5px);
    box-shadow: 0 12px 30px rgba(67, 97, 238, 0.8);
}
.btn:hover::before {
    width: 200%;
    height: 200%;
    top: -50%;
    left: -50%;
}
.btn i {
    font-size: 1.3rem;
}
.music-toggle-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    padding: 10px 15px;
    font-size: 1.2rem;
    border-radius: 50%;
    cursor: pointer;
    z-index: 101;
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.5);
    transition: background 0.3s ease, transform 0.2s ease;
}
.music-toggle-btn:hover {
    background: rgba(0, 0, 0, 0.7);
    transform: scale(1.05);
}
/* Controls Info */
.controls-info {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    margin: 25px 0;
    gap: 12px;
}
.control-item {
    background: rgba(76, 201, 240, 0.2);
    padding: 12px 20px;
    border-radius: 18px;
    font-size: 1.1rem;
    transition: all 0.3s;
    border: 1px solid rgba(76, 201, 240, 0.4);
}
.control-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(76, 201, 240, 0.4);
    background: rgba(76, 201, 240, 0.35);
}
/* Stats Display */
.stats {
    display: flex;
    gap: 25px;
    margin-top: 25px;
    background: rgba(0, 0, 0, 0.4);
    padding: 15px 35px;
    border-radius: 20px;
    font-size: 1.2rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
    flex-wrap: wrap;
    justify-content: center;
}
.stat {
    display: flex;
    flex-direction: column;
    align-items: center;
}
.stat-value {
    font-size: 2rem;
    font-weight: 700;
    color: #4cc9f0;
    text-shadow: 0 0 15px rgba(76, 201, 240, 0.7);
}
/* Scroll Indicator */
.scroll-indicator {
    position: absolute;
    bottom: 20px;
    animation: bounce 1.3s infinite;
    font-size: 1.8rem;
    color: #4cc9f0;
}
@keyframes bounce {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-20px);
    }
}
/* Game Area Elements */
#game-area {
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom, #1d3557, #0f1429);
    position: relative;
    overflow: hidden;
}
.background-element {
    position: absolute;
    background: rgba(76, 201, 240, 0.1);
    border-radius: 8px;
    animation: backgroundMove linear infinite;
}
.background-element:nth-child(odd) {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 50%;
}
@keyframes backgroundMove {
    from {
        transform: translateX(0);
    }
    to {
        transform: translateX(-100%);
    }
}
.dash-line {
    position: absolute;
    height: 3px;
    width: 100%;
    background: repeating-linear-gradient(90deg, #4cc9f0, #4cc9f0 15px, transparent 15px, transparent 30px);
    bottom: 63px;
    z-index: 5;
}
.ground, .ceiling {
    position: absolute;
    width: 100%;
    height: 60px;
    background: linear-gradient(to top, #1d3557, #0f1429);
    z-index: 10;
}
.ground {
    bottom: 0;
    border-top: 4px solid #4cc9f0;
    box-shadow: 0 -8px 20px rgba(76, 201, 240, 0.6);
}
.ceiling {
    top: 0;
    border-bottom: 4px solid #4cc9f0;
    box-shadow: 0 8px 20px rgba(76, 201, 240, 0.6);
}
/* Player */
.player {
    position: absolute;
    width: 45px;
    height: 45px;
    background: linear-gradient(135deg, #4361ee, #3a0ca3);
    border-radius: 8px;
    bottom: 63px;
    left: 50px;
    z-index: 20;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: none; /* Removed smooth transition to rely solely on frame update */
    box-shadow: 0 0 25px rgba(67, 97, 238, 0.9);
    border: 2px solid #4cc9f0;
}
.player-icon {
    font-size: 1.6rem;
    color: #f1faee;
}
.player.ship-mode {
    background: linear-gradient(135deg, #ff9e00, #ff6a00);
    border-radius: 4px;
    box-shadow: 0 0 25px rgba(255, 158, 0, 0.9);
    transform: rotate(0deg) !important;
}
/* Obstacles */
.obstacle {
    position: absolute;
    width: 40px;
    background: linear-gradient(to bottom, #e94560, #b71540);
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(233, 69, 96, 0.9);
    z-index: 15;
    border: 1px solid rgba(255, 255, 255, 0.2);
}
.ceiling-obstacle {
    background: linear-gradient(to top, #e94560, #b71540);
}
.obstacle-top {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 15px;
    background: rgba(255, 255, 255, 0.2);
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
}
.ceiling-obstacle-top {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 15px;
    background: rgba(255, 255, 255, 0.2);
    border-bottom-left-radius: 8px;
    border-bottom-right-radius: 8px;
}
.triangle-obstacle {
    background: linear-gradient(to bottom, #e94560, #b71540);
    clip-path: polygon(0% 100%, 50% 0%, 100% 100%);
    border-radius: 0;
    box-shadow: 0 0 20px rgba(233, 69, 96, 0.9);
    transform-origin: bottom center;
    width: 50px;
    height: 50px;
}
.triangle-obstacle.inverted {
    clip-path: polygon(0% 0%, 50% 100%, 100% 0%);
    transform-origin: top center;
}
.air-pad {
    background: linear-gradient(45deg, #2ecc71, #27ae60);
    width: 60px;
    height: 20px;
    border-radius: 5px;
    box-shadow: 0 0 25px rgba(46, 204, 113, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    font-size: 1.2rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
}
.air-pad::before {
    content: '\f062';
    font-family: "Font Awesome 5 Free";
    font-weight: 900;
    color: white;
    animation: bounceUpDown 1s infinite;
}
.gravity-portal {
    width: 70px;
    height: 120px;
    background: linear-gradient(90deg, #8e44ad, #9b59b6);
    border-radius: 10px;
    box-shadow: 0 0 30px rgba(142, 68, 173, 0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 3rem;
    color: white;
    animation: portalGlow 1.5s infinite alternate;
    overflow: hidden;
    position: relative;
}
.gravity-portal::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.1);
    transform: scaleY(0);
    transition: transform 0.3s ease-out;
    border-radius: 10px;
}
.gravity-portal.used::before {
    transform: scaleY(1);
}
.gravity-portal i {
    margin-bottom: 5px;
}
.gravity-portal.inverted i {
    transform: rotate(180deg);
}
.speed-portal {
    width: 50px;
    height: 80px;
    background: linear-gradient(90deg, #f39c12, #e67e22);
    border-radius: 8px;
    box-shadow: 0 0 25px rgba(243, 156, 18, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2.5rem;
    color: white;
    animation: portalGlow 1.2s infinite alternate;
    overflow: hidden;
    position: relative;
}
.speed-portal::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.1);
    transform: scaleX(0);
    transition: transform 0.3s ease-out;
    border-radius: 8px;
}
.speed-portal.used::before {
    transform: scaleX(1);
}
.speed-portal i {
    animation: speedPulse 0.8s infinite;
}
@keyframes portalGlow {
    0% {
        box-shadow: 0 0 20px rgba(142, 68, 173, 0.7);
    }
    100% {
        box-shadow: 0 0 40px rgba(142, 68, 173, 1);
    }
}
@keyframes speedPulse {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.1);
        opacity: 0.8;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}
/* New Obstacle: Moving Obstacle */
.moving-obstacle {
    background: linear-gradient(to bottom, #c0392b, #a02d22);
    /*animation: moveUpDown 3s infinite alternate ease-in-out; */
    width: 40px;
    height: 80px;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(192, 57, 43, 0.9);
    z-index: 15;
    border: 1px solid rgba(255, 255, 255, 0.2);
}
/* Removed moveUpDown animation to use JS physics */
/* New Obstacle: Spike */
.spike-obstacle {
    background: linear-gradient(to bottom, #e74c3c, #c0392b);
    clip-path: polygon(0% 100%, 50% 0%, 100% 100%);
    width: 30px;
    height: 30px;
    border-radius: 0;
    box-shadow: 0 0 15px rgba(231, 76, 60, 0.9);
    z-index: 15;
}
/* New Obstacle: Inverted Spike */
.inverted-spike-obstacle {
    background: linear-gradient(to top, #e74c3c, #c0392b);
    clip-path: polygon(0% 0%, 50% 100%, 100% 0%);
    width: 30px;
    height: 30px;
    border-radius: 0;
    box-shadow: 0 0 15px rgba(231, 76, 60, 0.9);
    z-index: 15;
    position: absolute;
}
/* New Collectible: Coin */
.coin {
    position: absolute;
    width: 30px;
    height: 30px;
    background: linear-gradient(45deg, #f1c40f, #f39c12);
    border-radius: 50%;
    box-shadow: 0 0 15px rgba(241, 196, 15, 0.8);
    z-index: 18;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.2rem;
    color: white;
    animation: coinSpin 1s infinite linear;
}
@keyframes coinSpin {
    0% {
        transform: rotateY(0deg);
    }
    100% {
        transform: rotateY(360deg);
    }
}
/* Game Info & Progress */
.progress-container {
    position: absolute;
    top: 20px;
    left: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.4);
    height: 12px;
    border-radius: 10px;
    z-index: 50;
    border: 1px solid rgba(255, 255, 255, 0.1);
}
.progress-bar {
    height: 100%;
    background: linear-gradient(to right, #4cc9f0, #3a0ca3);
    border-radius: 10px;
    width: 0%;
    transition: width 0.5s ease;
    box-shadow: 0 0 15px rgba(76, 201, 240, 0.9);
}
.game-info {
    position: absolute;
    top: 40px;
    right: 20px;
    display: flex;
    gap: 20px;
    z-index: 50;
    flex-wrap: wrap;
    justify-content: center;
}
.info-item {
    background: rgba(0, 0, 0, 0.4);
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 1.1rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
}
.info-value {
    font-weight: 700;
    color: #4cc9f0;
}
/* Overlays & Effects */
.warning-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(233, 69, 96, 0.7);
    z-index: 90;
    display: none;
    justify-content: center;
    align-items: center;
    font-size: 6rem;
    color: white;
    animation: warningPulse 0.5s infinite alternate;
    text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
}
@keyframes warningPulse {
    0% {
        opacity: 0.6;
        transform: scale(1);
    }
    100% {
        opacity: 1;
        transform: scale(1.05);
    }
}
.success-effect {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 30;
    pointer-events: none;
}
.particle {
    position: absolute;
    border-radius: 50%;
    pointer-events: none;
    animation: fadeOutParticle 0.8s forwards;
    opacity: 0.9;
}
.success-particles {
    position: absolute;
    border-radius: 50%;
    animation: successParticle 1.2s forwards;
    opacity: 0.9;
    pointer-events: none;
}
@keyframes successParticle {
    0% {
        transform: translate(0, 0) scale(0.5);
        opacity: 1;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}
.pause-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 100;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    font-size: 3.5rem;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
}
/* Player Animations */
/* Removed time-based CSS animations for jump, slide, roll to use frame-based JS */
.jumping {
}
.sliding {
}
.rolling {
}
@keyframes fadeOutParticle {
    0% {
        opacity: 1;
        transform: scale(1);
    }
    100% {
        opacity: 0;
        transform: scale(0);
    }
}
.obstacle-passed {
    animation: obstaclePassed 0.5s forwards;
}
@keyframes obstaclePassed {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.1);
    }
    100% {
        transform: scale(1);
    }
}
.glow-effect {
    animation: glow 1.5s infinite alternate;
}
@keyframes glow {
    from {
        filter: drop-shadow(0 0 5px #4361ee);
    }
    to {
        filter: drop-shadow(0 0 20px #4cc9f0);
    }
}
.level-up {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 4.5rem;
    font-weight: bold;
    color: #4cc9f0;
    text-shadow: 0 0 25px rgba(76, 201, 240, 0.9);
    animation: levelUp 1.2s forwards;
    z-index: 70;
    display: none;
}
@keyframes levelUp {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
}
#game-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 3rem;
    color: white;
    background: rgba(0, 0, 0, 0.7);
    padding: 20px 40px;
    border-radius: 15px;
    z-index: 110;
    display: none;
    opacity: 0;
    animation: fadeInOutMessage 2s forwards;
    text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
}
@keyframes fadeInOutMessage {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
    20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    80% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
}
/* Flying platform styles */
.flying-platform {
    position: absolute;
    background: linear-gradient(135deg, #4361ee, #3a0ca3);
    border-radius: 8px;
    box-shadow: 0 0 25px rgba(67, 97, 238, 0.8);
    z-index: 15;
    border: 2px solid rgba(76, 201, 240, 0.5);
    transition: transform 0.1s ease-out;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}
.flying-platform::before {
    content: '';
    position: absolute;
    top: -5px;
    left: 0;
    width: 100%;
    height: 10px;
    background: rgba(76, 201, 240, 0.5);
    border-radius: 8px 8px 0 0;
}
.flying-platform.purple {
    background: linear-gradient(135deg, #7209b7, #560bad);
    box-shadow: 0 0 25px rgba(114, 9, 183, 0.8);
}
.flying-platform.green {
    background: linear-gradient(135deg, #2ecc71, #27ae60);
    box-shadow: 0 0 25px rgba(46, 204, 113, 0.8);
}
.flying-platform.glow {
    animation: flyingGlow 1.5s infinite alternate;
}
@keyframes flyingGlow {
    0% {
        box-shadow: 0 0 15px rgba(67, 97, 238, 0.8);
    }
    100% {
        box-shadow: 0 0 30px rgba(67, 97, 238, 1);
    }
}
.platform-effect {
    position: absolute;
    width: 80%;
    height: 5px;
    background: rgba(76, 201, 240, 0.5);
    border-radius: 50%;
    filter: blur(5px);
    bottom: 0;
    animation: platformEffect 0.8s infinite alternate;
}
@keyframes platformEffect {
    0% {
        opacity: 0.3;
        transform: scale(0.9);
    }
    100% {
        opacity: 0.7;
        transform: scale(1.1);
    }
}
.flying-platform.disappearing {
    transition: opacity 0.3s ease-out, transform 0.3s ease-out;
}
.flying-platform.disappearing.fading {
    opacity: 0;
    transform: scale(0.5);
}
/* Challenge indicators */
.challenge-indicator {
    position: absolute;
    font-size: 1.8rem;
    color: #ff9e00;
    z-index: 25;
    text-shadow: 0 0 10px rgba(255, 158, 0, 0.8);
    animation: bounce 1s infinite;
}
/* Responsive Question Styles */
.question-modal h2 {
    font-size: clamp(1.2rem, 4.5vw, 2.2rem);
    margin-bottom: 15px;
    color: #f1faee;
    text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    direction: ltr;
    text-align: initial;
    width: 95%;
    max-width: 650px;
    unicode-bidi: embed;
    word-break: break-word;
    overflow-wrap: break-word;
    line-height: 1.4;
}
.question-modal input[type="text"] {
    padding: 12px 20px;
    font-size: 1.3rem;
    border-radius: 10px;
    border: 2px solid #4cc9f0;
    background-color: rgba(255, 255, 255, 0.1);
    color: #fff;
    width: 85%;
    max-width: 350px;
    text-align: center;
    margin-bottom: 20px;
    outline: none;
    transition: border-color 0.3s ease, background-color 0.3s ease;
    direction: ltr;
}
.question-modal input[type="text"]:focus {
    border-color: #7209b7;
    background-color: rgba(255, 255, 255, 0.2);
}
.question-modal .feedback-message {
    font-size: clamp(1.1rem, 4vw, 1.4rem);
    margin-top: 15px;
    font-weight: bold;
}
.feedback-message.correct {
    color: #2ecc71;
    text-shadow: 0 0 10px rgba(46, 204, 113, 0.8);
}
.feedback-message.incorrect {
    color: #e74c3c;
    text-shadow: 0 0 10px rgba(231, 76, 60, 0.8);
}
/* Multiple Choice Options */
.options-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
    width: 90%;
    max-width: 500px;
    margin-bottom: 20px;
}
.option-btn {
    background: rgba(76, 201, 240, 0.2);
    color: white;
    border: 2px solid #4cc9f0;
    padding: 12px 20px;
    font-size: clamp(1.0rem, 3.5vw, 1.2rem);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: initial;
    direction: ltr;
    unicode-bidi: embed;
    word-break: break-word;
    overflow-wrap: break-word;
}
.option-btn:hover {
    background: rgba(76, 201, 240, 0.4);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(76, 201, 240, 0.5);
}
.option-btn.selected {
    background: linear-gradient(45deg, #4361ee, #3a0ca3);
    border-color: #7209b7;
    box-shadow: 0 0 20px rgba(67, 97, 238, 0.8);
}
/* Mobile optimization for question modal */
@media (max-height: 600px) {
    .question-modal {
        padding: 10px;
    }
    .question-modal h2 {
        font-size: clamp(1.1rem, 4vw, 1.8rem);
        margin-bottom: 10px;
    }
    .option-btn {
        padding: 10px 15px;
        font-size: 1.0rem;
    }
}
/* Mobile controls */
.mobile-controls {
    position: absolute;
    bottom: 20px;
    width: 100%;
    display: flex;
    justify-content: space-around;
    padding: 0 20px;
    z-index: 50;
    display: none;
}
.mobile-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    background: rgba(76, 201, 240, 0.3);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2rem;
    color: white;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
    border: 2px solid rgba(255, 255, 255, 0.2);
    user-select: none;
    touch-action: manipulation;
}
/* Mobile-specific adjustments */
@media (max-width: 768px) {
    .game-container {
        max-height: 90vh;
        border-radius: 10px;
    }
    .logo {
        font-size: 3.5rem;
    }
    .subtitle {
        font-size: 1.4rem;
        margin-bottom: 20px;
    }
    .character {
        width: 70px;
        height: 70px;
    }
    .character i {
        font-size: 2.5rem;
    }
    .btn {
        padding: 14px 30px;
        font-size: 1.2rem;
    }
    .controls-info {
        gap: 8px;
    }
    .control-item {
        padding: 10px 15px;
        font-size: 0.9rem;
    }
    .stats {
        gap: 15px;
        padding: 10px 20px;
    }
    .stat-value {
        font-size: 1.8rem;
    }
    .mobile-controls {
        display: flex;
    }
    #game-message {
        font-size: 2rem;
        padding: 15px 30px;
    }
}
@media (max-width: 480px) {
    .logo {
        font-size: 2.8rem;
    }
    .subtitle {
        font-size: 1.2rem;
    }
    .character {
        width: 60px;
        height: 60px;
    }
    .character i {
        font-size: 2rem;
    }
    .btn {
        padding: 12px 25px;
        font-size: 1.1rem;
    }
    .mobile-btn {
        width: 60px;
        height: 60px;
        font-size: 1.8rem;
    }
    .stats {
        gap: 10px;
        padding: 8px 15px;
    }
    .stat-value {
        font-size: 1.6rem;
    }
    .info-item {
        font-size: 0.9rem;
        padding: 6px 12px;
    }
}
</style>
</head>
<body>
<div class="game-container">
<div id="start-screen" class="start-screen">
<h1 class="logo">ŸÖŸÜÿµÿßÿ™ ÿ∑ÿßÿ¶ÿ±ÿ©</h1>
<p class="subtitle">ÿßŸÇŸÅÿ≤ ÿπŸÑŸâ ÿßŸÑŸÖŸÜÿµÿßÿ™ Ÿàÿ™ÿ¨ŸÜÿ® ÿßŸÑÿπŸÇÿ®ÿßÿ™ ÿßŸÑŸÖÿ´ŸÑÿ´ÿ©!</p>
<div class="characters">
<div class="character active" data-character="1">
<i class="fas fa-cube"></i>
<span>ŸÖŸÉÿπÿ®</span>
</div>
<div class="character" data-character="2">
<i class="fas fa-ship"></i>
<span>ÿ≥ŸÅŸäŸÜÿ©</span>
</div>
<div class="character" data-character="3">
<i class="fas fa-robot"></i>
<span>ÿ±Ÿàÿ®Ÿàÿ™</span>
</div>
</div>
<button id="start-btn" class="btn glow-effect">
<i class="fas fa-play"></i> ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ©
</button>
<div class="controls-info">
<div class="control-item">
<i class="fas fa-arrow-up"></i> ŸÇŸÅÿ≤ / ŸÖÿ≥ÿßŸÅÿ© / ŸÜŸÇÿ±ÿ©
</div>
<div class="control-item">
<i class="fas fa-arrow-down"></i> ÿßŸÜÿ≤ŸÑÿßŸÇ
</div>
<div class="control-item">
<i class="fas fa-pause"></i> ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™ (P)
</div>
<div class="control-item">
<i class="fas fa-redo"></i> ÿ•ÿπÿßÿØÿ© ÿ™ÿ¥ÿ∫ŸäŸÑ (R)
</div>
<div class="control-item">
<i class="fas fa-star"></i> ŸÖŸÜÿµÿßÿ™ ÿ∑ÿßÿ¶ÿ±ÿ© (ŸÇŸÅÿ≤ ÿπŸÑŸäŸáÿß)
</div>
</div>
<div class="stats">
<div class="stat">
<span>ÿ£ÿπŸÑŸâ ŸÜÿ™Ÿäÿ¨ÿ©</span>
<span id="high-score" class="stat-value">0</span>
</div>
<div class="stat">
<span>ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ</span>
<span id="level" class="stat-value">1</span>
</div>
</div>
<div class="scroll-indicator">
<i class="fas fa-chevron-down"></i>
</div>
</div>
<div class="progress-container" id="progress-container">
<div id="progress-bar" class="progress-bar"></div>
</div>
<div class="game-info" id="game-info">
<div class="info-item"> ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©: <span id="score" class="info-value">0</span>
</div>
<div class="info-item"> ÿßŸÑŸàÿ∂ÿπ: <span id="player-mode-display" class="info-value">ŸÖŸÉÿπÿ®</span>
</div>
<div class="info-item"> ÿßŸÑÿ≥ÿ±ÿπÿ©: <span id="speed-display" class="info-value">x1</span>
</div>
<div class="info-item"> ÿßŸÑŸÖŸÜÿµÿßÿ™: <span id="platforms-passed" class="info-value">0</span>
</div>
<div class="info-item"> ÿßŸÑŸÜŸÇŸàÿØ: <span id="coins-collected" class="info-value">0</span>
</div>
</div>
<div id="warning-overlay" class="warning-overlay">
<i class="fas fa-exclamation-triangle"></i>
</div>
<div id="success-effect" class="success-effect"></div>
<div id="level-up" class="level-up">ŸÖÿ≥ÿ™ŸàŸâ ÿ¨ÿØŸäÿØ!</div>
<div id="game-message" style="display: none;"></div>
<div id="game-area">
</div>
<div id="end-screen" class="end-screen">
<h1 class="logo">ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©</h1>
<p class="subtitle">ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ!</p>
<div class="stats">
<div class="stat">
<span>ŸÜÿ™Ÿäÿ¨ÿ™ŸÉ</span>
<span id="final-score" class="stat-value">0</span>
</div>
<div class="stat">
<span>ÿ£ÿπŸÑŸâ ŸÜÿ™Ÿäÿ¨ÿ©</span>
<span id="final-high-score" class="stat-value">0</span>
</div>
<div class="stat">
<span>ÿßŸÑŸÖŸÜÿµÿßÿ™</span>
<span id="final-platforms" class="stat-value">0</span>
</div>
<div class="stat">
<span>ÿßŸÑŸÜŸÇŸàÿØ</span>
<span id="final-coins" class="stat-value">0</span>
</div>
</div>
<button id="restart-btn" class="btn glow-effect">
<i class="fas fa-redo"></i> ÿ•ÿπÿßÿØÿ© ÿ™ÿ¥ÿ∫ŸäŸÑ
</button>
</div>
<button id="music-toggle-btn" class="music-toggle-btn">
<i class="fas fa-volume-up"></i>
</button>
<div class="mobile-controls">
<div class="mobile-btn" id="jump-btn">
<i class="fas fa-arrow-up"></i>
</div>
<div class="mobile-btn" id="slide-btn">
<i class="fas fa-arrow-down"></i>
</div>
</div>
<div id="question-modal" class="question-modal">
<h2 id="question-text"></h2>
<div id="options-container" class="options-container"></div>
<button id="submit-answer-btn" class="btn">
<i class="fas fa-check"></i> ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©
</button>
<p id="feedback-message" class="feedback-message"></p>
</div>
</div>
<script>
// MathJax configuration to enable inline math with $ delimiters
window.MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
    svg: {
        fontCache: 'global'
    }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
<script>
// ** MUSIC SCRIPT - START **
// Global variables for the music player
let isMusicPlaying = false;
let nextNoteTime = 0.0;
let scheduleInterval = null;
const tempo = 240;
const waveType = 'triangle';
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const cMajorScale = [
    261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25
];
const cMajorChord = [cMajorScale[0], cMajorScale[2], cMajorScale[4]];
const gMajorChord = [cMajorScale[4], cMajorScale[6], cMajorScale[1] * 2];
const aMinorChord = [cMajorScale[5], cMajorScale[0] * 2, cMajorScale[2] * 2];
const fMajorChord = [cMajorScale[3], cMajorScale[5], cMajorScale[0] * 2];
const chordProgression = [
    cMajorChord,
    gMajorChord,
    aMinorChord,
    fMajorChord
];
const melodyPattern = [
    { noteIndex: 0, duration: 0.25 },
    { noteIndex: 1, duration: 0.25 },
    { noteIndex: 2, duration: 0.5 },
    { noteIndex: -1, duration: 0.5 },
    { noteIndex: 3, duration: 0.5 },
    { noteIndex: 2, duration: 0.5 },
    { noteIndex: 1, duration: 1 }
];

function playKickDrum(startTime) {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(120, startTime);
    oscillator.frequency.exponentialRampToValueAtTime(0.01, startTime + 0.05);
    gainNode.gain.setValueAtTime(0.6, startTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.start(startTime);
    oscillator.stop(startTime + 0.1);
}

function playSnare(startTime) {
    const snareGain = audioContext.createGain();
    snareGain.connect(audioContext.destination);
    snareGain.gain.setValueAtTime(0.5, startTime);
    snareGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.1);

    const bodyOsc = audioContext.createOscillator();
    bodyOsc.type = 'sine';
    bodyOsc.frequency.setValueAtTime(200, startTime);
    bodyOsc.connect(snareGain);
    bodyOsc.start(startTime);
    bodyOsc.stop(startTime + 0.1);

    const noise = audioContext.createBufferSource();
    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
    const output = noiseBuffer.getChannelData(0);
    for (let i = 0; i < output.length; i++) {
        output[i] = Math.random() * 2 - 1;
    }
    noise.buffer = noiseBuffer;
    const noiseGain = audioContext.createGain();
    noiseGain.gain.setValueAtTime(1, startTime);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.1);
    noise.connect(noiseGain);
    noiseGain.connect(snareGain);
    noise.start(startTime);
}

function playHiHat(startTime) {
    const noise = audioContext.createBufferSource();
    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
    const output = noiseBuffer.getChannelData(0);
    for (let i = 0; i < output.length; i++) {
        output[i] = Math.random() * 2 - 1;
    }
    noise.buffer = noiseBuffer;
    const noiseGain = audioContext.createGain();
    noiseGain.gain.setValueAtTime(0.2, startTime);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
    noise.connect(noiseGain);
    noiseGain.connect(audioContext.destination);
    noise.start(startTime);
    noise.stop(startTime + 0.1);
}

function playNoteWithADSR(frequency, type, startTime, noteDuration, volume) {
    if (!frequency || volume === 0) return;
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.type = type;
    oscillator.frequency.value = frequency;
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    const attackTime = 0.01;
    const decayTime = 0.1;
    const sustainLevel = 0.5;
    const releaseTime = 0.2;

    gainNode.gain.setValueAtTime(0, startTime);
    gainNode.gain.linearRampToValueAtTime(volume, startTime + attackTime);
    gainNode.gain.linearRampToValueAtTime(volume * sustainLevel, startTime + attackTime + decayTime);

    oscillator.start(startTime);
    oscillator.stop(startTime + noteDuration + releaseTime);

    gainNode.gain.setValueAtTime(volume * sustainLevel, startTime + noteDuration);
    gainNode.gain.linearRampToValueAtTime(0, startTime + noteDuration + releaseTime);
}

function playBassNote(frequency, startTime, noteDuration, volume) {
    if (!frequency || volume === 0) return;
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.type = 'sine';
    oscillator.frequency.value = frequency;
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    const attackTime = 0.01;
    const decayTime = 0.15;
    const sustainLevel = 0.4;
    const releaseTime = 0.3;

    gainNode.gain.setValueAtTime(0, startTime);
    gainNode.gain.linearRampToValueAtTime(volume, startTime + attackTime);
    gainNode.gain.linearRampToValueAtTime(0, startTime + noteDuration + releaseTime);

    oscillator.start(startTime);
    oscillator.stop(startTime + noteDuration + releaseTime);
    
    gainNode.gain.setValueAtTime(volume * sustainLevel, startTime + noteDuration);
    gainNode.gain.linearRampToValueAtTime(0, startTime + noteDuration + releaseTime);
}

let beatCounter = 0;
let chordIndex = 0;
let melodyPatternIndex = 0;

function scheduler() {
    if (!isMusicPlaying) return;

    const secondsPerBeat = 60.0 / tempo;

    while (nextNoteTime < audioContext.currentTime + 0.1) {
        const currentChord = chordProgression[chordIndex];
        const rootNote = currentChord[0];

        if (beatCounter % 4 === 0) {
            playKickDrum(nextNoteTime);
        }

        if (beatCounter % 4 === 1 || beatCounter % 4 === 3) {
            playSnare(nextNoteTime);
        }

        if (beatCounter % 2 === 0) {
            playHiHat(nextNoteTime);
        }

        if (beatCounter % 4 === 0) {
            playBassNote(rootNote / 2, nextNoteTime, secondsPerBeat * 1.5, 0.4);
        }

        const melodyNote = melodyPattern[melodyPatternIndex];
        if (melodyNote.noteIndex !== -1) {
            const melodyFrequency = currentChord[melodyNote.noteIndex];
            playNoteWithADSR(melodyFrequency * 2, 'sine', nextNoteTime, secondsPerBeat * melodyNote.duration, 0.35);
        }
        
        melodyPatternIndex = (melodyPatternIndex + 1) % melodyPattern.length;
        nextNoteTime += secondsPerBeat;
        beatCounter = (beatCounter + 1) % 16;

        if (beatCounter % 4 === 0) {
            chordIndex = (chordIndex + 1) % chordProgression.length;
        }
    }
}

function startMusic() {
    if (isMusicPlaying) return;
    isMusicPlaying = true;
    if (audioContext.state === 'suspended') {
        audioContext.resume();
    }
    nextNoteTime = audioContext.currentTime;
    beatCounter = 0;
    chordIndex = 0;
    melodyPatternIndex = 0;
    scheduleInterval = setInterval(scheduler, 25);
}

function stopMusic() {
    if (!isMusicPlaying) return;
    isMusicPlaying = false;
    clearInterval(scheduleInterval);
    scheduleInterval = null;
}
// ** MUSIC SCRIPT - END **

document.addEventListener('DOMContentLoaded', () => {
    // DOM Elements
    const gameArea = document.getElementById('game-area');
    const startScreen = document.getElementById('start-screen');
    const endScreen = document.getElementById('end-screen');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    let scoreElement = document.getElementById('score');
    const highScoreElement = document.getElementById('high-score');
    let levelElement = document.getElementById('level');
    let finalScoreElement = document.getElementById('final-score');
    let finalHighScoreElement = document.getElementById('final-high-score');
    let progressBar = document.getElementById('progress-bar');
    let playerModeDisplay = document.getElementById('player-mode-display');
    let speedDisplay = document.getElementById('speed-display');
    let warningOverlay = document.getElementById('warning-overlay');
    let successEffect = document.getElementById('success-effect');
    const characterElements = document.querySelectorAll('.character');
    let levelUpElement = document.getElementById('level-up');
    const musicToggleButton = document.getElementById('music-toggle-btn');
    let gameMessageElement = document.getElementById('game-message');
    let platformsPassedElement = document.getElementById('platforms-passed');
    let finalPlatformsElement = document.getElementById('final-platforms');
    let coinsCollectedElement = document.getElementById('coins-collected');
    let finalCoinsElement = document.getElementById('final-coins');
    const jumpBtn = document.getElementById('jump-btn');
    const slideBtn = document.getElementById('slide-btn');
    const questionModal = document.getElementById('question-modal');
    const questionTextElement = document.getElementById('question-text');
    const optionsContainer = document.getElementById('options-container');
    const submitAnswerBtn = document.getElementById('submit-answer-btn');
    const feedbackMessageElement = document.getElementById('feedback-message');

    // Game State Variables
    let gameRunning = false;
    let gamePaused = false;
    let score = 0;
    let level = 1;
    let platformsPassed = 0;
    let coinsCollected = 0;
    let highScore = localStorage.getItem('gdHighScore') || 0;
    let player;
    let obstacles = [];
    let flyingPlatforms = [];
    let coins = [];
    
    // Delta Time Variables
    let lastTime = 0;
    let animationFrameId = null;

    // Physics and Game Mechanics
    const BASE_SPEED = 250; // pixels per second (px/s) - Base speed for all movement
    let obstacleSpeed = BASE_SPEED;
    let currentSpeedMultiplier = 1.0;
    const BASE_JUMP_FORCE = 1050; // pixels per second (px/s) - üöÄ ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ŸáŸÜÿß üöÄ
    const BASE_GRAVITY = 3500; // pixels per second squared (px/s^2)
    let obstacleGenerationTime = 2.0; // Seconds between obstacles
    let timeSinceLastObstacle = 0; // Time counter for obstacle generation
    let backgroundElements = [];
    let playerMode = 'cube';
    let gravityDirection = 1;
    let isJumping = false;
    let canJump = true;
    let lastObstaclePassed = 0;
    let currentPlatform = null;
    let playerY = 0;
    let playerVelocity = 0;
    const groundLevel = 63;
    const playerHeight = 45;
    let rotationAngle = 0;
    let rotationSpeed = -500; // degrees per second
    let isRolling = true;
    let soundEnabled = true;
    let currentCorrectOptionIndex = -1;
    let currentSelectedOptionIndex = -1;
    let currentQuestion = null;
    let collidedObstacleRef = null;
    let isSliding = false;

    const questions = [
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $3.5x + 1.5x = ?$', options: ['$4x$', '$5.5x$', '$5x$', '$2x$'], correctOptionIndex: 2 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $7y + 4y = ?$', options: ['$3y$', '$28y$', '$74y$', '$11y$'], correctOptionIndex: 3 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $c^3r - 6c^3r = ?$', options: ['$-5c^3r$', '$5c^3r$', '$-6c^3r$', '$-7c^3r$'], correctOptionIndex: 0 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $bd - 4bd = ?$', options: ['$-3bd$', '$3bd$', '$-4bd$', '$-5bd$'], correctOptionIndex: 0 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $(3np + 5w) + (w - 10np) = ?$', options: ['$-7np + 4w$', '$13np + 6w$', '$-7np + 6w$', '$13np + 4w$'], correctOptionIndex: 2 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $(-z + 2xy) + (xy + 4z) = ?$', options: ['$3xy - 3z$', '$xy + 5z$', '$xy + 3z$', '$3xy + 3z$'], correctOptionIndex: 3 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $(14x^2 - 19x) + (-6x^2 + x) = ?$', options: ['$8x^2 - 18x$', '$8x^2 - 20x$', '$20x^2 - 18x$', '$20x^2 - 20x$'], correctOptionIndex: 0 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $(10b^2 - 3b) + (b^2 - 2b) = ?$', options: ['$11b^2 - 5b$', '$11b^2 - b$', '$9b^2 - 5b$', '$9b^2 - b$'], correctOptionIndex: 0 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $(1.5w - 6.5) - (0.5w + 3.5) = ?$', options: ['$w - 3$', '$2w - 10$', '$w - 10$', '$2w - 3$'], correctOptionIndex: 2 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $(x + \\frac{4}{7}) - (4x - \\frac{3}{7}) = ?$', options: ['$-3x + \\frac{1}{7}$', '$5x + 1$', '$5x + \\frac{1}{7}$', '$-3x + 1$'], correctOptionIndex: 3 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $8d + 4c^2 - 3(d - 5c^2) = ?$', options: ['$5d + 19c^2$', '$5d - 11c^2$', '$11d + 19c^2$', '$11d - 11c^2$'], correctOptionIndex: 0 },
        { type: 'multiple-choice', question: 'ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿØŸàÿØ ÿßŸÑÿ¨ÿ®ÿ±Ÿäÿ©: $6w - 3n^2m - 2(w + n^2m) = ?$', options: ['$4w - 5n^2m$', '$4w - n^2m$', '$8w - 5n^2m$', '$8w - n^2m$'], correctOptionIndex: 0 },
        { type: 'multiple-choice', question: 'ŸÖÿß ŸÜÿßÿ™ÿ¨ ÿ¨ŸÖÿπ $2x + 3$ ŸÖÿπ $4x - 1$ÿü', options: ['$6x + 4$', '$2x + 2$', '$6x + 2$', '$2x + 4$'], correctOptionIndex: 2 },
        { type: 'multiple-choice', question: 'ŸÖÿß ŸÜÿßÿ™ÿ¨ ÿ∑ÿ±ÿ≠ $5y - 2$ ŸÖŸÜ $8y + 3$ÿü', options: ['$3y + 5$', '$13y + 1$', '$13y + 5$', '$3y + 1$'], correctOptionIndex: 3 },
        { type: 'multiple-choice', question: 'ÿ™ÿ®ÿ≥Ÿäÿ∑ ÿßŸÑŸÖŸÇÿØÿßÿ± ÿßŸÑÿ¨ÿ®ÿ±Ÿä: $7a - (2a + 4)$ ŸáŸà:', options: ['$5a + 4$', '$5a - 4$', '$9a + 4$', '$9a - 4$'], correctOptionIndex: 1 },
        { type: 'multiple-choice', question: 'ŸÖÿß ŸáŸà ÿßŸÑŸÖŸÇÿØÿßÿ± ÿßŸÑÿ¨ÿ®ÿ±Ÿä ÿßŸÑŸÖŸÉÿßŸÅÿ¶ ŸÑŸÄ $3(x + 2) - x$ÿü', options: ['$2x + 2$', '$2x + 6$', '$4x + 2$', '$4x + 6$'], correctOptionIndex: 1 },
        { type: 'multiple-choice', question: 'ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÑÿØŸäŸÉ $10$ ÿ£ŸÇŸÑÿßŸÖ Ÿà ÿ£ÿπÿ∑Ÿäÿ™ ÿµÿØŸäŸÇŸÉ $3$ ÿ£ŸÇŸÑÿßŸÖÿå ÿ´ŸÖ ÿ£ÿπÿ∑ÿßŸÉ ÿµÿØŸäŸÇ ÿ¢ÿÆÿ± $x$ ŸÖŸÜ ÿßŸÑÿ£ŸÇŸÑÿßŸÖ. ŸÉŸÖ ŸÇŸÑŸÖŸãÿß ŸÑÿØŸäŸÉ ÿßŸÑÿ¢ŸÜÿü', options: ['$7 + x$', '$13 + x$', '$7 - x$', '$13 - x$'], correctOptionIndex: 0 }
    ];

    function playSound(frequency, type = 'sine', duration = 0.1, volume = 0.3) {
        if (!soundEnabled) return;
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = type;
            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;

            oscillator.start();
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
            oscillator.stop(audioContext.currentTime + duration);
        } catch (e) {
            console.log("Audio context not supported");
        }
    }

    function createBackgroundElements() {
        backgroundElements.forEach(el => el.remove());
        backgroundElements = [];
        const numElements = 30;
        for (let i = 0; i < numElements; i++) {
            const element = document.createElement('div');
            element.classList.add('background-element');
            const size = Math.random() * 40 + 10;
            const left = Math.random() * gameArea.offsetWidth * 2;
            const top = Math.random() * (gameArea.offsetHeight - 100) + 50;
            element.style.width = `${size}px`;
            element.style.height = `${size}px`;
            element.style.left = `${left}px`;
            element.style.top = `${top}px`;
            element.style.opacity = Math.random() * 0.2 + 0.05;
            const parallaxSpeed = Math.random() * 0.5 + 0.1;
            element.dataset.parallaxSpeed = parallaxSpeed;
            gameArea.appendChild(element);
            backgroundElements.push(element);
        }
    }

    function createPlayer() {
        if (player) player.remove();
        player = document.createElement('div');
        player.id = 'player';
        player.classList.add('player');
        const icon = document.createElement('i');
        icon.classList.add('player-icon');

        player.classList.remove('rolling', 'ship-mode');
        
        if (selectedCharacter === 1) {
            icon.classList.add('fas', 'fa-cube');
            playerMode = 'cube';
        } else if (selectedCharacter === 2) {
            icon.classList.add('fas', 'fa-ship');
            playerMode = 'ship';
            player.classList.add('ship-mode');
        } else {
            icon.classList.add('fas', 'fa-robot');
            playerMode = 'cube';
        }

        player.appendChild(icon);
        gameArea.appendChild(player);

        player.style.bottom = `${groundLevel}px`;
        playerY = 0;
        playerVelocity = 0;
        gravityDirection = 1;
        updatePlayerDisplay();
    }

    function showGameMessage(message, duration = 1500) {
        gameMessageElement.textContent = message;
        gameMessageElement.style.display = 'block';
        gameMessageElement.style.opacity = 0;
        void gameMessageElement.offsetWidth;
        gameMessageElement.style.animation = `fadeInOutMessage ${duration / 1000}s forwards`;

        setTimeout(() => {
            gameMessageElement.style.display = 'none';
        }, duration);
    }

    function createObstacle() {
        if (!gameRunning || gamePaused) return;

        const obstacleTypeRandom = Math.random();
        
        if (obstacleTypeRandom < 0.4) {
            createFlyingPlatform();
            return;
        }

        if (Math.random() < 0.25) {
            createCoin();
        }

        const obstacle = document.createElement('div');
        obstacle.classList.add('obstacle');
        let type = Math.random();

        if (level === 1) {
            if (type < 0.6) {
                const height = Math.random() * 70 + 60;
                obstacle.style.height = `${height}px`;
                obstacle.style.bottom = `${groundLevel}px`;
            } else if (type < 0.9) {
                obstacle.classList.add('triangle-obstacle');
                obstacle.style.bottom = `${groundLevel}px`;
            } else {
                obstacle.classList.add('air-pad');
                obstacle.style.bottom = `${groundLevel}px`;
            }
        } else if (level === 2) {
            if (type < 0.4) {
                const height = Math.random() * 70 + 60;
                obstacle.style.height = `${height}px`;
                obstacle.style.bottom = `${groundLevel}px`;
            } else if (type < 0.6) {
                obstacle.classList.add('triangle-obstacle');
                obstacle.style.bottom = `${groundLevel}px`;
            } else if (type < 0.75) {
                obstacle.classList.add('air-pad');
                obstacle.style.bottom = `${groundLevel}px`;
            } else if (type < 0.9) {
                obstacle.classList.add('speed-portal');
                obstacle.style.bottom = `${groundLevel}px`;
                const icon = document.createElement('i');
                icon.classList.add('fas', 'fa-forward');
                obstacle.appendChild(icon);
            } else {
                const height = Math.random() * 45 + 40;
                obstacle.classList.add('ceiling-obstacle');
                obstacle.style.height = `${height}px`;
                obstacle.style.top = '60px';
            }
        } else if (level === 3) {
            if (type < 0.3) {
                const height = Math.random() * 70 + 60;
                obstacle.style.height = `${height}px`;
                obstacle.style.bottom = `${groundLevel}px`;
            } else if (type < 0.5) {
                obstacle.classList.add('triangle-obstacle');
                if (Math.random() < 0.5) {
                    obstacle.classList.add('inverted');
                    obstacle.style.top = '60px';
                } else {
                    obstacle.style.bottom = `${groundLevel}px`;
                }
            } else if (type < 0.65) {
                obstacle.classList.add('air-pad');
                obstacle.style.bottom = `${groundLevel}px`;
            } else if (type < 0.8) {
                obstacle.classList.add('gravity-portal');
                obstacle.style.bottom = `${groundLevel}px`;
                const icon = document.createElement('i');
                icon.classList.add('fas', 'fa-arrows-alt-v');
                obstacle.appendChild(icon);
                if (gravityDirection === -1) {
                    icon.classList.add('inverted');
                }
            } else {
                obstacle.classList.add('moving-obstacle');
                obstacle.style.bottom = `${groundLevel}px`;
                const initialY = Math.random() * (gameArea.offsetHeight - 200) + groundLevel + 20;
                obstacle.dataset.initialY = initialY;
                obstacle.dataset.moveRange = Math.random() * 50 + 30;
                obstacle.dataset.moveSpeed = Math.random() * 2 + 1; // adjusted for seconds
                obstacle.dataset.moveOffset = Math.random() * Math.PI * 2;
            }
        } else if (level === 4) {
            if (type < 0.25) {
                const height = Math.random() * 70 + 60;
                obstacle.style.height = `${height}px`;
                obstacle.style.bottom = `${groundLevel}px`;
            } else if (type < 0.4) {
                obstacle.classList.add('triangle-obstacle');
                obstacle.classList.add('inverted');
                obstacle.style.top = '60px';
            } else if (type < 0.5) {
                obstacle.classList.add('spike-obstacle');
                obstacle.style.bottom = `${groundLevel}px`;
            } else if (type < 0.65) {
                obstacle.classList.add('gravity-portal');
                obstacle.style.bottom = `${groundLevel}px`;
                const icon = document.createElement('i');
                icon.classList.add('fas', 'fa-arrows-alt-v');
                obstacle.appendChild(icon);
                if (gravityDirection === -1) {
                    icon.classList.add('inverted');
                }
            } else if (type < 0.8) {
                obstacle.classList.add('speed-portal');
                obstacle.style.bottom = `${groundLevel}px`;
                const icon = document.createElement('i');
                icon.classList.add('fas', 'fa-forward');
                obstacle.appendChild(icon);
            } else {
                obstacle.classList.add('moving-obstacle');
                obstacle.style.bottom = `${groundLevel}px`;
                const initialY = Math.random() * (gameArea.offsetHeight - 200) + groundLevel + 20;
                obstacle.dataset.initialY = initialY;
                obstacle.dataset.moveRange = Math.random() * 50 + 30;
                obstacle.dataset.moveSpeed = Math.random() * 2 + 1;
                obstacle.dataset.moveOffset = Math.random() * Math.PI * 2;
            }
        } else {
            if (type < 0.2) {
                obstacle.classList.add('spike-obstacle');
                obstacle.style.bottom = `${groundLevel}px`;
            } else if (type < 0.35) {
                obstacle.classList.add('triangle-obstacle');
                obstacle.classList.add('inverted');
                obstacle.style.top = '60px';
            } else if (type < 0.5) {
                obstacle.classList.add('moving-obstacle');
                obstacle.style.bottom = `${groundLevel}px`;
                const initialY = Math.random() * (gameArea.offsetHeight - 200) + groundLevel + 20;
                obstacle.dataset.initialY = initialY;
                obstacle.dataset.moveRange = Math.random() * 60 + 40;
                obstacle.dataset.moveSpeed = Math.random() * 2.5 + 1.5;
                obstacle.dataset.moveOffset = Math.random() * Math.PI * 2;
            } else if (type < 0.7) {
                obstacle.classList.add('gravity-portal');
                obstacle.style.bottom = `${groundLevel}px`;
                const icon = document.createElement('i');
                icon.classList.add('fas', 'fa-arrows-alt-v');
                obstacle.appendChild(icon);
                if (gravityDirection === -1) {
                    icon.classList.add('inverted');
                }
            } else {
                obstacle.classList.add('speed-portal');
                obstacle.style.bottom = `${groundLevel}px`;
                const icon = document.createElement('i');
                icon.classList.add('fas', 'fa-forward');
                obstacle.appendChild(icon);
            }
        }

        obstacle.style.right = '-70px';
        gameArea.appendChild(obstacle);
        
        obstacles.push({
            element: obstacle,
            passed: false,
            used: false,
            isMoving: obstacle.classList.contains('moving-obstacle'),
            initialY: parseFloat(obstacle.dataset.initialY || 0),
            moveRange: parseFloat(obstacle.dataset.moveRange || 0),
            moveSpeed: parseFloat(obstacle.dataset.moveSpeed || 0),
            moveOffset: parseFloat(obstacle.dataset.moveOffset || 0)
        });
    }

    function createFlyingPlatform() {
        const platformWidth = Math.random() * 120 + 80;
        const platformHeight = 20;
        let platformY;
        const platformRight = -70;

        const platformMinY = groundLevel + 20;
        const platformMaxY = gameArea.offsetHeight - groundLevel - platformHeight - 20;
        platformY = Math.random() * (platformMaxY - platformMinY) + platformMinY;

        const platform = document.createElement('div');
        platform.classList.add('flying-platform');
        platform.classList.add('glow');

        const effect = document.createElement('div');
        effect.classList.add('platform-effect');
        platform.appendChild(effect);

        const colors = ['blue', 'purple', 'green'];
        const color = colors[Math.floor(Math.random() * colors.length)];
        platform.classList.add(color);
        
        let isDisappearing = false;
        if (level >= 4 && Math.random() < 0.4) {
            isDisappearing = true;
        }
        if (isDisappearing) {
            platform.classList.add('disappearing');
        }

        platform.style.width = `${platformWidth}px`;
        platform.style.height = `${platformHeight}px`;
        platform.style.bottom = `${platformY}px`;
        platform.style.right = `${platformRight}px`;
        
        if (Math.random() > 0.7 && level > 3) {
            const indicator = document.createElement('div');
            indicator.classList.add('challenge-indicator');
            indicator.innerHTML = '<i class="fas fa-exclamation"></i>';
            indicator.style.bottom = `${platformY + platformHeight + 10}px`;
            indicator.style.right = `${platformRight + (platformWidth / 2) - 15}px`;
            gameArea.appendChild(indicator);
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.remove();
                }
            }, 2000);
        }

        gameArea.appendChild(platform);

        flyingPlatforms.push({
            element: platform,
            width: platformWidth,
            height: platformHeight,
            y: platformY,
            passed: false,
            activated: false,
            isDisappearing: isDisappearing,
            fading: false
        });

        const spikeWidth = 30;
        const spikeHeight = 30;
        const numSpikes = Math.ceil(platformWidth / spikeWidth);
        for (let i = 0; i < numSpikes; i++) {
            const spike = document.createElement('div');
            spike.classList.add('inverted-spike-obstacle');
            spike.style.width = `${spikeWidth}px`;
            spike.style.height = `${spikeHeight}px`;
            spike.style.bottom = `${platformY - spikeHeight}px`;
            spike.style.right = `${platformRight + (i * spikeWidth)}px`;

            gameArea.appendChild(spike);
            obstacles.push({
                element: spike,
                passed: false,
                used: false,
                isMoving: false,
                initialY: 0,
                moveRange: 0,
                moveSpeed: 0,
                moveOffset: 0
            });
        }
    }

    function createCoin() {
        const coin = document.createElement('div');
        coin.classList.add('coin');
        coin.innerHTML = '<i class="fas fa-coins"></i>';
        const coinY = Math.random() * (gameArea.offsetHeight - 200) + 100;
        coin.style.bottom = `${coinY}px`;
        coin.style.right = '-50px';
        gameArea.appendChild(coin);
        coins.push({ element: coin, y: coinY, collected: false });
    }

    function createParticles(x, y, color, count = 10, sizeMin = 4, sizeMax = 12, speedMin = 2, speedMax = 6) {
        for (let i = 0; i < count; i++) {
            const particle = document.createElement('div');
            particle.classList.add('particle');
            particle.style.backgroundColor = color;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;

            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * (speedMax - speedMin) + speedMin;
            const vx = Math.cos(angle) * speed;
            const vy = Math.sin(angle) * speed;

            const size = Math.random() * (sizeMax - sizeMin) + sizeMin;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.setProperty('--vx', `${vx}px`);
            particle.style.setProperty('--vy', `${vy}px`);

            gameArea.appendChild(particle);
            
            setTimeout(() => {
                particle.remove();
            }, 800);
        }
    }

    function createSuccessParticles(x, y, count = 25) {
        for (let i = 0; i < count; i++) {
            const particle = document.createElement('div');
            particle.classList.add('success-particles');
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 120 + 60;
            const tx = Math.cos(angle) * distance;
            const ty = Math.sin(angle) * distance;
            
            particle.style.setProperty('--tx', `${tx}px`);
            particle.style.setProperty('--ty', `${ty}px`);
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            
            const size = Math.random() * 18 + 7;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.backgroundColor = Math.random() > 0.5 ? '#4cc9f0' : '#2ecc71';
            
            gameArea.appendChild(particle);
            
            setTimeout(() => {
                particle.remove();
            }, 1200);
        }
    }

    function showWarning() {
        warningOverlay.style.display = 'flex';
        playSound(100, 'square', 0.2, 0.4);
        setTimeout(() => playSound(120, 'square', 0.2, 0.4), 150);
        setTimeout(() => {
            warningOverlay.style.display = 'none';
        }, 1300);
    }

    function showLevelUp() {
        levelUpElement.style.display = 'block';
        levelUpElement.textContent = `ŸÖÿ≥ÿ™ŸàŸâ ÿ¨ÿØŸäÿØ! (${level})`;
        playSound(700, 'triangle', 0.15, 0.3);
        setTimeout(() => playSound(900, 'triangle', 0.15, 0.3), 100);
        setTimeout(() => {
            levelUpElement.style.display = 'none';
        }, 1200);
    }

    function updatePlayerDisplay() {
        playerModeDisplay.textContent = playerMode === 'cube' ? 'ŸÖŸÉÿπÿ®' : 'ÿ≥ŸÅŸäŸÜÿ©';
        speedDisplay.textContent = `x${currentSpeedMultiplier.toFixed(1)}`;
    }

    function startGame() {
        gameRunning = true;
        gamePaused = false;
        score = 0;
        level = 1;
        platformsPassed = 0;
        coinsCollected = 0;
        highScore = localStorage.getItem('gdHighScore') || 0;
        obstacles = [];
        flyingPlatforms = [];
        coins = [];
        obstacleSpeed = BASE_SPEED;
        currentSpeedMultiplier = 1.0;
        obstacleGenerationTime = 2.0;
        timeSinceLastObstacle = 0;
        isJumping = false;
        canJump = true;
        lastObstaclePassed = 0;
        gravityDirection = 1;
        currentPlatform = null;
        collidedObstacleRef = null;
        rotationAngle = 0;
        rotationSpeed = -500;
        isRolling = true;
        playerY = 0;
        playerVelocity = 0;
        isSliding = false;

        startScreen.style.display = 'none';
        endScreen.style.display = 'none';
        questionModal.style.display = 'none';
        gameArea.innerHTML = '';

        const dashLine = document.createElement('div');
        dashLine.classList.add('dash-line');
        gameArea.appendChild(dashLine);

        createBackgroundElements();
        createPlayer();

        const ground = document.createElement('div');
        ground.classList.add('ground');
        gameArea.appendChild(ground);

        const ceiling = document.createElement('div');
        ceiling.classList.add('ceiling');
        gameArea.appendChild(ceiling);

        levelElement.textContent = level;
        scoreElement.textContent = score;
        platformsPassedElement.textContent = platformsPassed;
        coinsCollectedElement.textContent = coinsCollected;
        updatePlayerDisplay();

        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(updateGame);

        startMusic();
    }

    function updateGame(timestamp) {
        if (!gameRunning) return;

        const deltaTime = (timestamp - lastTime) / 1000; // Delta time in seconds
        lastTime = timestamp;

        if (gamePaused) {
            animationFrameId = requestAnimationFrame(updateGame);
            return;
        }

        // --- Game Logic Updates ---

        // 1. Player Physics (Gravity, Velocity, Position)
        const gravity = BASE_GRAVITY;
        const jumpForce = BASE_JUMP_FORCE;

        playerVelocity -= gravity * gravityDirection * deltaTime;
        playerY += playerVelocity * deltaTime;

        // 2. Platform/Ground Collision
        let onPlatform = false;
        const maxPlayerY = gameArea.offsetHeight - groundLevel - playerHeight;

        flyingPlatforms.forEach(platform => {
            const platformRect = platform.element.getBoundingClientRect();
            const playerRect = player.getBoundingClientRect();
            const gameAreaRect = gameArea.getBoundingClientRect();

            const platformLeft = platformRect.left - gameAreaRect.left;
            const platformRight = platformRect.right - gameAreaRect.left;
            const platformTop = platformRect.top - gameAreaRect.top;

            const playerLeft = playerRect.left - gameAreaRect.left;
            const playerRight = playerRect.right - gameAreaRect.left;
            const playerBottom = playerRect.bottom - gameAreaRect.top;
            
            const isAbove = playerBottom >= platformTop - 10 && playerBottom <= platformTop + 10;
            const isHorizontallyAligned = playerRight > platformLeft && playerLeft < platformRight;
            
            if (isAbove && isHorizontallyAligned && playerVelocity <= 0 && gravityDirection === 1) {
                onPlatform = true;
                playerY = gameArea.offsetHeight - platformTop - groundLevel;
                playerVelocity = 0;
                isJumping = false;
                canJump = true;
                currentPlatform = platform;
                
                if (!platform.activated) {
                    platform.activated = true;
                    platformsPassed++;
                    platformsPassedElement.textContent = platformsPassed;
                    score += 50;
                    platform.element.style.boxShadow = '0 0 40px rgba(76, 201, 240, 1)';
                    playSound(500, 'sine', 0.1, 0.3);
                    createParticles(
                        player.offsetLeft + player.offsetWidth/2,
                        player.offsetTop,
                        '#4cc9f0',
                        15
                    );

                    if (platform.isDisappearing && !platform.fading) {
                        platform.fading = true;
                        platform.element.classList.add('fading');
                        setTimeout(() => {
                            if (platform.element.parentNode) {
                                platform.element.remove();
                                const platformIndex = flyingPlatforms.indexOf(platform);
                                if (platformIndex > -1) {
                                    flyingPlatforms.splice(platformIndex, 1);
                                }
                            }
                        }, 300);
                    }
                }
            } else if (isAbove && isHorizontallyAligned && playerVelocity >= 0 && gravityDirection === -1) {
                // Collision logic for inverted gravity on platform bottom (simplified for now)
                // If implementing a full inverse gravity mode, more detailed logic is needed
            }
        });

        if (!onPlatform) {
            currentPlatform = null;
        }

        // 3. Boundary Check (Ground/Ceiling)
        if (gravityDirection === 1) { // Normal Gravity
            if (playerY < 0) {
                playerY = 0;
                playerVelocity = 0;
                isJumping = false;
                canJump = true;
            } else if (playerY > maxPlayerY) {
                playerY = maxPlayerY;
                playerVelocity = 0;
            }
        } else { // Inverted Gravity
            if (playerY > maxPlayerY) {
                playerY = maxPlayerY;
                playerVelocity = 0;
                isJumping = false;
                canJump = true;
            } else if (playerY < 0) {
                playerY = 0;
                playerVelocity = 0;
            }
        }

        // 4. Update Player Visuals
        player.style.bottom = `${groundLevel + playerY}px`;
        
        if (playerMode !== 'ship') {
            if (isRolling) {
                rotationAngle += rotationSpeed * gravityDirection * deltaTime;
            }
            player.style.transform = `rotate(${rotationAngle}deg) ${isSliding ? 'scale(1.5, 0.5)' : ''}`;
        } else {
            player.style.transform = `rotate(0deg)`;
        }

        // 5. Scoring and Leveling
        score += 100 * currentSpeedMultiplier * deltaTime; // Score based on time passed
        scoreElement.textContent = Math.floor(score);

        const newLevel = Math.floor(score / 2000) + 1; // Level up every 2000 points
        if (newLevel > level) {
            level = newLevel;
            levelElement.textContent = level;
            showLevelUp();
            obstacleSpeed += 20; // Increase base speed in px/s
            rotationSpeed -= 50; // Increase rotation speed
            currentSpeedMultiplier += 0.05; // Smaller speed multiplier increase
        }

        const progress = Math.min(100, (score % 2000) / 2000 * 100);
        progressBar.style.width = `${progress}%`;

        // 6. Background Movement
        backgroundElements.forEach(el => {
            const currentRight = parseFloat(el.style.right || 0);
            const parallaxSpeed = parseFloat(el.dataset.parallaxSpeed);
            // Movement speed is BASE_SPEED (250 px/s) * multiplier * parallax factor * deltaTime
            el.style.right = `${currentRight - (obstacleSpeed * parallaxSpeed * currentSpeedMultiplier * deltaTime)}px`;
            
            if (currentRight > gameArea.offsetWidth + el.offsetWidth) {
                el.style.right = `-50px`; // Move from right to left (reset outside left edge)
            }
        });

        // 7. Obstacle Generation
        timeSinceLastObstacle += deltaTime;
        const currentObstacleInterval = obstacleGenerationTime / currentSpeedMultiplier;
        if (timeSinceLastObstacle >= currentObstacleInterval) {
            createObstacle();
            timeSinceLastObstacle = 0;
        }

        // 8. Obstacle, Platform, Coin Movement and Collision Detection
        const movementDistance = obstacleSpeed * currentSpeedMultiplier * deltaTime;

        flyingPlatforms = flyingPlatforms.filter(platform => {
            const platformEl = platform.element;
            const currentRight = parseFloat(platformEl.style.right || 0);
            const newRight = currentRight + movementDistance;
            platformEl.style.right = `${newRight}px`;
            
            if (newRight > gameArea.offsetWidth + 120) {
                platformEl.remove();
                return false;
            }
            return true;
        });

        coins = coins.filter(coin => {
            const coinEl = coin.element;
            const currentRight = parseFloat(coinEl.style.right || 0);
            coinEl.style.right = `${currentRight + movementDistance}px`;

            if (detectCoinCollision(player, coinEl)) {
                coin.collected = true;
                coinsCollected++;
                coinsCollectedElement.textContent = coinsCollected;
                score += 100;
                playSound(880, 'triangle', 0.05, 0.5);
                coinEl.remove();
                return false;
            }

            if (currentRight > gameArea.offsetWidth + 50) {
                coinEl.remove();
                return false;
            }
            return true;
        });

        obstacles = obstacles.filter((obs, index) => {
            const obstacle = obs.element;
            const currentRight = parseFloat(obstacle.style.right || 0);
            const newRight = currentRight + movementDistance;
            obstacle.style.right = `${newRight}px`;

            if (obs.isMoving) {
                const time = performance.now() / 1000 + obs.moveOffset;
                const offsetY = Math.sin(time * obs.moveSpeed) * obs.moveRange;
                obstacle.style.bottom = `${obs.initialY + offsetY}px`;
            }

            // Passing an obstacle
            if (!obs.passed && newRight > gameArea.offsetWidth - 220) {
                obs.passed = true;
                lastObstaclePassed = score;
                if (!obstacle.classList.contains('air-pad') && !obstacle.classList.contains('gravity-portal') && !obstacle.classList.contains('speed-portal') && !obstacle.classList.contains('inverted-spike-obstacle')) {
                    playSound(600, 'triangle', 0.1, 0.2);
                    setTimeout(() => playSound(800, 'triangle', 0.1, 0.2), 50);
                    obstacle.classList.add('obstacle-passed');
                    createSuccessParticles(
                        obstacle.offsetLeft + obstacle.offsetWidth/2,
                        obstacle.offsetTop + obstacle.offsetHeight/2
                    );
                }
            }

            // Removal outside bounds
            if (newRight > gameArea.offsetWidth + 120) {
                obstacle.remove();
                return false;
            }

            // Collision Detection
            if (detectCollision(player, obstacle, obs)) {
                animationFrameId = requestAnimationFrame(updateGame);
                return true; // Keep the obstacle on screen while in question modal
            }
            
            return true;
        });

        animationFrameId = requestAnimationFrame(updateGame);
    }

    function showQuestion() {
        gamePaused = true;
        
        const q = questions[Math.floor(Math.random() * questions.length)];
        currentQuestion = q;
        questionTextElement.innerHTML = q.question;
        feedbackMessageElement.textContent = '';
        feedbackMessageElement.classList.remove('correct', 'incorrect');
        optionsContainer.innerHTML = '';
        currentSelectedOptionIndex = -1;
        optionsContainer.style.display = 'flex';
        submitAnswerBtn.style.display = 'block';

        q.options.forEach((optionText, index) => {
            const optionBtn = document.createElement('button');
            optionBtn.classList.add('option-btn');
            optionBtn.innerHTML = optionText;
            optionBtn.dataset.index = index;
            
            optionBtn.addEventListener('click', () => {
                optionsContainer.querySelectorAll('.option-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });
                optionBtn.classList.add('selected');
                currentSelectedOptionIndex = index;
            });

            optionsContainer.appendChild(optionBtn);
        });

        currentCorrectOptionIndex = q.correctOptionIndex;
        questionModal.style.display = 'flex';
        optionsContainer.querySelector('.option-btn')?.focus();

        playSound(150, 'square', 0.2, 0.4);

        if (typeof MathJax !== 'undefined') {
            MathJax.typesetPromise([questionTextElement, optionsContainer]);
        }
    }

    function checkAnswer() {
        if (currentSelectedOptionIndex === -1) {
            feedbackMessageElement.textContent = 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿ•ÿ¨ÿßÿ®ÿ© ÿ£ŸàŸÑÿßŸã.';
            feedbackMessageElement.classList.add('incorrect');
            return;
        }

        let isCorrect = (currentSelectedOptionIndex === currentCorrectOptionIndex);

        if (isCorrect) {
            feedbackMessageElement.textContent = 'ÿµÿ≠Ÿäÿ≠! ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑŸÑÿπÿ®.';
            feedbackMessageElement.classList.add('correct');
            playSound(600, 'sine', 0.1, 0.5);

            setTimeout(() => {
                questionModal.style.display = 'none';
                gamePaused = false;

                // Clear the immediate area of the player for a safe respawn
                const playerSafeX = 50;
                const playerSafeWidth = player.offsetWidth;
                const safeZoneBuffer = 150;
                
                obstacles = obstacles.filter(obs => {
                    const obstacleElement = obs.element;
                    const obstacleRight = parseFloat(obstacleElement.style.right || 0);
                    const obstacleLeft = gameArea.offsetWidth - obstacleRight - obstacleElement.offsetWidth;
                    
                    const overlaps = (
                        obstacleLeft < (playerSafeX + playerSafeWidth + safeZoneBuffer) &&
                        (obstacleLeft + obstacleElement.offsetWidth) > (playerSafeX - safeZoneBuffer)
                    );

                    if (overlaps) {
                        obstacleElement.remove();
                        return false;
                    }
                    return true;
                });

                flyingPlatforms = flyingPlatforms.filter(platform => {
                    const platformElement = platform.element;
                    const platformRight = parseFloat(platformElement.style.right || 0);
                    const platformLeft = gameArea.offsetWidth - platformRight - platformElement.offsetWidth;
                    
                    const overlaps = (
                        platformLeft < (playerSafeX + playerSafeWidth + safeZoneBuffer) &&
                        (platformLeft + platformElement.offsetWidth) > (playerSafeX - safeZoneBuffer)
                    );

                    if (overlaps) {
                        platformElement.remove();
                        return false;
                    }
                    return true;
                });

                // Reset player state
                player.style.left = '50px';
                player.style.bottom = `${groundLevel}px`;
                playerY = 0;
                playerVelocity = 0;
                gravityDirection = 1;
                playerMode = (selectedCharacter === 1 || selectedCharacter === 3) ? 'cube' : 'ship';
                player.classList.remove('ship-mode');
                player.classList.add(playerMode === 'cube' ? 'rolling' : 'ship-mode');
                player.querySelector('i').className = selectedCharacter === 1 ? 'fas fa-cube' : (selectedCharacter === 2 ? 'fas fa-ship' : 'fas fa-robot');
                rotationAngle = 0;
                isSliding = false;
                player.style.transform = `rotate(${rotationAngle}deg)`;
                updatePlayerDisplay();

                // Resume game loop
                lastTime = performance.now();
                requestAnimationFrame(updateGame);

            }, 1000);
        } else {
            const correctAnswerDisplay = currentQuestion.options[currentCorrectOptionIndex];
            feedbackMessageElement.textContent = `ÿÆÿ∑ÿ£! ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: ${correctAnswerDisplay}`;
            feedbackMessageElement.classList.add('incorrect');
            playSound(80, 'sawtooth', 0.3, 0.5);

            setTimeout(() => {
                questionModal.style.display = 'none';
                endGame();
            }, 2000);
        }
    }

    function detectCollision(player, obstacle, obsData) {
        const playerRect = player.getBoundingClientRect();
        const obstacleRect = obstacle.getBoundingClientRect();
        const gameAreaRect = gameArea.getBoundingClientRect();

        const playerX = playerRect.left - gameAreaRect.left;
        const playerY_from_top = playerRect.top - gameAreaRect.top;
        const obstacleX = obstacleRect.left - gameAreaRect.left;
        const obstacleY_from_top = obstacleRect.top - gameAreaRect.top;

        let playerHitbox = {
            x: playerX + player.offsetWidth * 0.15,
            y: playerY_from_top + player.offsetHeight * 0.15,
            width: player.offsetWidth * 0.7,
            height: player.offsetHeight * 0.7
        };

        let obstacleHitbox = {
            x: obstacleX,
            y: obstacleY_from_top,
            width: obstacle.offsetWidth,
            height: obstacle.offsetHeight
        };
        
        if (isSliding) {
            // Reduce player height to half when sliding
            playerHitbox.y += playerHitbox.height * 0.5;
            playerHitbox.height *= 0.5;
        }

        const isOverlapping = (
            playerHitbox.x < obstacleHitbox.x + obstacleHitbox.width &&
            playerHitbox.x + playerHitbox.width > obstacleHitbox.x &&
            playerHitbox.y < obstacleHitbox.y + obstacleHitbox.height &&
            playerHitbox.y + playerHitbox.height > obstacleHitbox.y
        );

        if (!isOverlapping) {
            return false;
        }

        if (obstacle.classList.contains('flying-platform')) {
            return false;
        }

        if (obstacle.classList.contains('air-pad')) {
            const landingTolerance = 15;
            const isLanding = playerVelocity < 0 && 
                                playerRect.bottom >= obstacleRect.top - landingTolerance && 
                                playerRect.bottom <= obstacleRect.top + landingTolerance &&
                                playerRect.left < obstacleRect.right &&
                                playerRect.right > obstacleRect.left;

            if (isLanding && gravityDirection === 1) {
                playerY = (gameAreaRect.height - obstacleRect.top - player.offsetHeight) - groundLevel;
                playerVelocity = jumpForce * 1.5; // Extra big jump from air-pad
                canJump = false;
                isJumping = true;
                playSound(550, 'sine', 0.05, 0.2);
                return false;
            } else {
                playSound(80, 'sawtooth', 0.2, 0.3);
                createParticles(
                    player.offsetLeft + player.offsetWidth/2,
                    player.offsetTop + player.offsetHeight/2,
                    '#e94560', 35, 5, 15, 3, 8
                );
                collidedObstacleRef = obsData;
                showQuestion();
                return true;
            }
        } else if (obstacle.classList.contains('gravity-portal')) {
            if (!obsData.used) {
                gravityDirection *= -1;
                obsData.used = true;
                obstacle.classList.add('used');
                playSound(900, 'triangle', 0.15, 0.4);
                showGameMessage(gravityDirection === 1 ? 'ÿ¨ÿßÿ∞ÿ®Ÿäÿ© ÿπÿßÿØŸäÿ©!' : 'ÿ¨ÿßÿ∞ÿ®Ÿäÿ© ŸÖÿπŸÉŸàÿ≥ÿ©!');
                const icon = obstacle.querySelector('i');
                if (icon) {
                    icon.classList.toggle('inverted', gravityDirection === -1);
                }
                setTimeout(() => obstacle.remove(), 500);
            }
            return false;
        } else if (obstacle.classList.contains('speed-portal')) {
            if (!obsData.used) {
                currentSpeedMultiplier = Math.min(3, currentSpeedMultiplier + 0.3);
                obsData.used = true;
                obstacle.classList.add('used');
                playSound(1200, 'square', 0.1, 0.4);
                showGameMessage(`ÿßŸÑÿ≥ÿ±ÿπÿ©: x${currentSpeedMultiplier.toFixed(1)}`);
                updatePlayerDisplay();
                setTimeout(() => obstacle.remove(), 500);
            }
            return false;
        } else {
            playSound(80, 'sawtooth', 0.2, 0.3);
            createParticles(
                player.offsetLeft + player.offsetWidth/2,
                player.offsetTop + player.offsetHeight/2,
                '#e94560', 35, 5, 15, 3, 8
            );
            collidedObstacleRef = obsData;
            showQuestion();
            return true;
        }
    }

    function detectCoinCollision(player, coin) {
        const playerRect = player.getBoundingClientRect();
        const coinRect = coin.getBoundingClientRect();
        const gameAreaRect = gameArea.getBoundingClientRect();

        const playerX = playerRect.left - gameAreaRect.left;
        const playerY_from_top = playerRect.top - gameAreaRect.top;
        const coinX = coinRect.left - gameAreaRect.left;
        const coinY_from_top = coinRect.top - gameAreaRect.top;

        const playerHitbox = {
            x: playerX + player.offsetWidth * 0.15,
            y: playerY_from_top + player.offsetHeight * 0.15,
            width: player.offsetWidth * 0.7,
            height: player.offsetHeight * 0.7
        };

        const coinHitbox = {
            x: coinX,
            y: coinY_from_top,
            width: coin.offsetWidth,
            height: coin.offsetHeight
        };

        return (
            playerHitbox.x < coinHitbox.x + coinHitbox.width &&
            playerHitbox.x + playerHitbox.width > coinHitbox.x &&
            playerHitbox.y < coinHitbox.y + coinHitbox.height &&
            playerHitbox.y + coinHitbox.height > coinHitbox.y
        );
    }

    function endGame() {
        gameRunning = false;
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        
        if (score > highScore) {
            highScore = Math.floor(score);
            localStorage.setItem('gdHighScore', highScore);
            highScoreElement.textContent = highScore;
        }

        endScreen.style.display = 'flex';
        finalScoreElement.textContent = Math.floor(score);
        finalHighScoreElement.textContent = highScore;
        finalPlatformsElement.textContent = platformsPassed;
        finalCoinsElement.textContent = coinsCollected;

        stopMusic();
    }

    function jump() {
        if (!gameRunning || gamePaused) return;
        if (!canJump) return;

        isJumping = true;
        canJump = false;
        isSliding = false; // Stop sliding on jump

        if (gravityDirection === 1 && playerY < 1) { // Normal jump from ground/platform
            playerVelocity = BASE_JUMP_FORCE * gravityDirection;
            playSound(440, 'sine', 0.1, 0.2);
        } else if (gravityDirection === -1 && playerY >= gameArea.offsetHeight - groundLevel - playerHeight - 1) { // Inverted jump from ceiling
            playerVelocity = BASE_JUMP_FORCE * gravityDirection;
            playSound(440, 'sine', 0.1, 0.2);
        }

        if (playerMode !== 'ship') {
            // Apply immediate rotation on jump
            rotationSpeed = -500 * gravityDirection;
            isRolling = true;
        }

        createParticles(
            player.offsetLeft + player.offsetWidth/2,
            player.offsetTop + (gravityDirection === 1 ? player.offsetHeight : 0),
            playerMode === 'ship' ? '#ff9e00' : '#4cc9f0'
        );
    }

    function slide() {
        if (!gameRunning || gamePaused) return;
        
        // Only allow slide from ground or ceiling
        if (
            (gravityDirection === 1 && playerY < 1) ||
            (gravityDirection === -1 && playerY >= gameArea.offsetHeight - groundLevel - playerHeight - 1)
        ) {
            isSliding = true;
            isRolling = false; // Stop rolling while sliding
            player.style.transform = 'rotate(0deg) scale(1.5, 0.5)';

            createParticles(
                player.offsetLeft + player.offsetWidth/2,
                player.offsetTop + (gravityDirection === 1 ? player.offsetHeight : 0),
                playerMode === 'ship' ? '#ff6a00' : '#4361ee'
            );

            // Automatically stop sliding after a short period
            setTimeout(() => {
                isSliding = false;
                isRolling = true;
                player.style.transform = `rotate(${rotationAngle}deg)`;
            }, 450);
        }
    }

    function togglePause() {
        if (!gameRunning) return;
        if (questionModal.style.display === 'flex') { return; } // Can't pause during a question

        gamePaused = !gamePaused;

        if (gamePaused) {
            const pauseOverlay = document.createElement('div');
            pauseOverlay.classList.add('pause-overlay');
            pauseOverlay.id = 'pause-overlay';

            const pauseText = document.createElement('div');
            pauseText.textContent = 'ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™';
            pauseOverlay.appendChild(pauseText);

            const resumeBtn = document.createElement('button');
            resumeBtn.classList.add('btn');
            resumeBtn.innerHTML = '<i class="fas fa-play"></i> ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ ÿßŸÑŸÑÿπÿ®ÿ©';
            resumeBtn.addEventListener('click', togglePause);
            pauseOverlay.appendChild(resumeBtn);

            gameArea.appendChild(pauseOverlay);
            stopMusic();
        } else {
            const pauseOverlay = document.getElementById('pause-overlay');
            if (pauseOverlay) {
                pauseOverlay.remove();
            }
            lastTime = performance.now(); // Reset lastTime to prevent huge deltaTime on resume
            requestAnimationFrame(updateGame);
            startMusic();
        }
    }

    function toggleSound() {
        soundEnabled = !soundEnabled;
        if (soundEnabled) {
            musicToggleButton.innerHTML = '<i class="fas fa-volume-up"></i>';
            if (gameRunning && !gamePaused) {
                startMusic();
            }
        } else {
            musicToggleButton.innerHTML = '<i class="fas fa-volume-off"></i>';
            stopMusic();
        }
    }

    let selectedCharacter = 1;
    characterElements.forEach(character => {
        character.addEventListener('click', () => {
            characterElements.forEach(c => c.classList.remove('active'));
            character.classList.add('active');
            selectedCharacter = parseInt(character.dataset.character);
            if (gameRunning) {
                createPlayer();
            }
        });
    });

    musicToggleButton.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i>' : '<i class="fas fa-volume-off"></i>';

    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);
    musicToggleButton.addEventListener('click', toggleSound);
    submitAnswerBtn.addEventListener('click', checkAnswer);
    jumpBtn.addEventListener('click', jump);
    slideBtn.addEventListener('click', slide);

    document.addEventListener('keydown', (e) => {
        if (questionModal.style.display === 'flex') {
            if (e.key === 'Enter') {
                checkAnswer();
            }
            e.preventDefault();
            return;
        }

        if (e.code === 'Space' || e.key === ' ' || e.key === 'ArrowUp') {
            e.preventDefault();
            jump();
        }

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            slide();
        }

        if (e.key === 'p' || e.key === 'P' || e.key === 'ÿ©') {
            togglePause();
        }

        if (e.key === 'r' || e.key === 'R' || e.key === 'ŸÇ') {
            if (!gameRunning) startGame();
        }
    });

    document.addEventListener('touchstart', (e) => {
        if (questionModal.style.display === 'flex') {
            return;
        }
        
        if (e.target.closest('#music-toggle-btn') || e.target.closest('#warning-overlay') || e.target.closest('.btn') || e.target.closest('.pause-overlay')) {
            return;
        }

        const gameAreaRect = gameArea.getBoundingClientRect();
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;

        if (touchX >= gameAreaRect.left && touchX <= gameAreaRect.right && touchY >= gameAreaRect.top && touchY <= gameAreaRect.bottom) {
            e.preventDefault();
            if (gameRunning && !gamePaused) {
                jump();
            }
        }
    });

    // Initial call to set high score display
    highScoreElement.textContent = highScore;

    const scrollIndicator = document.querySelector('.scroll-indicator');
    if (scrollIndicator) {
        setInterval(() => {
            scrollIndicator.style.opacity = scrollIndicator.style.opacity === '0.5' ? '1' : '0.5';
        }, 800);
    }
});
</script>
</body>
</html>
