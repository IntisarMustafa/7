<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ø³ÙˆØ¨Ø± Sheep - Ø¬Ù…Ø¹ Ø§Ù„Ø®Ø±Ø§Ù Ø§Ù„Ø¶Ø§Ø¦Ø¹Ø©</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Cairo", sans-serif;
        }
        body, html {
            overflow: hidden;
            background: linear-gradient(to bottom, #87ceeb, #b0e0e6);
            color: #1a1a2e;
            height: 100%;
            width: 100%;
            cursor: grab;
        }
        body.dragging, html.dragging {
            cursor: grabbing;
        }
        body {
            touch-action: none;
        }
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            z-index: 300;
        }
        .start-screen-content {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            animation: fadeInScale 0.7s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        .start-screen h1 {
            color: #4caf50;
            font-size: 40px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #4caf50;
        }
        .start-screen h2 {
            color: #8bc34a;
            margin-top: 30px;
            margin-bottom: 10px;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 5px;
            font-size: 24px;
        }
        .start-screen p {
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: center;
        }
        .start-btn {
            background: linear-gradient(to right, #4caf50, #2e7d32);
            color: white;
            padding: 15px 35px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            margin: 20px 0;
        }
        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5);
        }
        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
            align-items: center;
            justify-content: center;
        }
        .info-panel {
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            opacity: 0.95;
            display: none;
        }
        .scene-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            height: 100%;
            width: 100%;
        }
        #gameScene {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 10px;
            color: white;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4caf50;
        }
        .stat-label {
            font-size: 12px;
            opacity: 0.8;
        }
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            max-width: 400px;
            display: none;
            color: white;
        }
        .title {
            font-size: 24px;
            margin-bottom: 10px;
            color: #4caf50;
            text-align: center;
        }
        .subtitle {
            font-size: 16px;
            opacity: 0.8;
            text-align: center;
        }
        .game-ui {
            position: absolute;
            bottom: 200px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
        }
        .ui-button {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .charge-btn {
            background: linear-gradient(to bottom, #ff5722, #ff9800);
            box-shadow: 0 4-px 10px rgba(255, 87, 34, 0.5);
            transition: transform 0.1s ease, box-shadow 0.3s ease;
        }
        .ui-button:active {
            background: rgba(76, 175, 80, 0.5);
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        .score-display {
            position: absolute;
            top: 50px;
            right: 20px;
            font-size: 24px;
            color: #2e7d32;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }
        .coins-display {
            position: absolute;
            top: 85px;
            right: 20px;
            font-size: 20px;
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }
        .sheep-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: #ffffff;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
        }
        .health-indicator {
            position: absolute;
            top: 155px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            display: none;
            z-index: 100;
        }
        .health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            transition: width 0.3s ease;
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            display: none;
            color: white;
        }
        .restart-btn {
            background: linear-gradient(to right, #4caf50, #2e7d32);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            margin-top: 20px;
        }
        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        .movement-controls {
            position: absolute;
            bottom: 200px;
            left: 20px;
            z-index: 100;
        }
        /* Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© - ØªÙ… ØªØ­Ø³ÙŠÙ†Ù‡Ø§ */
        .joystick-container {
            position: relative;
            width: 150px;
            height: 150px;
            touch-action: none;
        }
        .joystick-base {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            touch-action: none;
        }
        .joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(76, 175, 80, 0.7);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            touch-action: none;
        }
        .joystick-handle.active {
            background: rgba(76, 175, 80, 0.9);
            transform: translate(-50%, -50%) scale(1.1);
        }
        .coin-animation {
            position: absolute;
            font-size: 24px;
            color: #ffd700;
            font-weight: bold;
            animation: coinFloat 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 90;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .laser-sight {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: transparent;
            border: 3px solid #ff5722;
            box-shadow: 0 0 15px rgba(255, 87, 34, 0.9);
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            pointer-events: none;
            z-index: 90;
            display: none;
        }
        .world-boundary {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            color: #ff9800;
            z-index: 100;
            display: none;
            animation: boundaryPulse 2s infinite;
        }
        .round-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        .round-transition.active {
            opacity: 1;
            pointer-events: all;
        }
        .round-message {
            background: rgba(255, 255, 255, 0.9);
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            font-size: 32px;
            color: #4caf50;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .question-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 250;
            display: none;
            color: white;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        .question-panel h2 {
            color: #4caf50;
            margin-bottom: 20px;
            font-size: 28px;
        }
        .question-panel p {
            font-size: 20px;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        .options-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .option-btn {
            background: linear-gradient(to right, #4caf50, #2e7d32);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        .option-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        .health-box-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
        }
        .health-box-icon {
            font-size: 50px;
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            animation: pulse 1.5s infinite ease-in-out;
        }
        .health-box-label {
            position: absolute;
            bottom: -30px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: #00bfff;
            text-shadow: 0 0 5px rgba(0, 191, 255, 0.5);
            font-weight: bold;
        }
        /* Ø£Ù†Ù…Ø§Ø· Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ù‚ÙØ² */
        .jump-btn {
            background: linear-gradient(to bottom, #2196f3, #0d47a1);
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.5);
        }
        .jump-effect {
            position: absolute;
            width: 50px;
            height: 10px;
            background: rgba(33, 150, 243, 0.5);
            border-radius: 50%;
            filter: blur(5px);
            z-index: 90;
            animation: jumpPulse 0.5s ease-out;
        }
        .laser-sight.sprinting {
            border-color: #9c27b0;
            box-shadow: 0 0 15px rgba(156, 39, 176, 0.9);
        }
        /* Ø£Ù†Ù…Ø§Ø· Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø¹ØµØ§ */
        .stick-attack {
            position: absolute;
            width: 100px;
            height: 20px;
            background: linear-gradient(to right, #8b4513, #a0522d);
            border-radius: 10px;
            transform-origin: left center;
            z-index: 80;
            pointer-events: none;
            display: none;
        }
        /* Ø£Ù†Ù…Ø§Ø· Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø²Ø± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© */
        .bomb-btn {
            background: linear-gradient(to bottom, #ff5722, #d32f2f);
            box-shadow: 0 4px 10px rgba(255, 87, 34, 0.5);
        }
        .bomb-btn.disabled {
            background: #888;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            cursor: not-allowed;
        }
        .bomb-btn.charging {
            animation: bombChargePulse 0.5s infinite alternate;
        }
        .bomb-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,215,0,0.8) 0%, rgba(255,0,0,0) 70%);
            z-index: 90;
            pointer-events: none;
            animation: bombExplosion 0.5s ease-out;
        }
        /* Ø´Ø±ÙŠØ· Ø´Ø­Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯ */
        .bomb-charge-indicator {
            position: absolute;
            bottom: 280px;
            right: 20px;
            width: 80px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            display: none;
            z-index: 100;
        }
        .bomb-charge-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #ff9800, #ff5722);
            transition: width 0.1s linear;
        }
        .bomb-range-indicator {
            position: absolute;
            border: 2px solid rgba(255, 87, 34, 0.7);
            border-radius: 50%;
            pointer-events: none;
            z-index: 90;
            display: none;
        }
        @keyframes bombChargePulse {
            0% { transform: scale(1); box-shadow: 0 0 10px rgba(255, 87, 34, 0.5); }
            100% { transform: scale(1.1); box-shadow: 0 0 20px rgba(255, 87, 34, 0.8); }
        }
        @keyframes bombExplosion {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        @keyframes jumpPulse {
            0% { opacity: 0.8; transform: scale(0.5); }
            100% { opacity: 0; transform: scale(2); }
        }
        @keyframes coinFloat {
            0% { opacity: 1; transform: translate(0, 0); }
            100% { opacity: 0; transform: translate(0, -100px); }
        }
        @keyframes fadeInScale {
            0% { opacity: 0; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }
        @keyframes boundaryPulse {
            0% { box-shadow: 0 0 5px rgba(255, 153, 0, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 153, 0, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 153, 0, 0.5); }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .hidden {
            display: none;
        }
        /* Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© */
        .success-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4caf50, #8bc34a);
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            font-size: 42px;
            font-weight: bold;
            text-align: center;
            z-index: 300;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            animation: popIn 0.8s ease-out;
            border: 5px solid #fff;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }
            .info-panel {
                width: 100%;
                max-height: 45vh;
            }
            .overlay {
                font-size: 14px;
                max-width: 80%;
                left: 15px;
                top: 15px;
            }
            .overlay .title {
                font-size: 18px;
            }
            .overlay .subtitle {
                font-size: 14px;
            }
            .game-ui {
                bottom: 170px;
                right: 10px;
            }
            .ui-button {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }
            .movement-controls {
                bottom: 170px;
                left: 10px;
            }
            .joystick-container {
                width: 120px;
                height: 120px;
            }
            .joystick-handle {
                width: 50px;
                height: 50px;
            }
            .score-display {
                bottom: 150px;
                right: 10px;
                font-size: 16px;
            }
            .coins-display {
                bottom: 180px;
                right: 10px;
                font-size: 16px;
            }
            .sheep-display {
                top: 10px;
                left: 10px;
                font-size: 16px;
                padding: 8px 12px;
            }
            .health-indicator {
                top: 150px;
                right: 10px;
                width: 150px;
            }
            .start-screen-content {
                padding: 20px;
            }
            .start-screen h1 {
                font-size: 30px;
            }
            .start-screen h2 {
                font-size: 20px;
            }
            .start-screen p {
                font-size: 16px;
            }
            .start-btn {
                font-size: 18px;
                padding: 12px 25px;
            }
            .round-indicator {
                font-size: 16px;
                padding: 8px 15px;
            }
            .next-round-btn {
                bottom: 170px;
                right: 10px;
                font-size: 14px;
                padding: 10px 15px;
            }
            .charge-indicator {
                bottom: 150px;
                right: 90px;
                width: 80px;
            }
            .world-boundary {
                font-size: 12px;
                padding: 6px 10px;
                top: 5px;
                right: 5px;
            }
            .round-message {
                font-size: 24px;
                padding: 20px 30px;
            }
            .bomb-charge-indicator {
                bottom: 250px;
                right: 10px;
                width: 70px;
            }
            .success-message {
                font-size: 28px;
                padding: 25px 40px;
            }
        }
        .answer-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4caf50, #8bc34a);
            color: white;
            padding: 30px;
            border-radius: 20px;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            z-index: 300;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: popIn 0.5s ease-out;
            border: 5px solid #fff;
        }
        .answer-message.incorrect {
            background: linear-gradient(45deg, #f44336, #ff9800);
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        /* ØªØ£Ø«ÙŠØ± Ø¬Ø¯ÙŠØ¯ Ù„Ø¶Ø±Ø± Ø§Ù„Ù„Ø§Ø¹Ø¨ */
        .player-damage-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .player-damage-effect.active {
            opacity: 1;
            animation: damageFlash 0.5s;
        }
        @keyframes damageFlash {
            0% { opacity: 0.7; }
            50% { opacity: 0.3; }
            100% { opacity: 0; }
        }
        /* Ø¹Ø±Ø¶ Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„ */
        .bombs-display {
            position: absolute;
            top: 190px;
            right: 20px;
            font-size: 20px;
            color: #ff5722;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }
        /* Ø£Ù†Ù…Ø§Ø· Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ§Øª */
        .sequence-container {
            direction: ltr;
            text-align: left;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
            font-size: 18px;
            line-height: 1.5;
        }
        .sequence-item {
            display: inline-block;
            margin: 0 5px;
        }
        /* Ø²Ø± Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© */
        .next-round-btn {
            position: absolute;
            bottom: 200px;
            right: 120px;
            background: linear-gradient(to right, #4caf50, #2e7d32);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 100;
            display: none;
        }
        .next-round-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
    </style>
</head>
<body>
    <!-- Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ø§Ù„Ù…Ø¹Ø¯Ù„Ø© - Ø£ØµØ¨Ø­Øª Ù…Ø®ØªØµØ±Ø© -->
    <div class="start-screen" id="startScreen">
        <div class="start-screen-content">
            <h1>Ø³ÙˆØ¨Ø± Sheep - Ø¬Ù…Ø¹ Ø§Ù„Ø®Ø±Ø§Ù Ø§Ù„Ø¶Ø§Ø¦Ø¹Ø©</h1>
            <h2>Ù‚ØµØ© Ø§Ù„Ù„Ø¹Ø¨Ø©</h2>
            <p>Ø¶Ø§Ø¹Øª Ø®Ù…Ø³ Ø®Ø±Ø§Ù Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø¹Ø§ØµÙØ©! ÙŠØ¨Ø­Ø« Ø§Ù„Ø±Ø§Ø¹ÙŠ Ø¹Ù†Ù‡Ø§ ÙˆÙŠÙˆØ§Ø¬Ù‡ Ø§Ù„Ø°Ø¦Ø§Ø¨ Ø§Ù„Ø´Ø±Ø³Ø© Ø§Ù„ØªÙŠ ØªØ­Ù…ÙŠ Ø§Ù„Ø®Ø±Ø§Ù.</p>
            <p>Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø±Ø§Ø¹ÙŠ ÙÙŠ Ø¬Ù…Ø¹ Ø§Ù„Ø®Ø±Ø§Ù Ø§Ù„Ø¶Ø§Ø¦Ø¹Ø© ÙˆØªØ¬Ù†Ø¨ Ø§Ù„Ø°Ø¦Ø§Ø¨ Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©!</p>
            <button class="start-btn" id="startGameBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
        </div>
    </div>
    <div class="laser-sight" id="laserSight"></div>
    <div class="world-boundary" id="worldBoundaryWarning">
        Ø£Ù†Øª ØªÙ‚ØªØ±Ø¨ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù…!
    </div>
    <div class="round-transition" id="roundTransition">
        <div class="round-message" id="roundMessage">Ø§Ù„Ø¬ÙˆÙ„Ø© 1</div>
    </div>
    <div class="player-damage-effect" id="playerDamageEffect"></div>
    <div class="container">
        <div class="info-panel" id="infoPanel">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="levelDisplay">1</div>
                    <div class="stat-label">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="wasteCount">0</div>
                    <div class="stat-label">Ø§Ù„Ø°Ø¦Ø§Ø¨</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="coinsCount">0</div>
                    <div class="stat-label">Ø§Ù„Ø¹Ù…Ù„Ø§Øª</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="aggressiveCount">0</div>
                    <div class="stat-label">Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="beesCount">0</div>
                    <div class="stat-label">Ø§Ù„Ù†Ø­Ù„</div>
                </div>
            </div>
        </div>
        <div class="scene-container">
            <canvas id="gameScene"></canvas>
            <div class="score-display" id="scoreDisplay">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
            <div class="coins-display" id="coinsDisplay">Ø§Ù„Ø¹Ù…Ù„Ø§Øª: 0</div>
            <div class="sheep-display" id="sheepDisplay">Ø§Ù„Ø®Ø±Ø§Ù: 0/5</div>
            <div class="bombs-display" id="bombsDisplay">Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„: 0</div>
            <div class="health-indicator" id="healthIndicator">
                <div class="health-bar" id="healthBar"></div>
            </div>
            <div class="round-indicator" id="roundIndicator">Ø§Ù„Ø¬ÙˆÙ„Ø©: 1</div>
            <button class="next-round-btn" id="nextRoundBtn">Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©</button>
            <!-- Ø´Ø±ÙŠØ· Ø´Ø­Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯ -->
            <div class="bomb-charge-indicator" id="bombChargeIndicator">
                <div class="bomb-charge-bar" id="bombChargeBar"></div>
            </div>
            <!-- Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© - ØªÙ… ØªØ­Ø³ÙŠÙ†Ù‡Ø§ -->
            <div class="movement-controls" id="movementControls">
                <div class="joystick-container">
                    <div class="joystick-base" id="joystickBase"></div>
                    <div class="joystick-handle" id="joystickHandle"></div>
                </div>
            </div>
            <div class="game-ui">
                <div class="ui-button jump-btn" id="jumpBtn">â†Ÿ</div>
                <!-- Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: ÙˆØ¶Ø¹ Ø²Ø± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© ÙÙˆÙ‚ Ø²Ø± Ø§Ù„Ø¹ØµØ§ -->
                <div class="ui-button bomb-btn" id="bombBtn">ğŸ’£</div>
                <div class="ui-button" id="attackBtn">ğŸª„</div>
            </div>
            <div class="game-over" id="gameOverPanel">
                <h2>Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!</h2>
                <p>Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: <span id="finalScore">0</span></p>
                <p>Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: <span id="finalCoins">0</span></p>
                <button class="restart-btn" id="restartBtn">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨</button>
            </div>
        </div>
    </div>
    <div class="question-panel" id="questionPanel">
        <h2>Ø³Ø¤Ø§Ù„ Ø±ÙŠØ§Ø¶ÙŠ!</h2>
        <p id="questionText">Ù…Ø§ Ø§Ù„Ø­Ø¯ Ø§Ù„ØªØ§Ù„ÙŠ ÙÙŠ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ© Ø§Ù„Ø¢ØªÙŠØ©ØŸ</p>
        <div id="sequenceContainer" class="sequence-container">
            <span class="sequence-item">2</span>
            <span class="sequence-item">ØŒ </span>
            <span class="sequence-item">4</span>
            <span class="sequence-item">ØŒ </span>
            <span class="sequence-item">8</span>
            <span class="sequence-item">ØŒ </span>
            <span class="sequence-item">16</span>
            <span class="sequence-item">ØŒ </span>
            <span class="sequence-item">...</span>
        </div>
        <div class="options-container" id="optionsContainer"></div>
    </div>
    <script>
        // Audio context for sound generation
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // The core function to generate and play sounds
        function playSound(
            frequency,
            type = "sine",
            duration = 0.1,
            volume = 0.3
        ) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Set sound properties
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;

            // Play the sound
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Sound effect for monster attack
        function playMonsterAttackSound() {
            const now = audioContext.currentTime;
            const duration = 0.3;
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(
                1,
                bufferSize,
                audioContext.sampleRate
            );
            const output = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            const gainNode = audioContext.createGain();
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            gainNode.gain.setValueAtTime(0.5, now);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);

            source.start(now);
        }

        // NEW: Sound effect for a stick attack
        function playStickSound() {
            // Part 1: Sharp, immediate hit sound
            const hitOscillator = audioContext.createOscillator();
            const hitGain = audioContext.createGain();
            hitOscillator.connect(hitGain);
            hitGain.connect(audioContext.destination);

            hitOscillator.type = "sawtooth"; // A sharp, rich-in-harmonics waveform
            hitOscillator.frequency.setValueAtTime(400, audioContext.currentTime); // High frequency for a sharp sound
            hitGain.gain.setValueAtTime(0.7, audioContext.currentTime);
            hitGain.gain.exponentialRampToValueAtTime(
                0.001,
                audioContext.currentTime + 0.1
            );

            hitOscillator.start(audioContext.currentTime);
            hitOscillator.stop(audioContext.currentTime + 0.1);

            // Part 2: Low-frequency "thump" sound after a small delay
            const thumpOscillator = audioContext.createOscillator();
            const thumpGain = audioContext.createGain();
            thumpOscillator.connect(thumpGain);
            thumpGain.connect(audioContext.destination);

            thumpOscillator.type = "sawtooth";
            thumpOscillator.frequency.setValueAtTime(
                100,
                audioContext.currentTime + 0.05
            ); // Lower frequency
            thumpGain.gain.setValueAtTime(0.4, audioContext.currentTime + 0.05);
            thumpGain.gain.exponentialRampToValueAtTime(
                0.001,
                audioContext.currentTime + 0.2
            );

            thumpOscillator.start(audioContext.currentTime + 0.05);
            thumpOscillator.stop(audioContext.currentTime + 0.2);
        }

        // Sound effect for monster explosion
        function playMonsterExplosionSound() {
            const now = audioContext.currentTime;
            const duration = 0.5;

            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);

            oscillator1.type = "sawtooth";
            oscillator1.frequency.value = 60;
            gainNode1.gain.setValueAtTime(0.5, now);
            gainNode1.gain.exponentialRampToValueAtTime(0.001, now + duration);

            oscillator1.start(now);
            oscillator1.stop(now + duration);

            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);

            oscillator2.type = "square";
            oscillator2.frequency.value = 1000;
            gainNode2.gain.setValueAtTime(0.3, now);
            gainNode2.gain.exponentialRampToValueAtTime(0.001, now + duration);

            oscillator2.start(now);
            oscillator2.stop(now + duration);
        }

        // Sound effect for collecting a coin
        function playCoinSound() {
            playSound(880, "triangle", 0.1, 0.2);
        }

        // Sound effect for collecting a sheep
        function playSheepSound() {
            playSound(440, "sine", 0.2, 0.3);
            setTimeout(() => playSound(550, "sine", 0.2, 0.3), 100);
            setTimeout(() => playSound(660, "sine", 0.2, 0.3), 200);
        }

        // Sound effect for reaching a box
        function playBoxSound() {
            playSound(440, "sine", 0.1, 0.3);
            setTimeout(() => playSound(660, "sine", 0.1, 0.3), 100);
        }

        // Sound effect for getting a gift
        function playGiftSound() {
            playSound(523, "sine", 0.1, 0.3);
            setTimeout(() => playSound(659, "sine", 0.1, 0.3), 100);
            setTimeout(() => playSound(784, "sine", 0.1, 0.3), 200);
        }

        // Sound effect for jumping
        function playJumpSound() {
            playSound(500, "sine", 0.2, 0.3);
        }

        // Sound effect for player damage
        function playDamageSound() {
            playSound(150, "sawtooth", 0.3, 0.5);
            setTimeout(() => playSound(100, "sawtooth", 0.2, 0.4), 100);
        }

        // Sound effect for bomb explosion - ØªÙ… ØªØ­Ø³ÙŠÙ†Ù‡ Ù„ÙŠÙƒÙˆÙ† Ø£ÙƒØ«Ø± Ù‚ÙˆØ©
        function playBombSound() {
            // Low frequency explosion sound - Ø£ÙƒØ«Ø± Ù‚ÙˆØ©
            const explosionOscillator = audioContext.createOscillator();
            const explosionGain = audioContext.createGain();
            explosionOscillator.connect(explosionGain);
            explosionGain.connect(audioContext.destination);

            explosionOscillator.type = "sawtooth";
            explosionOscillator.frequency.setValueAtTime(40, audioContext.currentTime); // ØªØ±Ø¯Ø¯ Ø£Ù‚Ù„ Ù„Ø§Ù†ÙØ¬Ø§Ø± Ø£Ù‚ÙˆÙ‰
            explosionGain.gain.setValueAtTime(1.0, audioContext.currentTime); // Ø²ÙŠØ§Ø¯Ø© Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª
            explosionGain.gain.exponentialRampToValueAtTime(
                0.001,
                audioContext.currentTime + 1.5 // Ø²ÙŠØ§Ø¯Ø© Ù…Ø¯Ø© Ø§Ù„ØµÙˆØª
            );

            explosionOscillator.start(audioContext.currentTime);
            explosionOscillator.stop(audioContext.currentTime + 1.5);

            // High frequency shrapnel sound - Ø£ÙƒØ«Ø± Ù‚ÙˆØ©
            const shrapnelOscillator = audioContext.createOscillator();
            const shrapnelGain = audioContext.createGain();
            shrapnelOscillator.connect(shrapnelGain);
            shrapnelGain.connect(audioContext.destination);

            shrapnelOscillator.type = "square";
            shrapnelOscillator.frequency.setValueAtTime(1200, audioContext.currentTime); // ØªØ±Ø¯Ø¯ Ø£Ø¹Ù„Ù‰
            shrapnelOscillator.frequency.exponentialRampToValueAtTime(
                300,
                audioContext.currentTime + 0.7
            );
            shrapnelGain.gain.setValueAtTime(0.7, audioContext.currentTime); // Ø²ÙŠØ§Ø¯Ø© Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª
            shrapnelGain.gain.exponentialRampToValueAtTime(
                0.001,
                audioContext.currentTime + 0.7
            );

            shrapnelOscillator.start(audioContext.currentTime);
            shrapnelOscillator.stop(audioContext.currentTime + 0.7);

            // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø§Ù‡ØªØ²Ø§Ø² Ø¥Ø¶Ø§ÙÙŠ
            const rumbleOscillator = audioContext.createOscillator();
            const rumbleGain = audioContext.createGain();
            rumbleOscillator.connect(rumbleGain);
            rumbleGain.connect(audioContext.destination);

            rumbleOscillator.type = "sine";
            rumbleOscillator.frequency.setValueAtTime(30, audioContext.currentTime);
            rumbleGain.gain.setValueAtTime(0.4, audioContext.currentTime);
            rumbleGain.gain.exponentialRampToValueAtTime(
                0.001,
                audioContext.currentTime + 1.0
            );

            rumbleOscillator.start(audioContext.currentTime);
            rumbleOscillator.stop(audioContext.currentTime + 1.0);
        }

        // Ø¯Ø§Ù„Ø© Ø¥Ù†Ø´Ø§Ø¡ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø¹ Ø§Ù„Ø¹ØµØ§ ÙˆØ§Ù„Ø£Ø°Ø±Ø¹ ÙˆØ§Ù„Ø£Ø±Ø¬Ù„ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
        function createPlayerModel() {
            const playerGroup = new THREE.Group();

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø³Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ (Ø§Ù„Ø¬Ø°Ø¹)
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x4169e1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            playerGroup.add(body);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ù‚Ø¨Ø©
            const neckGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 16);
            const neckMaterial = new THREE.MeshStandardMaterial({
                color: 0xffdbac
            });
            const neck = new THREE.Mesh(neckGeometry, neckMaterial);
            neck.position.y = 0.7;
            body.add(neck);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø£Ø³
            const headGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xffdbac,
                roughness: 0.8,
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.2;
            neck.add(head);

            // Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ù…Ø­ Ø§Ù„ÙˆØ¬Ù‡ - ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¹ÙŠÙˆÙ†
            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.12, 0.05, 0.28);
            head.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.12, 0.05, 0.28);
            head.add(rightEye);

            // Ø¥Ø¶Ø§ÙØ© Ø¨Ø¤Ø¨Ø¤ Ø§Ù„Ø¹ÙŠÙ†
            const pupilGeometry = new THREE.SphereGeometry(0.04, 16, 16);
            const pupilMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(0, 0, 0.06);
            leftEye.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0, 0, 0.06);
            rightEye.add(rightPupil);

            const mouthGeometry = new THREE.TorusGeometry(
                0.1,
                0.02,
                16,
                100,
                Math.PI
            );
            const mouthMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4d4d
            });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, -0.1, 0.25);
            mouth.rotation.x = Math.PI / 2;
            head.add(mouth);

            // Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø¨Ø¹Ø©
            const hatMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513
            });

            // ØªØ§Ø¬ Ø§Ù„Ù‚Ø¨Ø¹Ø©
            const hatCrownGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.2, 16);
            const hatCrown = new THREE.Mesh(hatCrownGeometry, hatMaterial);
            hatCrown.position.y = 0.3;
            head.add(hatCrown);

            // Ø­Ø§ÙØ© Ø§Ù„Ù‚Ø¨Ø¹Ø©
            const hatBrimGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 32);
            const hatBrim = new THREE.Mesh(hatBrimGeometry, hatMaterial);
            hatBrim.position.y = 0.2;
            head.add(hatBrim);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø°Ø±Ø¹ (Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù…Ù†ÙØµÙ„Ø© Ù„ØªØ³Ù‡ÙŠÙ„ Ø§Ù„Ø­Ø±ÙƒØ©) - ØªÙ… Ø®ÙØ¶ Ø§Ù„ÙŠØ¯ÙŠÙ†
            const leftArmGroup = new THREE.Group();
            leftArmGroup.position.set(-0.6, 0.3, 0); // ØªÙ… Ø®ÙØ¶ Ø§Ù„ÙŠØ¯ÙŠÙ†
            body.add(leftArmGroup);

            const rightArmGroup = new THREE.Group();
            rightArmGroup.position.set(0.6, 0.3, 0); // ØªÙ… Ø®ÙØ¶ Ø§Ù„ÙŠØ¯ÙŠÙ†
            body.add(rightArmGroup);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© Ø§Ù„Ø£Ø°Ø±Ø¹
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 16);
            const armMaterial = new THREE.MeshStandardMaterial({
                color: 0x4169e1
            });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.rotation.z = Math.PI / 4;
            leftArmGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.rotation.z = -Math.PI / 4;
            rightArmGroup.add(rightArm);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£ÙŠØ¯ÙŠ
            const handGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const handMaterial = new THREE.MeshStandardMaterial({
                color: 0xffdbac
            });
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(0, 0.4, 0);
            leftArm.add(leftHand);

            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(0, 0.4, 0);
            rightArm.add(rightHand);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø±Ø¬Ù„ (Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù…Ù†ÙØµÙ„Ø© Ù„ØªØ³Ù‡ÙŠÙ„ Ø§Ù„Ø­Ø±ÙƒØ©) - ØªÙ… ØªÙˆØµÙŠÙ„ Ø§Ù„Ø£Ù‚Ø¯Ø§Ù… Ø¨Ø§Ù„ÙƒØ§Ø­Ù„
            const leftLegGroup = new THREE.Group();
            leftLegGroup.position.set(-0.2, -0.6, 0);
            body.add(leftLegGroup);

            const rightLegGroup = new THREE.Group();
            rightLegGroup.position.set(0.2, -0.6, 0);
            body.add(rightLegGroup);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© Ø§Ù„Ø£Ø±Ø¬Ù„ - ØªÙ… ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙˆØµÙŠÙ„ Ø¨Ø§Ù„ÙƒØ§Ø­Ù„
            const legGeometry = new THREE.CylinderGeometry(0.12, 0.12, 1.0, 16); // Ø£Ø±Ø¬Ù„ Ø£Ù‚ØµØ± Ù‚Ù„ÙŠÙ„Ø§Ù‹
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x00008b
            });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.y = -0.5; // ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø±Ø¬Ù„
            leftLegGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.y = -0.5; // ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø±Ø¬Ù„
            rightLegGroup.add(rightLeg);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø­Ø°ÙŠØ© - Ù…ØªØµÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø§Ù„ÙƒØ§Ø­Ù„
            const shoeGeometry = new THREE.BoxGeometry(0.25, 0.15, 0.3);
            const shoeMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333
            });
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.y = -0.6; // Ù…ØªØµÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø§Ù„ÙƒØ§Ø­Ù„
            leftLeg.add(leftShoe);

            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.y = -0.6; // Ù…ØªØµÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø§Ù„ÙƒØ§Ø­Ù„
            rightLeg.add(rightShoe);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¹ØµØ§
            const stickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3.5, 8);
            const stickMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513
            });
            const stick = new THREE.Mesh(stickGeometry, stickMaterial);
            stick.position.set(0, 0, 1.75);
            stick.rotation.x = Math.PI / 2;
            leftHand.add(stick);

            // ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨
            playerGroup.scale.set(1, 1, 1);
            playerGroup.position.y = 1; // Ø±ÙØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¹Ù† Ø§Ù„Ø£Ø±Ø¶

            // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹ Ù„Ù„Ø­Ø±ÙƒØ©
            playerGroup.userData = {
                leftArm: leftArmGroup,
                rightArm: rightArmGroup,
                leftLeg: leftLegGroup,
                rightLeg: rightLegGroup,
                stick: stick,
                isAttacking: false,
                attackProgress: 0,
                walkCycle: 0,
            };

            return playerGroup;
        }

        // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø£Ø°Ø±Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø´ÙŠ
        function animateWalking(playerModel, deltaTime) {
            if (!playerModel.userData) return;

            const { leftArm, rightArm } = playerModel.userData;
            const walkSpeed = 5;

            // ØªØ­Ø¯ÙŠØ« Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø´ÙŠ
            playerModel.userData.walkCycle += deltaTime * walkSpeed;

            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø£Ø°Ø±Ø¹ Ù„Ù„Ù…Ø´ÙŠ
            const armSwing = Math.sin(playerModel.userData.walkCycle) * 0.3;
            leftArm.rotation.z = Math.PI / 4 + armSwing;
            rightArm.rotation.z = -Math.PI / 4 - armSwing;
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø£Ø±Ø¬Ù„ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø´ÙŠ
        function animateLegs(playerModel, deltaTime) {
            if (!playerModel.userData) return;

            const { leftLeg, rightLeg } = playerModel.userData;
            const walkSpeed = 5;

            playerModel.userData.walkCycle += deltaTime * walkSpeed;

            const legSwing = Math.sin(playerModel.userData.walkCycle) * 0.5;
            leftLeg.rotation.x = legSwing;
            rightLeg.rotation.x = -legSwing;
        }

        // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¹ØµØ§ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù‡Ø¬ÙˆÙ…
        function animateStickAttack(playerModel, deltaTime) {
            if (!playerModel.userData || !playerModel.userData.isAttacking) return;

            const { leftArm, stick, attackProgress } = playerModel.userData;

            // ØªØ­Ø¯ÙŠØ« ØªÙ‚Ø¯Ù… Ø§Ù„Ù‡Ø¬ÙˆÙ…
            playerModel.userData.attackProgress += deltaTime * 10;

            if (playerModel.userData.attackProgress < 1) {
                // Ø§Ù„ØªØ£Ø±Ø¬Ø­ Ù„Ù„Ø£Ù…Ø§Ù…
                const swingAngle = (Math.sin(playerModel.userData.attackProgress * Math.PI) * Math.PI) / 1.5;
                leftArm.rotation.z = Math.PI / 4 + swingAngle;

                // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¹ØµØ§ Ù…Ø¹ Ø§Ù„ÙŠØ¯
                if (stick) {
                    stick.rotation.x = Math.PI / 2 + swingAngle * 0.5;
                }
            } else {
                // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø· Ø¨Ø¹Ø¯ Ø§Ù„Ù‡Ø¬ÙˆÙ…
                playerModel.userData.isAttacking = false;
                playerModel.userData.attackProgress = 0;
                leftArm.rotation.z = Math.PI / 4;
                if (stick) {
                    stick.rotation.x = Math.PI / 2;
                }
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„ØªÙØ¹ÙŠÙ„ Ø­Ø±ÙƒØ© Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø¹ØµØ§
        function triggerStickAttack(playerModel) {
            if (playerModel.userData) {
                playerModel.userData.isAttacking = true;
                playerModel.userData.attackProgress = 0;
            }
        }

        // ØªÙ‡ÙŠØ¦Ø© Ù…Ø´Ù‡Ø¯ Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0xadd8e6, 50, 800);

        const canvas = document.getElementById("gameScene");
        const renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true
        });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);

        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ù„Ø§Ø¹Ø¨ (ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ÙˆØ§Ù„ÙƒØ§Ù…ÙŠØ±Ø§)
        const player = new THREE.Group();
        scene.add(player);

        // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø¹ Ø§Ù„Ø¹ØµØ§ ÙˆØ¥Ø¶Ø§ÙØªÙ‡ Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨
        const playerModel = createPlayerModel();
        player.add(playerModel);

        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¨Ù…Ù†Ø¸ÙˆØ± Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ø«Ø§Ù„Ø« - ØªÙ… ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const camera = new THREE.PerspectiveCamera(
            70, // Ø²ÙŠØ§Ø¯Ø© Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø±Ø¤ÙŠØ©
            canvas.clientWidth / canvas.clientHeight,
            0.1,
            1000
        );
        camera.position.set(0, 6, 10); // ØªØ¹Ø¯ÙŠÙ„ Ù…ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        scene.add(camera);

        // Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(100, 200, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        scene.add(sunLight);

        // Ø¥Ø¶Ø§ÙØ© Ø¥Ø¶Ø§Ø¡Ø© Ø¥Ø¶Ø§ÙÙŠØ© Ù„ØªØ³Ù„ÙŠØ· Ø§Ù„Ø¶ÙˆØ¡ Ø¹Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨
        const playerLight = new THREE.DirectionalLight(0xfff0c0, 0.5);
        playerLight.position.set(0, 10, 0);
        player.add(playerLight);

        // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø±Ø¶ÙŠØ©
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x4caf50,
            roughness: 0.9,
            metalness: 0.1,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù… Ù„Ù…Ù†Ø¹ Ø®Ø±ÙˆØ¬ Ø§Ù„Ù„Ø§Ø¹Ø¨ - ØªÙ… ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†Ø¸Ø§Ù…
        const worldBounds = {
            minX: -450,
            maxX: 450,
            minZ: -450,
            maxZ: 450,
            buffer: 30, // Ø²ÙŠØ§Ø¯Ø© Ù…Ø³Ø§ÙØ© Ø§Ù„ØªØ­Ø°ÙŠØ±
        };

        // ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¹Ø§Ù„Ù… Ø¥Ù„Ù‰ Ø£Ø±Ø¨Ø¹Ø© Ø£Ø±Ø¨Ø§Ø¹
        const quarters = [
            { minX: -450, maxX: 0, minZ: -450, maxZ: 0 }, // Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø£ÙˆÙ„: Ø§Ù„Ø´Ù…Ø§Ù„ Ø§Ù„ØºØ±Ø¨ÙŠ
            { minX: 0, maxX: 450, minZ: -450, maxZ: 0 },  // Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø«Ø§Ù†ÙŠ: Ø§Ù„Ø´Ù…Ø§Ù„ Ø§Ù„Ø´Ø±Ù‚ÙŠ
            { minX: -450, maxX: 0, minZ: 0, maxZ: 450 },  // Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø«Ø§Ù„Ø«: Ø§Ù„Ø¬Ù†ÙˆØ¨ Ø§Ù„ØºØ±Ø¨ÙŠ
            { minX: 0, maxX: 450, minZ: 0, maxZ: 450 }    // Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø±Ø§Ø¨Ø¹: Ø§Ù„Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø´Ø±Ù‚ÙŠ
        ];

        // Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø¯ÙˆØ¯ Ù…Ø±Ø¦ÙŠØ© Ù„Ù„Ø¹Ø§Ù„Ù…
        function createWorldBoundsVisual() {
            const boundsGeometry = new THREE.BoxGeometry(
                worldBounds.maxX - worldBounds.minX,
                1,
                worldBounds.maxZ - worldBounds.minZ
            );
            const boundsMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true,
                transparent: true,
                opacity: 0.1,
            });
            const bounds = new THREE.Mesh(boundsGeometry, boundsMaterial);
            bounds.position.set(
                (worldBounds.maxX + worldBounds.minX) / 2,
                -0.5,
                (worldBounds.maxZ + worldBounds.minZ) / 2
            );
            scene.add(bounds);
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù… - ØªÙ… ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†Ø¸Ø§Ù…
        function checkWorldBounds(position) {
            const warningElement = document.getElementById("worldBoundaryWarning");
            let isNearBoundary = false;

            if (position.x < worldBounds.minX + worldBounds.buffer) {
                position.x = worldBounds.minX + worldBounds.buffer;
                isNearBoundary = true;
            }
            if (position.x > worldBounds.maxX - worldBounds.buffer) {
                position.x = worldBounds.maxX - worldBounds.buffer;
                isNearBoundary = true;
            }
            if (position.z < worldBounds.minZ + worldBounds.buffer) {
                position.z = worldBounds.minZ + worldBounds.buffer;
                isNearBoundary = true;
            }
            if (position.z > worldBounds.maxZ - worldBounds.buffer) {
                position.z = worldBounds.maxZ - worldBounds.buffer;
                isNearBoundary = true;
            }

            if (isNearBoundary) {
                warningElement.style.display = "block";
            } else {
                warningElement.style.display = "none";
            }

            return position;
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø°Ø¦Ø¨ Ù…ÙØµÙ„ Ù…Ø¹ Ø£Ø±Ø¬Ù„ Ù…ØªØ­Ø±ÙƒØ©
        function createDetailedWolf(x, z, type) {
            const wolfGroup = new THREE.Group();
            
            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ø°Ø¦Ø¨
            let furMain, furLight, furHighlight;
            let scaleFactor = 1;
            
            switch(type) {
                case 'giant':
                    furMain = 0x990000;
                    furLight = 0xbb3333;
                    furHighlight = 0xff6666;
                    scaleFactor = 1.5;
                    break;
                case 'aggressive':
                    furMain = 0x8b4513;
                    furLight = 0xa0522d;
                    furHighlight = 0xd2691e;
                    scaleFactor = 0.96; // ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: ØªØµØºÙŠØ± Ø¨Ù†Ø³Ø¨Ø© 20% (1.2 Ã— 0.8 = 0.96)
                    break;
                case 'strong':
                    furMain = 0x2f4f4f;
                    furLight = 0x4f6f6f;
                    furHighlight = 0x6f8f8f;
                    scaleFactor = 1.1;
                    break;
                case 'fast':
                    furMain = 0x696969;
                    furLight = 0x808080;
                    furHighlight = 0x999999;
                    scaleFactor = 0.9;
                    break;
                case 'normal':
                default:
                    furMain = 0x505050;
                    furLight = 0x777777;
                    furHighlight = 0x999999;
                    scaleFactor = 0.77; // ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: ØªÙƒØ¨ÙŠØ± Ø¨Ù†Ø³Ø¨Ø© 10% (0.7 Ã— 1.1 = 0.77)
            }
            
            // Ø§Ù„Ù…ÙˆØ§Ø¯
            const matBody = new THREE.MeshStandardMaterial({ 
                color: furMain, 
                flatShading: true,
                roughness: 0.8 
            });
            const matLight = new THREE.MeshStandardMaterial({ 
                color: furLight, 
                flatShading: true,
                roughness: 0.8 
            });
            const matHighlight = new THREE.MeshStandardMaterial({ 
                color: furHighlight, 
                flatShading: true,
                roughness: 0.8 
            });

            // 1. Ø§Ù„Ø¬Ø³Ø¯
            // Ø§Ù„ØµØ¯Ø±
            const chestGeom = new THREE.DodecahedronGeometry(1.4 * scaleFactor);
            chestGeom.scale(1, 1.1, 1.4);
            const chest = new THREE.Mesh(chestGeom, matBody);
            chest.position.y = 2.8 * scaleFactor;
            wolfGroup.add(chest);

            // Ø§Ù„Ø¨Ø·Ù†
            const bellyGeom = new THREE.DodecahedronGeometry(1.1 * scaleFactor);
            bellyGeom.scale(0.9, 1, 1.3);
            const belly = new THREE.Mesh(bellyGeom, matLight);
            belly.position.set(0, 2.9 * scaleFactor, -1.8 * scaleFactor);
            wolfGroup.add(belly);

            // 2. Ø§Ù„Ø±Ø£Ø³
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 4.2 * scaleFactor, 1.8 * scaleFactor);

            // Ø§Ù„Ø¬Ù…Ø¬Ù…Ø©
            const skull = new THREE.Mesh(new THREE.BoxGeometry(1.2 * scaleFactor, 1.2 * scaleFactor, 1.4 * scaleFactor), matBody);
            headGroup.add(skull);

            // Ø§Ù„Ø£Ù†Ù
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.7 * scaleFactor, 0.7 * scaleFactor, 1.2 * scaleFactor), matLight);
            snout.position.set(0, -0.1 * scaleFactor, 1.1 * scaleFactor);
            headGroup.add(snout);

            // Ø·Ø±Ù Ø§Ù„Ø£Ù†Ù
            const noseTip = new THREE.Mesh(new THREE.BoxGeometry(0.3 * scaleFactor, 0.2 * scaleFactor, 0.2 * scaleFactor), 
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a, flatShading: true }));
            noseTip.position.set(0, 0.2 * scaleFactor, 1.7 * scaleFactor);
            headGroup.add(noseTip);

            // Ø§Ù„ÙÙƒ Ø§Ù„Ø³ÙÙ„ÙŠ
            const jawGroup = new THREE.Group();
            jawGroup.position.set(0, -0.4 * scaleFactor, 0.8 * scaleFactor);
            const jawMesh = new THREE.Mesh(new THREE.BoxGeometry(0.6 * scaleFactor, 0.3 * scaleFactor, 1.0 * scaleFactor), matLight);
            jawGroup.add(jawMesh);
            headGroup.add(jawGroup);

            // Ø§Ù„Ø£Ø°Ù†ÙŠÙ†
            const earGeo = new THREE.ConeGeometry(0.3 * scaleFactor, 0.8 * scaleFactor, 4);
            const earL = new THREE.Mesh(earGeo, matBody);
            earL.position.set(0.4 * scaleFactor, 0.8 * scaleFactor, -0.3 * scaleFactor);
            earL.rotation.set(-0.2, 0, -0.2);
            headGroup.add(earL);

            const earR = new THREE.Mesh(earGeo, matBody);
            earR.position.set(-0.4 * scaleFactor, 0.8 * scaleFactor, -0.3 * scaleFactor);
            earR.rotation.set(-0.2, 0, 0.2);
            headGroup.add(earR);

            // Ø§Ù„Ø¹ÙŠÙˆÙ†
            const eyeGeo = new THREE.BoxGeometry(0.1 * scaleFactor, 0.15 * scaleFactor, 0.05 * scaleFactor);
            const eyeMat = new THREE.MeshStandardMaterial({ 
                color: 0xffaa00, 
                emissive: 0xffaa00, 
                emissiveIntensity: 0.5 
            });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(0.35 * scaleFactor, 0.2 * scaleFactor, 0.7 * scaleFactor);
            eyeR.position.set(-0.35 * scaleFactor, 0.2 * scaleFactor, 0.7 * scaleFactor);
            headGroup.add(eyeL);
            headGroup.add(eyeR);

            wolfGroup.add(headGroup);

            // 3. Ø§Ù„Ø°ÙŠÙ„
            const tailGroup = new THREE.Group();
            tailGroup.position.set(0, 3.2 * scaleFactor, -2.5 * scaleFactor);
            
            // Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°ÙŠÙ„
            const tailBase = new THREE.Mesh(new THREE.CylinderGeometry(0.2 * scaleFactor, 0.5 * scaleFactor, 1.5 * scaleFactor, 5), matBody);
            tailBase.position.set(0, -0.5 * scaleFactor, -0.5 * scaleFactor);
            tailBase.rotation.x = -0.8;
            tailGroup.add(tailBase);
            
            // Ø·Ø±Ù Ø§Ù„Ø°ÙŠÙ„
            const tailTip = new THREE.Mesh(new THREE.ConeGeometry(0.4 * scaleFactor, 1.5 * scaleFactor, 5), matHighlight);
            tailTip.position.set(0, -1.5 * scaleFactor, -1.0 * scaleFactor);
            tailTip.rotation.x = -0.5;
            tailGroup.add(tailTip);
            
            wolfGroup.add(tailGroup);

            // 4. Ø§Ù„Ø£Ø±Ø¬Ù„ (Ù…ØªØ¶Ù…Ù†Ø© ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ù„Ø¥Ø´Ø§Ø±Ø© Ø¥Ù„ÙŠÙ‡Ø§ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ù„Ù„ØªØ­Ø±ÙŠÙƒ)
            const legs = [];
            
            function createLeg(x, z, isBack) {
                const legGroup = new THREE.Group();
                legGroup.position.set(x, 2.8 * scaleFactor, z);

                // Ø§Ù„ÙØ®Ø°
                const thighH = isBack ? 1.4 : 1.2;
                const thigh = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.35 * scaleFactor, 0.5 * scaleFactor, thighH * scaleFactor, 5), 
                    matBody
                );
                thigh.position.set(0, -thighH * scaleFactor / 2, 0);
                thigh.rotation.x = isBack ? 0.3 : -0.1;
                legGroup.add(thigh);

                // Ø§Ù„Ø³Ø§Ù‚ Ø§Ù„Ø³ÙÙ„ÙŠØ©
                const shinH = 1.0;
                const shin = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2 * scaleFactor, 0.3 * scaleFactor, shinH * scaleFactor, 4), 
                    matLight
                );
                shin.position.set(0, -thighH * scaleFactor - shinH * scaleFactor / 2 + 0.1 * scaleFactor, 
                                  isBack ? -0.3 * scaleFactor : 0.1 * scaleFactor);
                shin.rotation.x = isBack ? -0.5 : 0.1;
                legGroup.add(shin);

                // Ø§Ù„Ù‚Ø¯Ù…
                const paw = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4 * scaleFactor, 0.3 * scaleFactor, 0.5 * scaleFactor), 
                    matBody
                );
                paw.position.set(0, -thighH * scaleFactor - shinH * scaleFactor - 0.1 * scaleFactor, 
                                 isBack ? -0.5 * scaleFactor : 0.2 * scaleFactor);
                legGroup.add(paw);

                wolfGroup.add(legGroup);
                return legGroup;
            }

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø±Ø¬Ù„ Ø§Ù„Ø£Ø±Ø¨Ø¹Ø©
            legs.push(createLeg(0.6 * scaleFactor, 0.5 * scaleFactor, false));  // Front L
            legs.push(createLeg(-0.6 * scaleFactor, 0.5 * scaleFactor, false)); // Front R
            legs.push(createLeg(0.6 * scaleFactor, -2.0 * scaleFactor, true));  // Back L
            legs.push(createLeg(-0.6 * scaleFactor, -2.0 * scaleFactor, true)); // Back R

            // ØªØ®Ø²ÙŠÙ† Ù…Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø£Ø±Ø¬Ù„ Ù„Ù„ØªØ­Ø±ÙŠÙƒ Ù„Ø§Ø­Ù‚Ø§Ù‹
            wolfGroup.userData.legs = legs;
            wolfGroup.userData.head = headGroup;
            wolfGroup.userData.jaw = jawGroup;
            wolfGroup.userData.tail = tailGroup;
            wolfGroup.userData.walkCycle = 0;
            wolfGroup.userData.earL = earL;
            wolfGroup.userData.earR = earR;

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ­Ø¬ÙŠÙ… Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
            wolfGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
            
            // ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø°Ø¦Ø¨ - Ø§Ù„ØªØµØ­ÙŠØ­ Ù‡Ù†Ø§: Ø§Ù„Ø°Ø¦Ø§Ø¨ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© ÙˆØ§Ù„Ø´Ø±Ø³Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø±Ø¶ØŒ Ø§Ù„Ø¹Ù…Ù„Ø§Ù‚Ø© ØªØ±ØªÙØ¹ Ù‚Ù„ÙŠÙ„Ø§Ù‹
            wolfGroup.position.set(x, type === 'giant' ? 4 * scaleFactor : 0, z);
            
            // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø®Ø§Øµ Ù„Ù„Ø°Ø¦Ø§Ø¨ Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©
            if (type === 'aggressive') {
                const glowGeometry = new THREE.SphereGeometry(2.5 * scaleFactor, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: furMain,
                    transparent: true,
                    opacity: 0.3,
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                wolfGroup.add(glow);
            }

            return wolfGroup;
        }

        // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø±ÙŠÙƒ Ø£Ø±Ø¬Ù„ Ø§Ù„Ø°Ø¦Ø¨
        function animateWolfLegs(wolf, deltaTime) {
            if (!wolf.userData.legs) return;
            
            const legs = wolf.userData.legs;
            const isChasing = wolf.userData.isChasing || false;
            
            // Ø²ÙŠØ§Ø¯Ø© Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø´ÙŠ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø°Ø¦Ø¨ ÙŠØªØ­Ø±Ùƒ
            if (isChasing && wolf.userData.speed > 0) {
                wolf.userData.walkCycle += deltaTime * wolf.userData.speed * 10;
            }
            
            const walkSpeed = isChasing ? 8 : 4;
            const legSwing = Math.sin(wolf.userData.walkCycle * walkSpeed) * 0.3;
            
            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø£Ø±Ø¬Ù„ Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© ÙˆØ§Ù„Ø®Ù„ÙÙŠØ© Ø¨Ø´ÙƒÙ„ Ù…Ø¹Ø§ÙƒØ³
            // Ø§Ù„Ø£Ø±Ø¬Ù„ Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ©
            if (legs[0]) legs[0].rotation.x = legSwing;
            if (legs[1]) legs[1].rotation.x = legSwing;
            
            // Ø§Ù„Ø£Ø±Ø¬Ù„ Ø§Ù„Ø®Ù„ÙÙŠØ© (Ù…Ø¹ÙƒÙˆØ³Ø©)
            if (legs[2]) legs[2].rotation.x = -legSwing;
            if (legs[3]) legs[3].rotation.x = -legSwing;
            
            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø°ÙŠÙ„ Ù‚Ù„ÙŠÙ„Ø§Ù‹
            if (wolf.userData.tail) {
                wolf.userData.tail.rotation.y = Math.sin(wolf.userData.walkCycle * 2) * 0.1;
            }
            
            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø£Ø°Ù†ÙŠÙ†
            if (wolf.userData.earL && wolf.userData.earR) {
                const earMove = Math.sin(wolf.userData.walkCycle * 4) * 0.1;
                wolf.userData.earL.rotation.z = -0.2 + earMove;
                wolf.userData.earR.rotation.z = 0.2 - earMove;
            }
        }

        // ØªØ¹Ø¯ÙŠÙ„ Ø¯Ø§Ù„Ø© createWolf Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°Ø¦Ø¨ Ø§Ù„Ù…ÙØµÙ„
        function createWolf(x, z, type, quarter) {
            const wolfGroup = createDetailedWolf(x, z, type);
            
            let health, value;
            const sizeFactor = 1 + (round - 1) * 0.5;
            const healthFactor = 1 + (round - 1) * 0.8;

            // ØªØ­Ø¯ÙŠØ¯ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø°Ø¦Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹Ù‡
            switch(type) {
                case 'giant':
                    health = 500;
                    value = 50;
                    break;
                case 'aggressive':
                    health = 150 * healthFactor;
                    value = 25;
                    break;
                case 'strong':
                    health = 120;
                    value = 15;
                    break;
                case 'fast':
                    health = 80;
                    value = 10;
                    break;
                case 'normal':
                default:
                    health = 30;
                    value = 5;
            }

            // ØªØ­Ø¯ÙŠØ¯ Ø³Ø±Ø¹Ø© Ø§Ù„Ø°Ø¦Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹Ù‡
            let baseSpeed;
            switch(type) {
                case 'aggressive':
                    baseSpeed = 0.12;
                    break;
                case 'fast':
                    baseSpeed = 0.08;
                    break;
                case 'normal':
                    baseSpeed = 0.1; // Ø³Ø±Ø¹Ø© Ù…ØªÙˆØ³Ø·Ø© Ù„Ù„Ø°Ø¦Ø¨ Ø§Ù„Ø¹Ø§Ø¯ÙŠ
                    break;
                default:
                    baseSpeed = 0.04;
            }

            // ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯Ù‰ Ø§Ù„ÙƒØ´Ù Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ø°Ø¦Ø¨
            let detectionRange;
            if (type === "aggressive") {
                detectionRange = 30;
            } else if (type === "normal") {
                detectionRange = 50; // ØªÙ‚Ù„ÙŠÙ„ Ù…Ø¯Ù‰ Ø§Ù„ÙƒØ´Ù Ù„Ù„Ø°Ø¦Ø§Ø¨ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
            } else {
                detectionRange = 0;
            }

            // Ø¥Ø¶Ø§ÙØ© Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø°Ø¦Ø¨
            wolfGroup.userData = {
                ...wolfGroup.userData,
                type,
                health,
                maxHealth: health,
                speed: baseSpeed,
                value,
                isAggressive: type === "aggressive" || type === "normal",
                isChasing: false,
                detectionRange: detectionRange,
                attackRange: (type === "aggressive" || type === "normal") ? 5 : 0,
                attackDamage: (type === "aggressive" || type === "normal") ? 10 : 0,
                lastAttackTime: 0,
                collisionDamage: type === "normal" ? 8 : (type === "aggressive" ? 15 : 5),
                lastCollisionTime: 0,
                collisionCooldown: 1000,
                isProtector: type === "aggressive",
                protectedSheep: null,
                guardRadius: 15,
                // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø°ÙŠ ÙŠÙ†ØªÙ…ÙŠ Ø¥Ù„ÙŠÙ‡ Ø§Ù„Ø°Ø¦Ø¨
                quarter: quarter,
                // Ø¥Ø¶Ø§ÙØ© Ù‡Ø¯Ù Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ù„Ø­Ø±ÙƒØ© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø±Ø¨Ø¹
                randomTarget: null,
                targetTimer: 0
            };

            scene.add(wolfGroup);
            return wolfGroup;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø£ØºÙ†Ø§Ù…
        function createSheep(x, y, z) {
            const sheepGroup = new THREE.Group();

            // Ø§Ù„Ù…Ø§Ø¯Ø© (Material)
            const woolMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff
            });
            const fleshMaterial = new THREE.MeshPhongMaterial({
                color: 0xf5deb3
            });
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000
            });
            const legMaterial = new THREE.MeshPhongMaterial({
                color: 0x4b4b4b
            });

            // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø®Ø±ÙˆÙ

            // Ø§Ù„Ø¬Ø³Ù… (Ø¨ÙŠØ¶Ø§ÙˆÙŠ)
            const bodyGeometry = new THREE.SphereGeometry(1.8, 32, 16);
            const body = new THREE.Mesh(bodyGeometry, woolMaterial);
            body.scale.set(0.7, 0.7, 1.1);
            body.castShadow = true;
            sheepGroup.add(body);

            // Ø§Ù„Ø°ÙŠÙ„ (ÙƒØ±Ø© Ø¨ÙŠØ¶Ø§Ø¡ Ù…Ø³Ø·Ø­Ø©)
            const tailGeometry = new THREE.SphereGeometry(0.3, 32, 16);
            const tail = new THREE.Mesh(tailGeometry, woolMaterial);
            tail.position.set(0, 0, -1.8);
            tail.scale.z = 0.5;
            tail.castShadow = true;
            body.add(tail);

            // Ø§Ù„Ø±Ø£Ø³ (Ø¨ÙŠØ¶Ø§ÙˆÙŠ ØºÙŠØ± Ù…ØªÙ†Ø§Ø³Ù‚)
            const headGeometry = new THREE.SphereGeometry(0.5, 32, 16);
            const head = new THREE.Mesh(headGeometry, fleshMaterial);
            head.position.set(0, 0.75, 1.4);
            head.scale.set(0.7, 1.2, 1.1);
            head.castShadow = true;
            body.add(head);

            // Ø§Ù„Ø£Ø°Ù†ÙŠÙ† (Ù…Ø«Ù„Ø«Ø§Øª)
            const earGeometry = new THREE.ConeGeometry(0.35, 0.35, 3);
            const leftEar = new THREE.Mesh(earGeometry, fleshMaterial);
            leftEar.position.set(-0.6, 0.4, 0);
            leftEar.rotation.z = Math.PI / 2;
            leftEar.rotation.y = Math.PI / 4;
            leftEar.castShadow = true;
            head.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, fleshMaterial);
            rightEar.position.set(0.6, 0.4, 0);
            rightEar.rotation.z = -Math.PI / 2;
            rightEar.rotation.y = -Math.PI / 4;
            rightEar.castShadow = true;
            head.add(rightEar);

            // Ø§Ù„Ø¹ÙŠÙˆÙ† (ÙƒØ±Ø§Øª)
            const eyeGeometry = new THREE.SphereGeometry(0.07, 32, 16);
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 0.25, 0.45);
            leftEye.castShadow = true;
            head.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 0.25, 0.45);
            rightEye.castShadow = true;
            head.add(rightEye);

            // Ø§Ù„Ø£Ø±Ø¬Ù„ (Ø£Ø³Ø·ÙˆØ§Ù†ÙŠØ© Ù†Ø­ÙŠÙØ©)
            const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.2);

            const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontLeftLeg.position.set(-0.7, -1.2, 1);
            frontLeftLeg.castShadow = true;
            body.add(frontLeftLeg);

            const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontRightLeg.position.set(0.7, -1.2, 1);
            frontRightLeg.castShadow = true;
            body.add(frontRightLeg);

            const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            backLeftLeg.position.set(-0.7, -1.2, -1);
            backLeftLeg.castShadow = true;
            body.add(backLeftLeg);

            const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            backRightLeg.position.set(0.7, -1.2, -1);
            backRightLeg.castShadow = true;
            body.add(backRightLeg);

            sheepGroup.position.set(x, y, z);
            scene.add(sheepGroup);

            return sheepGroup;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¨Ù„ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¨ÙŠØª
        function createMountain(x, z, width, height, depth) {
            const mountainGroup = new THREE.Group();

            // Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¬Ø¨Ù„
            const baseGeometry = new THREE.ConeGeometry(width, height, 8);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1,
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(x, height / 2, z);
            base.castShadow = true;
            base.receiveShadow = true;
            mountainGroup.add(base);

            // Ù‚Ù…Ø© Ø§Ù„Ø¬Ø¨Ù„ Ø§Ù„Ù…ØºØ·Ø§Ø© Ø¨Ø§Ù„Ø«Ù„Ø¬
            const snowGeometry = new THREE.ConeGeometry(width * 0.4, height * 0.4, 8);
            const snowMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.7,
                metalness: 0.1,
            });
            const snow = new THREE.Mesh(snowGeometry, snowMaterial);
            snow.position.set(x, height * 0.7, z);
            snow.castShadow = true;
            snow.receiveShadow = true;
            mountainGroup.add(snow);

            // Ø¥Ø¶Ø§ÙØ© Ø¨Ø¹Ø¶ Ø§Ù„ØµØ®ÙˆØ± Ø¹Ù„Ù‰ Ø¬ÙˆØ§Ù†Ø¨ Ø§Ù„Ø¬Ø¨Ù„
            const rockCount = 5;
            for (let i = 0; i < rockCount; i++) {
                const rockSize = Math.random() * 5 + 3;
                const rockGeometry = new THREE.SphereGeometry(rockSize, 6, 6);
                const rockMaterial = new THREE.MeshStandardMaterial({
                    color: 0x696969,
                    roughness: 0.8,
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);

                // ÙˆØ¶Ø¹ Ø§Ù„ØµØ®ÙˆØ± Ø¹Ù„Ù‰ Ø¬ÙˆØ§Ù†Ø¨ Ø§Ù„Ø¬Ø¨Ù„ Ø¨Ø´ÙƒÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * width * 0.6;
                const rockHeight = Math.random() * height * 0.4;

                rock.position.set(
                    x + Math.cos(angle) * distance,
                    rockHeight,
                    z + Math.sin(angle) * distance
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                mountainGroup.add(rock);
            }

            scene.add(mountainGroup);
            return mountainGroup;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù…Ù„Ø©
        function createCoin(x, z, value) {
            const coinGroup = new THREE.Group();

            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
            const coinMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 1,
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.x = Math.PI / 2;
            coinGroup.add(coin);

            const haloGeometry = new THREE.RingGeometry(0.6, 0.8, 32);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.rotation.x = -Math.PI / 2;
            halo.position.y = 0.05;
            coinGroup.add(halo);

            const sparkleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const sparkleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
            });

            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                sparkle.position.set(
                    Math.cos(angle) * 0.7,
                    0.1,
                    Math.sin(angle) * 0.7
                );
                sparkle.userData = {
                    angle: angle,
                };
                coinGroup.add(sparkle);
            }

            coinGroup.position.set(x, 1, z);
            coinGroup.userData = {
                value,
                spinSpeed: 0.02,
                sparkleSpeed: 0.05,
            };

            scene.add(coinGroup);
            return coinGroup;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø¹ØµØ§ Ø§Ù„Ù‡Ø¬ÙˆÙ…
        function createStickSwingEffect(position) {
            const particles = [];
            const particleCount = 15;
            const colors = [0x8b4513, 0xa0522d, 0xd2691e];

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.3, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 0.8,
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);

                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 0.1 + 0.05;

                particle.userData = {
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 0.1,
                        Math.sin(angle) * speed
                    ),
                    createdAt: Date.now(),
                };

                scene.add(particle);
                particles.push(particle);
            }

            return particles;
        }

        // Function to create a platform
        function createPlatform(x, y, z, width, height, depth) {
            const platformGeometry = new THREE.BoxGeometry(width, height, depth);
            const platformMaterial = new THREE.MeshStandardMaterial({
                color: 0x964b00,
                roughness: 0.8,
                metalness: 0.1,
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(x, y + height / 2, z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
        function createBombBox(x, z) {
            const boxGroup = new THREE.Group();

            const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: 0xff5722,
                roughness: 0.6,
                metalness: 0.3,
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.y = 1;
            box.castShadow = true;
            box.receiveShadow = true;
            boxGroup.add(box);

            // Ø¥Ø¶Ø§ÙØ© Ø±Ù…Ø² Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© Ø¹Ù„Ù‰ Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚
            const bombSymbolGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const bombSymbolMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000
            });
            const bombSymbol = new THREE.Mesh(bombSymbolGeometry, bombSymbolMaterial);
            bombSymbol.position.set(0, 1, 1.1);
            boxGroup.add(bombSymbol);

            // Ø¥Ø¶Ø§ÙØ© ÙØªÙŠÙ„ Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
            const fuseGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
            const fuseMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00
            });
            const fuse = new THREE.Mesh(fuseGeometry, fuseMaterial);
            fuse.position.set(0, 1.8, 0.5);
            fuse.rotation.x = Math.PI / 6;
            boxGroup.add(fuse);

            // ØªØ£Ø«ÙŠØ± ÙˆÙ…ÙŠØ¶ Ù„Ù„ÙØªÙŠÙ„
            const sparkGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const sparkMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000
            });
            const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
            spark.position.set(0, 2.0, 0.7);
            boxGroup.add(spark);

            boxGroup.position.set(x, 0, z);
            scene.add(boxGroup);

            boxGroup.userData = {
                isBombBox: true,
                spark: spark,
                sparkTimer: 0,
            };

            return boxGroup;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø§Ù†ÙØ¬Ø§Ø± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© - ØªÙ… ØªØ­Ø³ÙŠÙ†Ù‡ Ù„ÙŠÙƒÙˆÙ† Ø£ÙƒØ«Ø± Ù‚ÙˆØ©
        function createBombExplosionEffect(position) {
            const particles = [];
            const particleCount = 50; // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª
            const colors = [0xff5722, 0xff9800, 0xffd700, 0xffffff, 0x00ff00, 0x0000ff]; // Ø¥Ø¶Ø§ÙØ© Ø£Ù„ÙˆØ§Ù† Ø¬Ø¯ÙŠØ¯Ø©

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.7, 8, 8); // Ø²ÙŠØ§Ø¯Ø© Ø­Ø¬Ù… Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª
                const material = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 0.9, // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø´ÙØ§ÙÙŠØ©
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);

                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 0.5 + 0.2; // Ø²ÙŠØ§Ø¯Ø© Ø³Ø±Ø¹Ø© Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª

                particle.userData = {
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 0.3 + 0.1, // Ø²ÙŠØ§Ø¯Ø© Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª
                        Math.sin(angle) * speed
                    ),
                    createdAt: Date.now(),
                    lifeTime: 1500 + Math.random() * 500, // Ø²ÙŠØ§Ø¯Ø© Ø¹Ù…Ø± Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª
                };

                scene.add(particle);
                particles.push(particle);
            }

            // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø¨ØµØ±ÙŠ Ø£ÙƒØ¨Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©
            const bombEffect = document.createElement("div");
            bombEffect.className = "bomb-effect";
            bombEffect.style.width = "200px"; // Ø²ÙŠØ§Ø¯Ø© Ø­Ø¬Ù… Ø§Ù„ØªØ£Ø«ÙŠØ±
            bombEffect.style.height = "200px";

            const vector = new THREE.Vector3(position.x, position.y, position.z);
            vector.project(camera);

            bombEffect.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            bombEffect.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(bombEffect);

            setTimeout(() => {
                bombEffect.remove();
            }, 800); // Ø²ÙŠØ§Ø¯Ø© Ù…Ø¯Ø© Ø§Ù„ØªØ£Ø«ÙŠØ±

            return particles;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø­Ù„Ø© - Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©
        function createBee(x, z) {
            const beeGroup = new THREE.Group();

            // Ø¬Ø³Ù… Ø§Ù„Ù†Ø­Ù„Ø© (ÙƒØ±Ø© ØµÙØ±Ø§Ø¡ ÙˆØ³ÙˆØ¯Ø§Ø¡)
            const bodyGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                roughness: 0.7,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            beeGroup.add(body);

            // Ø®Ø·ÙˆØ· Ø³ÙˆØ¯Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø³Ù…
            const stripeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.6, 8);
            const stripeMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            
            for (let i = 0; i < 3; i++) {
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, -0.6 + i * 0.6, 0);
                stripe.rotation.z = Math.PI / 2;
                body.add(stripe);
            }

            // Ø±Ø£Ø³ Ø§Ù„Ù†Ø­Ù„Ø©
            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0.8, 0);
            beeGroup.add(head);

            // Ø¹ÙŠÙˆÙ† Ø§Ù„Ù†Ø­Ù„Ø©
            const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2, 0.9, 0.3);
            beeGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2, 0.9, 0.3);
            beeGroup.add(rightEye);

            // Ù‚Ø±ÙˆÙ† Ø§Ù„Ø§Ø³ØªØ´Ø¹Ø§Ø±
            const antennaGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8);
            const antennaMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            
            const leftAntenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            leftAntenna.position.set(-0.2, 1.1, 0.1);
            leftAntenna.rotation.z = -Math.PI / 6;
            beeGroup.add(leftAntenna);
            
            const rightAntenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            rightAntenna.position.set(0.2, 1.1, 0.1);
            rightAntenna.rotation.z = Math.PI / 6;
            beeGroup.add(rightAntenna);

            // Ø£Ø¬Ù†Ø­Ø© Ø§Ù„Ù†Ø­Ù„Ø©
            const wingGeometry = new THREE.SphereGeometry(0.6, 8, 8);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.8, 0.5, 0);
            leftWing.scale.set(0.1, 0.5, 1);
            beeGroup.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.8, 0.5, 0);
            rightWing.scale.set(0.1, 0.5, 1);
            beeGroup.add(rightWing);

            // Ø¥Ø¨Ø±Ø© Ø§Ù„Ù†Ø­Ù„Ø©
            const stingerGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
            const stingerMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            const stinger = new THREE.Mesh(stingerGeometry, stingerMaterial);
            stinger.position.set(0, -0.8, 0);
            stinger.rotation.x = Math.PI;
            beeGroup.add(stinger);

            beeGroup.position.set(x, 5, z); // Ø§Ù„Ù†Ø­Ù„ ÙŠØ·ÙŠØ± ÙÙŠ Ø§Ù„Ù‡ÙˆØ§Ø¡

            // Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù†Ø­Ù„Ø©
            beeGroup.userData = {
                type: 'bee',
                health: 40,
                speed: 0.08,
                damage: 8,
                isChasing: false,
                detectionRange: 25,
                attackRange: 2,
                lastAttackTime: 0,
                attackCooldown: 1500,
                collisionDamage: 12,
                lastCollisionTime: 0,
                collisionCooldown: 1000,
                wingFlapSpeed: 15,
                wingFlapAngle: 0
            };

            scene.add(beeGroup);
            return beeGroup;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ù„Ø³Ø¹Ø© Ø§Ù„Ù†Ø­Ù„Ø© - Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©
        function createBeeSting(fromPos, toPos) {
            const stingGroup = new THREE.Group();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„Ø³Ø¹Ø©
            const stingGeometry = new THREE.CylinderGeometry(0.05, 0.02, 1, 8);
            const stingMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000
            });
            const sting = new THREE.Mesh(stingGeometry, stingMaterial);
            sting.rotation.x = Math.PI / 2;
            stingGroup.add(sting);
            
            stingGroup.position.copy(fromPos);
            
            // Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù„Ø³Ø¹Ø© Ù†Ø­Ùˆ Ø§Ù„Ù„Ø§Ø¹Ø¨
            const direction = new THREE.Vector3().subVectors(toPos, fromPos).normalize();
            stingGroup.lookAt(toPos);
            
            scene.add(stingGroup);
            
            // Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù„Ø³Ø¹Ø©
            stingGroup.userData = {
                type: 'beeSting',
                direction: direction,
                speed: 0.3,
                damage: 8,
                distanceTraveled: 0,
                maxDistance: 20
            };
            
            beeStings.push(stingGroup);
            
            // ØµÙˆØª Ø§Ù„Ù„Ø³Ø¹Ø©
            playSound(800, 'sawtooth', 0.1, 0.2);
        }

        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
        const sheeps = [];
        const wolves = [];
        const coins = [];
        const effects = [];
        const mountains = []; // ØªÙ… ØªØºÙŠÙŠØ± houses Ø¥Ù„Ù‰ mountains
        const wolfProjectiles = [];
        const platforms = [];
        const bombBoxes = [];
        const bees = []; // Ø¥Ø¶Ø§ÙØ© Ù…ØµÙÙˆÙØ© Ø§Ù„Ù†Ø­Ù„
        const beeStings = []; // Ø¥Ø¶Ø§ÙØ© Ù…ØµÙÙˆÙØ© Ù„Ø³Ø¹Ø§Øª Ø§Ù„Ù†Ø­Ù„

        let score = 0;
        let coinsCollected = 0;
        let sheepCollected = 0; // Ø¥Ø¶Ø§ÙØ© Ù…ØªØºÙŠØ± Ø¬Ø¯ÙŠØ¯ Ù„Ø¬Ù…Ø¹ Ø§Ù„Ø®Ø±Ø§Ù
        let level = 1;
        let round = 1;
        let gameOver = false;
        let gameStarted = false;
        let isRoundTransition = false;
        let playerHealth = 100;
        const maxPlayerHealth = 100;
        let lastHitTime = 0; // ÙˆÙ‚Øª Ø¢Ø®Ø± Ø¶Ø±Ø± ØªØ¹Ø±Ø¶ Ù„Ù‡ Ø§Ù„Ù„Ø§Ø¹Ø¨
        const hitCooldown = 1000; // ÙØªØ±Ø© Ø§Ù„Ù…Ù†Ø§Ø¹Ø© Ø¨ÙŠÙ† Ø§Ù„Ø¶Ø±Ø¨Ø§Øª (1 Ø«Ø§Ù†ÙŠØ©)
        let lastAttackTime = 0;
        const attackCooldown = 500;
        let bombs = 0; // Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„ Ø§Ù„ØªÙŠ ÙŠÙ…ØªÙ„ÙƒÙ‡Ø§ Ø§Ù„Ù„Ø§Ø¹Ø¨

        // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: ØªØ®ÙÙŠØ¶ Ø³Ø±Ø¹Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ø´ÙƒÙ„ ÙƒØ¨ÙŠØ±
        let playerSpeed = 1.0; // ØªÙ… ØªØ®ÙÙŠØ¶ Ø§Ù„Ø³Ø±Ø¹Ø© Ù…Ù† 2.0 Ø¥Ù„Ù‰ 1.0
        let acceleration = 0.05; // ØªÙ… ØªØ®ÙÙŠØ¶ Ø§Ù„ØªØ³Ø§Ø±Ø¹ Ù…Ù† 0.1 Ø¥Ù„Ù‰ 0.05
        let deceleration = 0.95; // ØªÙ… Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ¨Ø§Ø·Ø¤ Ù…Ù† 0.9 Ø¥Ù„Ù‰ 0.95
        let maxSpeed = 1.0; // ØªÙ… ØªØ®ÙÙŠØ¶ Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù‚ØµÙˆÙ‰ Ù…Ù† 2.0 Ø¥Ù„Ù‰ 1.0
        let velocity = new THREE.Vector3();

        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let previousTouchX = 0;
        let previousTouchY = 0;
        const mouseSensitivity = 0.003; // Ø²ÙŠØ§Ø¯Ø© Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø§ÙˆØ³
        const touchSensitivity = 0.005; // Ø²ÙŠØ§Ø¯Ø© Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù„Ù…Ø³
        let cameraTouchId = null;
        const buttonTouchIds = new Map();
        let totalSheeps = 0;

        // Ø¥Ø¶Ø§ÙØ© Ù…ØªØºÙŠØ±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ù‚ÙØ²
        let isJumping = false;
        let jumpVelocity = 0;
        const gravity = 0.02;
        const jumpPower = 0.25;

        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ø«Ø§Ù„Ø« - ØªÙ… ØªØ­Ø³ÙŠÙ†Ù‡Ø§
        let cameraDistance = 10;
        let cameraHeight = 5;
        let cameraAngle = 0;

        // Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© - ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
        let joystickActive = false;
        let joystickTouchId = null;
        let joystickCenterX = 0;
        let joystickCenterY = 0;
        let joystickRadius = 75; // Ù†ØµÙ Ù‚Ø·Ø± Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
        let joystickDirection = {
            x: 0,
            y: 0
        };

        // Ù…ØªØºÙŠØ±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© - ØªÙ… ØªØ­Ø³ÙŠÙ†Ù‡Ø§ Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù‚ÙˆØ©
        let bombCharge = 0; // Ù…Ø³ØªÙˆÙ‰ Ø´Ø­Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© (0 Ø¥Ù„Ù‰ 1)
        let isChargingBomb = false; // Ø­Ø§Ù„Ø© Ø§Ù„Ø´Ø­Ù†
        let bombChargeSpeed = 0.03; // Ø²ÙŠØ§Ø¯Ø© Ø³Ø±Ø¹Ø© Ø´Ø­Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©

        // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø²ÙŠØ§Ø¯Ø© Ù…Ø¯Ù‰ Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© Ø¨Ø´ÙƒÙ„ ÙƒØ¨ÙŠØ±
        let bombMaxRadius = 80; // ØªÙ… Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø¯Ù‰ Ù…Ù† 60 Ø¥Ù„Ù‰ 80 (Ø£ÙˆØ³Ø¹ Ø¨ÙƒØ«ÙŠØ±)
        let bombRangeIndicator = null; // Ù…Ø¤Ø´Ø± Ù…Ø¯Ù‰ Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©

        // Ø¥Ø¶Ø§ÙØ© Ù…ØªØºÙŠØ±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            arrowup: false,
            arrowleft: false,
            arrowdown: false,
            arrowright: false
        };

        // Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const startScreen = document.getElementById("startScreen");
        const startGameBtn = document.getElementById("startGameBtn");
        const infoPanel = document.getElementById("infoPanel");
        const scoreDisplay = document.getElementById("scoreDisplay");
        const coinsDisplay = document.getElementById("coinsDisplay");
        const sheepDisplay = document.getElementById("sheepDisplay"); // Ø¥Ø¶Ø§ÙØ© Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø±Ø§Ù
        const bombsDisplay = document.getElementById("bombsDisplay"); // Ø¥Ø¶Ø§ÙØ© Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„
        const levelDisplay = document.getElementById("levelDisplay");
        const wasteCount = document.getElementById("wasteCount");
        const coinsCount = document.getElementById("coinsCount");
        const aggressiveCount = document.getElementById("aggressiveCount");
        const beesCount = document.getElementById("beesCount");
        const gameOverPanel = document.getElementById("gameOverPanel");
        const finalScore = document.getElementById("finalScore");
        finalScore.textContent = "0";
        const finalCoins = document.getElementById("finalCoins");
        finalCoins.textContent = "0";
        const restartBtn = document.getElementById("restartBtn");
        const attackBtn = document.getElementById("attackBtn");
        const jumpBtn = document.getElementById("jumpBtn");
        const bombBtn = document.getElementById("bombBtn"); // Ø²Ø± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯
        const laserSight = document.getElementById("laserSight");
        const movementControls = document.getElementById("movementControls");
        const roundIndicator = document.getElementById("roundIndicator");
        const nextRoundBtn = document.getElementById("nextRoundBtn");
        const worldBoundaryWarning = document.getElementById("worldBoundaryWarning");
        const roundTransition = document.getElementById("roundTransition");
        const roundMessage = document.getElementById("roundMessage");
        const healthIndicator = document.getElementById("healthIndicator");
        const healthBar = document.getElementById("healthBar");
        const questionPanel = document.getElementById("questionPanel");
        const questionText = document.getElementById("questionText");
        const sequenceContainer = document.getElementById("sequenceContainer"); // Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        const optionsContainer = document.getElementById("optionsContainer");
        const playerDamageEffect = document.getElementById("playerDamageEffect");

        // Ø¹Ù†Ø§ØµØ± Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        const joystickBase = document.getElementById("joystickBase");
        const joystickHandle = document.getElementById("joystickHandle");

        // Ø¹Ù†Ø§ØµØ± Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
        const bombChargeIndicator = document.getElementById("bombChargeIndicator");
        const bombChargeBar = document.getElementById("bombChargeBar");

        let isGameFrozen = false;
        let gameLoopId;
        const treasureBoxes = [];

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
        function getArabicNumber(num) {
            const arabicNumbers = {
                1: "Ø§Ù„Ø£ÙˆÙ„", 2: "Ø§Ù„Ø«Ø§Ù†ÙŠ", 3: "Ø§Ù„Ø«Ø§Ù„Ø«", 4: "Ø§Ù„Ø±Ø§Ø¨Ø¹", 5: "Ø§Ù„Ø®Ø§Ù…Ø³",
                6: "Ø§Ù„Ø³Ø§Ø¯Ø³", 7: "Ø§Ù„Ø³Ø§Ø¨Ø¹", 8: "Ø§Ù„Ø«Ø§Ù…Ù†", 9: "Ø§Ù„ØªØ§Ø³Ø¹", 10: "Ø§Ù„Ø¹Ø§Ø´Ø±",
                11: "Ø§Ù„Ø­Ø§Ø¯ÙŠ Ø¹Ø´Ø±", 12: "Ø§Ù„Ø«Ø§Ù†ÙŠ Ø¹Ø´Ø±", 13: "Ø§Ù„Ø«Ø§Ù„Ø« Ø¹Ø´Ø±", 14: "Ø§Ù„Ø±Ø§Ø¨Ø¹ Ø¹Ø´Ø±",
                15: "Ø§Ù„Ø®Ø§Ù…Ø³ Ø¹Ø´Ø±"
            };
            return arabicNumbers[num] || num;
        }

        // ØªÙˆÙ„ÙŠØ¯ Ø³Ø¤Ø§Ù„ Ø±ÙŠØ§Ø¶ÙŠ Ø­ÙˆÙ„ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ§Øª - ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ§Øª ÙÙŠ Ø³Ø·Ø± Ù…Ø³ØªÙ‚Ù„
        function generateMathQuestion() {
            const questionTypes = ["arithmetic_sequence", "geometric_sequence", "general_term_rule", "find_rule"];
            const selectedType = questionTypes[Math.floor(Math.random() * questionTypes.length)];

            if (selectedType === "arithmetic_sequence") {
                // Ù…ØªØªØ§Ù„ÙŠØ© Ø­Ø³Ø§Ø¨ÙŠØ©
                const firstTerm = Math.floor(Math.random() * 10) + 1;
                const commonDifference = Math.floor(Math.random() * 5) + 1;
                const sequenceLength = 4; // Ø¹Ø¯Ø¯ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ© Ø§Ù„Ù…Ø¹Ø·Ø§Ø©

                let sequence = [];
                for (let i = 0; i < sequenceLength; i++) {
                    sequence.push(firstTerm + i * commonDifference);
                }

                const nextTerm = firstTerm + sequenceLength * commonDifference;
                const question = `Ù…Ø§ Ø§Ù„Ø­Ø¯ Ø§Ù„ØªØ§Ù„ÙŠ ÙÙŠ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ© Ø§Ù„Ø¢ØªÙŠØ©ØŸ`;
                const options = [nextTerm.toString()];

                while (options.length < 4) {
                    // Ø¥Ù†Ø´Ø§Ø¡ Ø®ÙŠØ§Ø±Ø§Øª Ø®Ø§Ø·Ø¦Ø©
                    let wrongAnswer = nextTerm + (Math.floor(Math.random() * 10) - 5); // Ø¹Ø¯Ø¯ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø­ÙˆÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
                    if (wrongAnswer === nextTerm) {
                        wrongAnswer += 1;
                    }
                    if (!options.includes(wrongAnswer.toString())) {
                        options.push(wrongAnswer.toString());
                    }
                }

                options.sort(() => Math.random() - 0.5);

                return {
                    question,
                    options,
                    answer: nextTerm.toString(),
                    sequence: sequence // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ© Ù„Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ÙØµÙ„
                };
            } else if (selectedType === "geometric_sequence") {
                // Ù…ØªØªØ§Ù„ÙŠØ© Ù‡Ù†Ø¯Ø³ÙŠØ©
                const firstTerm = Math.floor(Math.random() * 5) + 1;
                const commonRatio = Math.floor(Math.random() * 3) + 2; // ØªØ¬Ù†Ø¨ 1 Ù„ØªÙƒÙˆÙ† Ù…ØªØªØ§Ù„ÙŠØ© ØºÙŠØ± Ø«Ø§Ø¨ØªØ©
                const sequenceLength = 4;

                let sequence = [];
                for (let i = 0; i < sequenceLength; i++) {
                    sequence.push(firstTerm * Math.pow(commonRatio, i));
                }

                const nextTerm = firstTerm * Math.pow(commonRatio, sequenceLength);
                const question = `Ù…Ø§ Ø§Ù„Ø­Ø¯ Ø§Ù„ØªØ§Ù„ÙŠ ÙÙŠ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ© Ø§Ù„Ø¢ØªÙŠØ©ØŸ`;
                const options = [nextTerm.toString()];

                while (options.length < 4) {
                    let wrongAnswer = nextTerm + (Math.floor(Math.random() * 10) - 5);
                    if (wrongAnswer === nextTerm) {
                        wrongAnswer += 1;
                    }
                    if (!options.includes(wrongAnswer.toString())) {
                        options.push(wrongAnswer.toString());
                    }
                }

                options.sort(() => Math.random() - 0.5);

                return {
                    question,
                    options,
                    answer: nextTerm.toString(),
                    sequence: sequence // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ© Ù„Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ÙØµÙ„
                };
            } else if (selectedType === "general_term_rule") {
                // Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯: Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø­Ø¯ Ø§Ù„Ø¹Ø§Ù… Ù„Ù„Ù…ØªØªØ§Ù„ÙŠØ©
                const multiplier = Math.floor(Math.random() * 8) + 2; // Ø¹Ø¯Ø¯ Ø¨ÙŠÙ† 2 Ùˆ 9
                const adder = Math.floor(Math.random() * 10) + 1; // Ø¹Ø¯Ø¯ Ø¨ÙŠÙ† 1 Ùˆ 10
                const termPosition = Math.floor(Math.random() * 10) + 5; // Ø±ØªØ¨Ø© Ø§Ù„Ø­Ø¯ Ø¨ÙŠÙ† 5 Ùˆ 14
                
                // Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø­Ø¯ Ø§Ù„Ø¹Ø§Ù…
                const rule = `Ø§Ø¶Ø±Ø¨ Ø±ØªØ¨Ø© Ø§Ù„Ø­Ø¯ ÙÙŠ ${multiplier} Ø«Ù… Ø§Ø·Ø±Ø­ ${adder}`;
                
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
                const answer = (termPosition * multiplier) - adder;
                
                const question = `Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø­Ø¯ Ø§Ù„Ø¹Ø§Ù… Ù„Ù„Ù…ØªØªØ§Ù„ÙŠØ© Ù‡ÙŠ: ${rule}. ÙØ£ÙˆØ¬Ø¯ Ø§Ù„Ø­Ø¯ ${getArabicNumber(termPosition)}`;
                const options = [answer.toString()];

                // Ø¥Ù†Ø´Ø§Ø¡ Ø®ÙŠØ§Ø±Ø§Øª Ø®Ø§Ø·Ø¦Ø©
                while (options.length < 4) {
                    let wrongAnswer = answer + (Math.floor(Math.random() * 10) - 5);
                    if (wrongAnswer === answer) {
                        wrongAnswer += Math.floor(Math.random() * 5) + 1;
                    }
                    if (!options.includes(wrongAnswer.toString())) {
                        options.push(wrongAnswer.toString());
                    }
                }

                options.sort(() => Math.random() - 0.5);

                return {
                    question,
                    options,
                    answer: answer.toString(),
                    sequence: null
                };
            } else if (selectedType === "find_rule") {
                // Ù†ÙˆØ¹ Ø¥Ø¶Ø§ÙÙŠ: Ø¥ÙŠØ¬Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ© Ù…Ù† Ø­Ø¯ÙˆØ¯ Ù…Ø¹Ø·Ø§Ø©
                const ruleType = Math.random() > 0.5 ? "arithmetic" : "geometric";
                
                if (ruleType === "arithmetic") {
                    const firstTerm = Math.floor(Math.random() * 10) + 1;
                    const commonDifference = Math.floor(Math.random() * 5) + 1;
                    const sequence = [firstTerm, firstTerm + commonDifference, firstTerm + 2 * commonDifference];
                    
                    const question = `Ù…Ø§ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø­Ø¯ Ø§Ù„Ø¹Ø§Ù… Ù„Ù„Ù…ØªØªØ§Ù„ÙŠØ©: ${sequence.join('ØŒ ')}ØŒ ...ØŸ`;
                    const correctRule = `Ø§Ø¶Ø±Ø¨ Ø±ØªØ¨Ø© Ø§Ù„Ø­Ø¯ ÙÙŠ ${commonDifference} Ø«Ù… Ø§Ø¬Ù…Ø¹ ${firstTerm - commonDifference}`;
                    const options = [correctRule];
                    
                    // Ø¥Ù†Ø´Ø§Ø¡ Ù‚ÙˆØ§Ø¹Ø¯ Ø®Ø§Ø·Ø¦Ø©
                    while (options.length < 4) {
                        let wrongDiff = commonDifference + (Math.floor(Math.random() * 3) - 1);
                        if (wrongDiff === commonDifference) wrongDiff += 1;
                        if (wrongDiff < 1) wrongDiff = 1;
                        
                        let wrongFirst = firstTerm + (Math.floor(Math.random() * 3) - 1);
                        if (wrongFirst === firstTerm) wrongFirst += 1;
                        
                        const wrongRule = `Ø§Ø¶Ø±Ø¨ Ø±ØªØ¨Ø© Ø§Ù„Ø­Ø¯ ÙÙŠ ${wrongDiff} Ø«Ù… Ø§Ø¬Ù…Ø¹ ${wrongFirst - wrongDiff}`;
                        if (!options.includes(wrongRule)) {
                            options.push(wrongRule);
                        }
                    }
                    
                    options.sort(() => Math.random() - 0.5);
                    
                    return {
                        question,
                        options,
                        answer: correctRule,
                        sequence: sequence
                    };
                } else {
                    // Ù‚Ø§Ø¹Ø¯Ø© Ù‡Ù†Ø¯Ø³ÙŠØ©
                    const firstTerm = Math.floor(Math.random() * 5) + 1;
                    const commonRatio = Math.floor(Math.random() * 3) + 2;
                    const sequence = [firstTerm, firstTerm * commonRatio, firstTerm * commonRatio * commonRatio];
                    
                    const question = `Ù…Ø§ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø­Ø¯ Ø§Ù„Ø¹Ø§Ù… Ù„Ù„Ù…ØªØªØ§Ù„ÙŠØ©: ${sequence.join('ØŒ ')}ØŒ ...ØŸ`;
                    const correctRule = `Ø§Ø¶Ø±Ø¨ ${firstTerm} ÙÙŠ ${commonRatio} Ø£Ø³ (Ø±ØªØ¨Ø© Ø§Ù„Ø­Ø¯ Ù†Ø§Ù‚Øµ 1)`;
                    const options = [correctRule];
                    
                    // Ø¥Ù†Ø´Ø§Ø¡ Ù‚ÙˆØ§Ø¹Ø¯ Ø®Ø§Ø·Ø¦Ø©
                    while (options.length < 4) {
                        let wrongRatio = commonRatio + (Math.floor(Math.random() * 2) - 0);
                        if (wrongRatio === commonRatio) wrongRatio += 1;
                        if (wrongRatio < 2) wrongRatio = 2;
                        
                        let wrongFirst = firstTerm + (Math.floor(Math.random() * 2) - 0);
                        if (wrongFirst === firstTerm) wrongFirst += 1;
                        if (wrongFirst < 1) wrongFirst = 1;
                        
                        const wrongRule = `Ø§Ø¶Ø±Ø¨ ${wrongFirst} ÙÙŠ ${wrongRatio} Ø£Ø³ (Ø±ØªØ¨Ø© Ø§Ù„Ø­Ø¯ Ù†Ø§Ù‚Øµ 1)`;
                        if (!options.includes(wrongRule)) {
                            options.push(wrongRule);
                        }
                    }
                    
                    options.sort(() => Math.random() - 0.5);
                    
                    return {
                        question,
                        options,
                        answer: correctRule,
                        sequence: sequence
                    };
                }
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ© ÙÙŠ Ø³Ø·Ø± Ù…Ø³ØªÙ‚Ù„ ÙˆØ¨Ø§ØªØ¬Ø§Ù‡ Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ†
        function displaySequence(sequence) {
            sequenceContainer.innerHTML = ''; // Ù…Ø³Ø­ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø³Ø§Ø¨Ù‚

            sequence.forEach((term, index) => {
                const termElement = document.createElement('span');
                termElement.className = 'sequence-item';
                termElement.textContent = term;

                // Ø¥Ø¶Ø§ÙØ© ÙØ§ØµÙ„Ø© Ø¨ÙŠÙ† Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø¨Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø§Ù„Ø£Ø®ÙŠØ±
                if (index < sequence.length - 1) {
                    termElement.textContent += 'ØŒ ';
                }

                sequenceContainer.appendChild(termElement);
            });

            // Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø«Ù„Ø§Ø«Ø© Ù„Ù„Ø¥Ø´Ø§Ø±Ø© Ø¥Ù„Ù‰ Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ©
            const dotsElement = document.createElement('span');
            dotsElement.className = 'sequence-item';
            dotsElement.textContent = '...';
            sequenceContainer.appendChild(dotsElement);
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±ØªÙØ¹Ø§Øª (Ø§Ù„Ù…Ù†ØµØ§Øª)
        function spawnPlatforms() {
            const platformCount = 10;
            for (let i = 0; i < platformCount; i++) {
                const platformWidth = Math.random() * 10 + 5;
                const platformDepth = Math.random() * 10 + 5;
                const platformHeight = Math.random() * 5 + 3;
                const platformX = Math.random() * 800 - 400;
                const platformZ = Math.random() * 800 - 400;

                platforms.push(
                    createPlatform(
                        platformX,
                        0,
                        platformZ,
                        platformWidth,
                        platformHeight,
                        platformDepth
                    )
                );
            }
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£ØºÙ†Ø§Ù… Ù„Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© - ØªÙ… ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§ Ù„Ø¥Ù†Ø´Ø§Ø¡ 5 Ø®Ø±Ø§Ù ÙÙ‚Ø·
        function spawnNewSheeps() {
            const currentSheepCount = 5; // 5 Ø®Ø±Ø§Ù ÙÙ‚Ø· Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† 20
            totalSheeps = currentSheepCount;

            // ÙˆØ¶Ø¹ Ø§Ù„Ø®Ø±Ø§Ù Ø¨Ø¹ÙŠØ¯Ø§Ù‹ Ø¹Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù…
            const safeAreaBuffer = 100; // Ù…Ø³Ø§ÙØ© Ø¢Ù…Ù†Ø© Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù…
            const safeMinX = worldBounds.minX + safeAreaBuffer;
            const safeMaxX = worldBounds.maxX - safeAreaBuffer;
            const safeMinZ = worldBounds.minZ + safeAreaBuffer;
            const safeMaxZ = worldBounds.maxZ - safeAreaBuffer;

            for (let i = 0; i < currentSheepCount; i++) {
                // Ø¶Ù…Ø§Ù† ÙˆØ¶Ø¹ Ø§Ù„Ø®Ø±Ø§Ù ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¢Ù…Ù†Ø© Ø¨Ø¹ÙŠØ¯Ø§Ù‹ Ø¹Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
                const sheepX = Math.random() * (safeMaxX - safeMinX) + safeMinX;
                const sheepZ = Math.random() * (safeMaxZ - safeMinZ) + safeMinZ;

                const sheep = createSheep(sheepX, 2, sheepZ);
                sheeps.push(sheep);

                // Ø¥Ø¶Ø§ÙØ© 3 Ø°Ø¦Ø§Ø¨ Ø´Ø±Ø³Ø© Ø­ÙˆÙ„ ÙƒÙ„ Ø®Ø±ÙˆÙ
                for (let j = 0; j < 3; j++) {
                    const angle = (j / 3) * Math.PI * 2;
                    const distance = 10; // Ù…Ø³Ø§ÙØ© Ø§Ù„Ø°Ø¦Ø§Ø¨ Ø¹Ù† Ø§Ù„Ø®Ø±ÙˆÙ
                    const wolfX = sheepX + Math.cos(angle) * distance;
                    const wolfZ = sheepZ + Math.sin(angle) * distance;

                    const wolfType = "aggressive";
                    const wolf = createWolf(wolfX, wolfZ, wolfType);
                    
                    // Ø±Ø¨Ø· Ø§Ù„Ø°Ø¦Ø¨ Ø§Ù„Ø´Ø±Ø³ Ø¨Ø§Ù„Ø®Ø±ÙˆÙ Ø§Ù„Ø°ÙŠ ÙŠØ­Ù…ÙŠÙ‡
                    wolf.userData.protectedSheep = sheep;
                    
                    wolves.push(wolf);
                }
            }
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø°Ø¦Ø§Ø¨ Ø¹Ø§Ø¯ÙŠØ© Ù…ÙˆØ²Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø±Ø¨Ø§Ø¹
        function spawnNormalWolvesInQuarters() {
            const wolvesPerQuarter = 5; // Ø¹Ø¯Ø¯ Ø§Ù„Ø°Ø¦Ø§Ø¨ ÙÙŠ ÙƒÙ„ Ø±Ø¨Ø¹
            
            quarters.forEach((quarter, index) => {
                for (let i = 0; i < wolvesPerQuarter; i++) {
                    // ÙˆØ¶Ø¹ Ø§Ù„Ø°Ø¦Ø¨ Ø¨Ø´ÙƒÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¯Ø§Ø®Ù„ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø±Ø¨Ø¹
                    const wolfX = Math.random() * (quarter.maxX - quarter.minX) + quarter.minX;
                    const wolfZ = Math.random() * (quarter.maxZ - quarter.minZ) + quarter.minZ;
                    
                    const wolf = createWolf(wolfX, wolfZ, "normal", quarter);
                    
                    // Ø¥Ø¶Ø§ÙØ© Ù‡Ø¯Ù Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø£ÙˆÙ„ÙŠ Ù„Ù„Ø°Ø¦Ø¨
                    wolf.userData.randomTarget = new THREE.Vector3(
                        Math.random() * (quarter.maxX - quarter.minX) + quarter.minX,
                        0,
                        Math.random() * (quarter.maxZ - quarter.minZ) + quarter.minZ
                    );
                    
                    wolves.push(wolf);
                }
            });
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø°Ø¦Ø§Ø¨ Ù„Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© - ØªÙ… ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø°Ø¦Ø§Ø¨ Ø¹Ø§Ø¯ÙŠØ© Ù…ÙˆØ²Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø±Ø¨Ø§Ø¹
        function spawnWavesForRound() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø°Ø¦Ø§Ø¨ Ø¹Ø§Ø¯ÙŠØ© ÙÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø¹
            spawnNormalWolvesInQuarters();

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ø­Ù„ Ù…Ù† Ø§Ù„Ø¬ÙˆÙ„Ø© 3 ÙØµØ§Ø¹Ø¯Ø§Ù‹
            if (round >= 3) {
                const beeCount = 3 + (round - 3) * 2; // Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø­Ù„ ÙŠØ²Ø¯Ø§Ø¯ Ù…Ø¹ Ø§Ù„Ø¬ÙˆÙ„Ø§Øª
                for (let i = 0; i < beeCount; i++) {
                    const beeX = Math.random() * 900 - 450;
                    const beeZ = Math.random() * 900 - 450;
                    bees.push(createBee(beeX, beeZ));
                }
            }

            const treasureBoxCount = 5 + round * 2;
            for (let i = 0; i < treasureBoxCount; i++) {
                const boxX = Math.random() * 800 - 400;
                const boxZ = Math.random() * 800 - 400;

                // 30% ÙØ±ØµØ© Ù„Ø¥Ù†Ø´Ø§Ø¡ ØµÙ†Ø¯ÙˆÙ‚ Ù‚Ù†Ø¨Ù„Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„ØµØ­Ø©
                if (Math.random() < 0.3) {
                    bombBoxes.push(createBombBox(boxX, boxZ));
                } else {
                    treasureBoxes.push(createHealthBox(boxX, boxZ));
                }
            }

            updateUI();
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¨Ø§Ù„ ÙÙŠ Ø£Ù…Ø§ÙƒÙ† Ø«Ø§Ø¨ØªØ© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø© - ØªÙ… ØªØºÙŠÙŠØ± Ø¹Ø¯Ø¯Ù‡Ø§ Ù…Ù† 15 Ø¥Ù„Ù‰ 5
        function spawnMountains() {
            const mountainCount = 5; // ØªÙ… ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¹Ø¯Ø¯ Ù…Ù† 15 Ø¥Ù„Ù‰ 5
            for (let i = 0; i < mountainCount; i++) {
                // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¨Ø§Ù„ Ø¨Ø£Ø­Ø¬Ø§Ù… Ù…Ø®ØªÙ„ÙØ©
                const mountainWidth = Math.random() * 30 + 20; // Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¨Ù„
                const mountainHeight = Math.random() * 40 + 30; // Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¬Ø¨Ù„
                const mountainDepth = Math.random() * 30 + 20; // Ø¹Ù…Ù‚ Ø§Ù„Ø¬Ø¨Ù„
                const mountainX = Math.random() * 800 - 400;
                const mountainZ = Math.random() * 800 - 400;

                mountains.push(createMountain(mountainX, mountainZ, mountainWidth, mountainHeight, mountainDepth));
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¥Ù†Ø´Ø§Ø¡ ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„ØµØ­Ø© (Ø§Ù„ÙƒÙ†Ø²)
        function createHealthBox(x, z) {
            const boxGroup = new THREE.Group();

            const boxBaseGeometry = new THREE.BoxGeometry(2, 1.5, 2);
            const boxBaseMaterial = new THREE.MeshStandardMaterial({
                color: 0xd2b48c,
                roughness: 0.6,
                metalness: 0.3,
            });
            const boxBase = new THREE.Mesh(boxBaseGeometry, boxBaseMaterial);
            boxBase.position.y = 0.75;
            boxBase.castShadow = true;
            boxBase.receiveShadow = true;
            boxGroup.add(boxBase);

            const goldBandGeometry = new THREE.BoxGeometry(2.2, 0.3, 2.2);
            const goldBandMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.2,
                metalness: 0.9,
            });
            const goldBand = new THREE.Mesh(goldBandGeometry, goldBandMaterial);
            goldBand.position.y = 1.6;
            goldBand.castShadow = true;
            goldBand.receiveShadow = true;
            boxGroup.add(goldBand);

            const crossGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.2);
            const crossMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000
            });
            const crossHorizontal = new THREE.Mesh(crossGeometry, crossMaterial);
            crossHorizontal.position.set(0, 1.6, 1.1);

            const crossVertical = new THREE.Mesh(crossGeometry, crossMaterial);
            crossVertical.rotation.y = Math.PI / 2;
            crossVertical.position.set(0, 1.6, 1.1);

            boxGroup.add(crossHorizontal);
            boxGroup.add(crossVertical);

            boxGroup.position.set(x, 0, z);
            scene.add(boxGroup);

            boxGroup.userData = {
                isHealthBox: true,
            };

            return boxGroup;
        }

        function updateUI() {
            scoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
            coinsDisplay.textContent = `Ø§Ù„Ø¹Ù…Ù„Ø§Øª: ${coinsCollected}`;
            sheepDisplay.textContent = `Ø§Ù„Ø®Ø±Ø§Ù: ${sheepCollected}/5`; // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø±Ø§Ù Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
            bombsDisplay.textContent = `Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„: ${bombs}`; // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„
            levelDisplay.textContent = level;
            wasteCount.textContent = wolves.length;
            coinsCount.textContent = coinsCollected;
            beesCount.textContent = bees.length; // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø­Ù„

            const aggressiveWolves = wolves.filter(
                (w) => w.userData.isAggressive
            ).length;
            aggressiveCount.textContent = aggressiveWolves;

            roundIndicator.textContent = `Ø§Ù„Ø¬ÙˆÙ„Ø©: ${round}`;

            const healthPercentage = (playerHealth / maxPlayerHealth) * 100;
            healthBar.style.width = `${healthPercentage}%`;

            // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: ØªÙØ¹ÙŠÙ„ Ø²Ø± Ø§Ù„Ø¬ÙˆÙ„Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© Ø¹Ù†Ø¯ Ø¬Ù…Ø¹ 5 Ø®Ø±Ø§Ù
            if (sheepCollected >= 5 && !gameOver && !isRoundTransition && gameStarted) {
                nextRoundBtn.style.display = "block";
                nextRoundBtn.disabled = false;
            } else {
                nextRoundBtn.style.display = "none";
            }

            // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø¬Ø¹Ù„ Ø²Ø± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© Ø±Ù…Ø§Ø¯ÙŠ Ø¹Ù†Ø¯Ù…Ø§ ØªÙƒÙˆÙ† Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„ ØµÙØ±
            if (bombs <= 0) {
                bombBtn.classList.add("disabled");
            } else {
                bombBtn.classList.remove("disabled");
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†Ø¬Ø§Ø­
        function showSuccessMessage() {
            const successDiv = document.createElement("div");
            successDiv.className = "success-message";
            successDiv.textContent = "Ø£Ø­Ø³Ù†Øª! Ù„Ù‚Ø¯ Ø£Ù†Ø¬Ø²Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­";
            document.body.appendChild(successDiv);

            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }

        function nextRound() {
            isRoundTransition = true;
            nextRoundBtn.disabled = true;
            nextRoundBtn.style.display = "none";

            roundMessage.textContent = `Ø§Ù„Ø¬ÙˆÙ„Ø© ${round + 1}`;
            roundTransition.classList.add("active");

            setTimeout(() => {
                round++;
                
                // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: ØªØ¬Ø¯ÙŠØ¯ ØµØ­Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ø¹Ø¯ ÙƒÙ„ Ù…Ø³ØªÙˆÙ‰
                playerHealth = maxPlayerHealth;
                
                sheepCollected = 0; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¹Ø¯Ø¯ Ø§Ù„Ø®Ø±Ø§Ù Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©

                wolves.forEach((wolf) => scene.remove(wolf));
                wolves.length = 0;

                coins.forEach((coin) => scene.remove(coin));
                coins.length = 0;

                wolfProjectiles.forEach((p) => scene.remove(p));
                wolfProjectiles.length = 0;

                effects.forEach((effect) => {
                    effect.particles.forEach((particle) => scene.remove(particle));
                });
                effects.length = 0;

                sheeps.forEach((sheep) => scene.remove(sheep));
                sheeps.length = 0;

                treasureBoxes.forEach((box) => scene.remove(box));
                treasureBoxes.length = 0;

                bombBoxes.forEach((box) => scene.remove(box));
                bombBoxes.length = 0;

                platforms.forEach((platform) => scene.remove(platform));
                platforms.length = 0;

                bees.forEach((bee) => scene.remove(bee));
                bees.length = 0;

                beeStings.forEach((sting) => scene.remove(sting));
                beeStings.length = 0;

                spawnPlatforms();
                spawnNewSheeps();
                spawnWavesForRound();

                roundTransition.classList.remove("active");
                isRoundTransition = false;
                updateUI();
            }, 2000);
        }

        // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¯Ø§Ø®Ù„ Ø±Ø¨Ø¹ Ù…Ø¹ÙŠÙ†
        function isPlayerInQuarter(quarter) {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);
            
            return playerPos.x >= quarter.minX && playerPos.x <= quarter.maxX &&
                   playerPos.z >= quarter.minZ && playerPos.z <= quarter.maxZ;
        }

        // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ù‡Ø¯Ù Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø±Ø¨Ø¹
        function generateRandomTargetInQuarter(quarter) {
            return new THREE.Vector3(
                Math.random() * (quarter.maxX - quarter.minX) + quarter.minX,
                0,
                Math.random() * (quarter.maxZ - quarter.minZ) + quarter.minZ
            );
        }

        function moveWolves(deltaTime) {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            wolves.forEach((wolf) => {
                const wolfData = wolf.userData;
                const wolfPos = new THREE.Vector3();
                wolf.getWorldPosition(wolfPos);

                // ØªØ­Ø±ÙŠÙƒ Ø£Ø±Ø¬Ù„ Ø§Ù„Ø°Ø¦Ø¨
                animateWolfLegs(wolf, deltaTime);

                const distanceToPlayer = wolfPos.distanceTo(playerPos);

                // Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø°Ø¦Ø§Ø¨ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ø±Ø¨Ø¹
                if (wolfData.type === "normal") {
                    const quarter = wolfData.quarter;
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ø°Ø¦Ø¨
                    if (isPlayerInQuarter(quarter)) {
                        // Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø±Ø¨Ø¹ØŒ Ù„Ø°Ù„Ùƒ ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø°Ø¦Ø¨ Ø¨Ù…Ø·Ø§Ø±Ø¯ØªÙ‡
                        wolfData.isChasing = true;

                        const direction = new THREE.Vector3().subVectors(playerPos, wolfPos).normalize();
                        const newPosition = wolfPos.clone().add(direction.multiplyScalar(wolfData.speed * 1.5));

                        // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¨Ù‚Ø§Ø¡ Ø§Ù„Ø°Ø¦Ø¨ Ø¯Ø§Ø®Ù„ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø±Ø¨Ø¹
                        newPosition.x = Math.max(quarter.minX, Math.min(quarter.maxX, newPosition.x));
                        newPosition.z = Math.max(quarter.minZ, Math.min(quarter.maxZ, newPosition.z));

                        let collisionDetected = false;
                        const wolfBoundingSphere = new THREE.Sphere(newPosition, 2 * wolf.scale.x);

                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØµØ§Ø¯Ù… Ù…Ø¹ Ø§Ù„Ø¬Ø¨Ø§Ù„
                        for (const mountain of mountains) {
                            mountain.children.forEach((child) => {
                                const childBox = new THREE.Box3().setFromObject(child);
                                if (childBox.intersectsSphere(wolfBoundingSphere)) {
                                    collisionDetected = true;
                                }
                            });
                            if (collisionDetected) break;
                        }

                        if (!collisionDetected) {
                            wolf.position.x = newPosition.x;
                            wolf.position.z = newPosition.z;
                        }

                        // ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ø°Ø¦Ø¨ Ù†Ø­Ùˆ Ø§Ù„Ù„Ø§Ø¹Ø¨
                        wolf.lookAt(
                            wolf.position.x + direction.x,
                            wolf.position.y,
                            wolf.position.z + direction.z
                        );

                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØµØ§Ø¯Ù… Ù…Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙˆØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¶Ø±Ø±
                        if (distanceToPlayer < 3) {
                            const currentTime = Date.now();
                            if (currentTime - wolfData.lastCollisionTime > wolfData.collisionCooldown) {
                                playerHealth -= wolfData.collisionDamage;
                                wolfData.lastCollisionTime = currentTime;
                                showPlayerDamageEffect();
                                playDamageSound();
                                updateUI();
                            }
                        }
                    } else {
                        // Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø®Ø§Ø±Ø¬ Ø§Ù„Ø±Ø¨Ø¹ØŒ Ø§Ù„Ø°Ø¦Ø¨ ÙŠØªØ­Ø±Ùƒ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø±Ø¨Ø¹
                        wolfData.isChasing = false;
                        
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„Ù‡Ø¯Ù Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                        wolfData.targetTimer += deltaTime * 1000; // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ù…ÙŠÙ„ÙŠ Ø«Ø§Ù†ÙŠØ©
                        
                        // Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª Ø£Ùˆ ÙˆØµÙ„ Ø§Ù„Ø°Ø¦Ø¨ Ø¥Ù„Ù‰ Ø§Ù„Ù‡Ø¯ÙØŒ ØªÙˆÙ„ÙŠØ¯ Ù‡Ø¯Ù Ø¬Ø¯ÙŠØ¯
                        if (!wolfData.randomTarget || wolfPos.distanceTo(wolfData.randomTarget) < 2 || wolfData.targetTimer > 5000) {
                            wolfData.randomTarget = generateRandomTargetInQuarter(quarter);
                            wolfData.targetTimer = 0;
                        }
                        
                        // Ø§Ù„ØªØ­Ø±Ùƒ Ù†Ø­Ùˆ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                        const direction = new THREE.Vector3().subVectors(wolfData.randomTarget, wolfPos).normalize();
                        const newPosition = wolfPos.clone().add(direction.multiplyScalar(wolfData.speed * 0.5));

                        // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¨Ù‚Ø§Ø¡ Ø§Ù„Ø°Ø¦Ø¨ Ø¯Ø§Ø®Ù„ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø±Ø¨Ø¹
                        newPosition.x = Math.max(quarter.minX, Math.min(quarter.maxX, newPosition.x));
                        newPosition.z = Math.max(quarter.minZ, Math.min(quarter.maxZ, newPosition.z));

                        let collisionDetected = false;
                        const wolfBoundingSphere = new THREE.Sphere(newPosition, 2 * wolf.scale.x);

                        for (const mountain of mountains) {
                            mountain.children.forEach((child) => {
                                const childBox = new THREE.Box3().setFromObject(child);
                                if (childBox.intersectsSphere(wolfBoundingSphere)) {
                                    collisionDetected = true;
                                }
                            });
                            if (collisionDetected) break;
                        }

                        if (!collisionDetected) {
                            wolf.position.x = newPosition.x;
                            wolf.position.z = newPosition.z;
                        }

                        // ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ø°Ø¦Ø¨ Ù†Ø­Ùˆ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                        wolf.lookAt(
                            wolf.position.x + direction.x,
                            wolf.position.y,
                            wolf.position.z + direction.z
                        );
                    }
                }
                // Ø§Ù„Ø°Ø¦Ø§Ø¨ Ø§Ù„Ø´Ø±Ø³Ø© ØªØ¨Ù‚Ù‰ Ø­ÙˆÙ„ Ø§Ù„Ø®Ø±Ø§Ù
                else if (wolfData.isProtector && wolfData.protectedSheep) {
                    const sheepPos = new THREE.Vector3();
                    wolfData.protectedSheep.getWorldPosition(sheepPos);
                    
                    const distanceToSheep = playerPos.distanceTo(sheepPos);
                    
                    if (distanceToSheep < wolfData.guardRadius && distanceToPlayer < wolfData.detectionRange) {
                        wolfData.isChasing = true;

                        const direction = new THREE.Vector3().subVectors(playerPos, wolfPos).normalize();
                        const newPosition = wolfPos.clone().add(direction.multiplyScalar(wolfData.speed * 1.5));

                        let collisionDetected = false;
                        const wolfBoundingSphere = new THREE.Sphere(newPosition, 2 * wolf.scale.x);

                        for (const mountain of mountains) {
                            mountain.children.forEach((child) => {
                                const childBox = new THREE.Box3().setFromObject(child);
                                if (childBox.intersectsSphere(wolfBoundingSphere)) {
                                    collisionDetected = true;
                                }
                            });
                            if (collisionDetected) break;
                        }

                        if (!collisionDetected) {
                            wolf.position.x = newPosition.x;
                            wolf.position.z = newPosition.z;
                        }

                        wolf.lookAt(
                            wolf.position.x + direction.x,
                            wolf.position.y,
                            wolf.position.z + direction.z
                        );

                        if (distanceToPlayer < 3) {
                            const currentTime = Date.now();
                            if (currentTime - wolfData.lastCollisionTime > wolfData.collisionCooldown) {
                                playerHealth -= wolfData.collisionDamage;
                                wolfData.lastCollisionTime = currentTime;
                                showPlayerDamageEffect();
                                playDamageSound();
                                updateUI();
                            }
                        }
                    } else {
                        wolfData.isChasing = false;
                        
                        // Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ø­ÙˆÙ„ Ø§Ù„Ø®Ø±ÙˆÙ
                        const wolfToSheep = new THREE.Vector3().subVectors(wolfPos, sheepPos);
                        const distanceToSheepCenter = wolfToSheep.length();
                        
                        if (distanceToSheepCenter > wolfData.guardRadius / 2) {
                            const returnDirection = new THREE.Vector3().subVectors(sheepPos, wolfPos).normalize();
                            const returnPosition = sheepPos.clone().add(returnDirection.multiplyScalar(wolfData.guardRadius / 3));
                            
                            let collisionDetected = false;
                            const wolfBoundingSphere = new THREE.Sphere(returnPosition, 2 * wolf.scale.x);

                            for (const mountain of mountains) {
                                mountain.children.forEach((child) => {
                                    const childBox = new THREE.Box3().setFromObject(child);
                                    if (childBox.intersectsSphere(wolfBoundingSphere)) {
                                        collisionDetected = true;
                                    }
                                });
                                if (collisionDetected) break;
                            }

                            if (!collisionDetected) {
                                wolf.position.x = returnPosition.x;
                                wolf.position.z = returnPosition.z;
                            }
                        }
                    }
                } else {
                    wolfData.isChasing = false;
                }
            });
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù†Ø­Ù„
        function moveBees() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            bees.forEach((bee) => {
                const beeData = bee.userData;
                const beePos = new THREE.Vector3();
                bee.getWorldPosition(beePos);

                // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø£Ø¬Ù†Ø­Ø©
                beeData.wingFlapAngle += beeData.wingFlapSpeed * 0.01;
                const wingFlap = Math.sin(beeData.wingFlapAngle) * 0.3;
                
                bee.children.forEach((child) => {
                    if (child.position.x !== 0) { // Ø§Ù„Ø£Ø¬Ù†Ø­Ø© ÙÙ‚Ø·
                        child.rotation.x = wingFlap;
                    }
                });

                // Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨
                const distanceToPlayer = beePos.distanceTo(playerPos);
                
                if (distanceToPlayer < beeData.detectionRange) {
                    beeData.isChasing = true;
                    
                    const direction = new THREE.Vector3().subVectors(playerPos, beePos).normalize();
                    const newPosition = beePos.clone().add(direction.multiplyScalar(beeData.speed));
                    
                    // Ø§Ù„Ù†Ø­Ù„ ÙŠØ·ÙŠØ± ÙÙŠ Ø§Ù„Ù‡ÙˆØ§Ø¡
                    newPosition.y = 5 + Math.sin(Date.now() * 0.005) * 0.5; // Ø­Ø±ÙƒØ© ØªÙ…ÙˆØ¬ÙŠØ©
                    
                    // ØªØ¬Ù†Ø¨ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø¬Ø¨Ø§Ù„
                    let collisionDetected = false;
                    const beeBoundingSphere = new THREE.Sphere(newPosition, 0.8);
                    
                    for (const mountain of mountains) {
                        mountain.children.forEach((child) => {
                            const childBox = new THREE.Box3().setFromObject(child);
                            if (childBox.intersectsSphere(beeBoundingSphere)) {
                                collisionDetected = true;
                            }
                        });
                        if (collisionDetected) break;
                    }
                    
                    if (!collisionDetected) {
                        bee.position.x = newPosition.x;
                        bee.position.y = newPosition.y;
                        bee.position.z = newPosition.z;
                    }
                    
                    bee.lookAt(
                        bee.position.x + direction.x,
                        bee.position.y + direction.y,
                        bee.position.z + direction.z
                    );
                    
                    // Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨
                    if (distanceToPlayer < beeData.attackRange) {
                        const currentTime = Date.now();
                        if (currentTime - beeData.lastAttackTime > beeData.attackCooldown) {
                            // Ø¥Ø·Ù„Ø§Ù‚ Ù„Ø³Ø¹Ø©
                            createBeeSting(beePos, playerPos);
                            beeData.lastAttackTime = currentTime;
                        }
                    }
                    
                    // Ø¶Ø±Ø± Ø§Ù„ØªØµØ§Ø¯Ù…
                    if (distanceToPlayer < 1.5) {
                        const currentTime = Date.now();
                        if (currentTime - beeData.lastCollisionTime > beeData.collisionCooldown) {
                            playerHealth -= beeData.collisionDamage;
                            beeData.lastCollisionTime = currentTime;
                            showPlayerDamageEffect();
                            playDamageSound();
                            updateUI();
                        }
                    }
                } else {
                    beeData.isChasing = false;
                    
                    // Ø­Ø±ÙƒØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ø¹Ù†Ø¯Ù…Ø§ Ù„Ø§ ØªØ·Ø§Ø±Ø¯ Ø§Ù„Ù„Ø§Ø¹Ø¨
                    bee.position.x += (Math.random() - 0.5) * 0.05;
                    bee.position.z += (Math.random() - 0.5) * 0.05;
                    bee.position.y = 5 + Math.sin(Date.now() * 0.003) * 0.3;
                }
            });
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø±ÙŠÙƒ Ù„Ø³Ø¹Ø§Øª Ø§Ù„Ù†Ø­Ù„
        function moveBeeStings() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);
            
            for (let i = beeStings.length - 1; i >= 0; i--) {
                const sting = beeStings[i];
                const stingData = sting.userData;
                
                // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù„Ø³Ø¹Ø©
                sting.position.add(stingData.direction.clone().multiplyScalar(stingData.speed));
                stingData.distanceTraveled += stingData.speed;
                
                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù„Ø³Ø¹Ø© Ø¥Ø°Ø§ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ù‚ØµÙˆÙ‰
                if (stingData.distanceTraveled > stingData.maxDistance) {
                    scene.remove(sting);
                    beeStings.splice(i, 1);
                    continue;
                }
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ù„Ø§Ø¹Ø¨
                const stingPos = new THREE.Vector3();
                sting.getWorldPosition(stingPos);
                const distanceToPlayer = stingPos.distanceTo(playerPos);
                
                if (distanceToPlayer < 1.5) {
                    playerHealth -= stingData.damage;
                    scene.remove(sting);
                    beeStings.splice(i, 1);
                    showPlayerDamageEffect();
                    playDamageSound();
                    updateUI();
                }
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø¹Ø±Ø¶ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¶Ø±Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨
        function showPlayerDamageEffect() {
            playerDamageEffect.classList.add("active");
            setTimeout(() => {
                playerDamageEffect.classList.remove("active");
            }, 500);
        }

        function updateWolfProjectiles() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            for (let i = wolfProjectiles.length - 1; i >= 0; i--) {
                const projectile = wolfProjectiles[i];

                projectile.position.add(
                    projectile.userData.direction
                    .clone()
                    .multiplyScalar(projectile.userData.speed)
                );

                const distanceToOrigin = projectile.position.distanceTo(
                    new THREE.Vector3(0, 0, 0)
                );
                if (distanceToOrigin > 1000) {
                    scene.remove(projectile);
                    wolfProjectiles.splice(i, 1);
                    continue;
                }

                const distanceToPlayer = projectile.position.distanceTo(playerPos);
                if (distanceToPlayer < 2) {
                    playerHealth -= projectile.userData.damage;
                    updateUI();
                    scene.remove(projectile);
                    wolfProjectiles.splice(i, 1);
                    effects.push({
                        particles: createStickSwingEffect(playerPos),
                        createdAt: now,
                    });
                }
            }
        }

        function stickAttack() {
            if (!gameStarted || gameOver || isRoundTransition) return;

            const currentTime = Date.now();
            if (currentTime - lastAttackTime < attackCooldown) return;

            lastAttackTime = currentTime;

            // NEW: Play the stick sound when the attack happens
            playStickSound();

            // Trigger stick attack animation
            triggerStickAttack(playerModel);

            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            const attackRadius = 6;
            const damage = 50;

            const wolvesToDamage = [];
            for (let i = wolves.length - 1; i >= 0; i--) {
                const wolf = wolves[i];
                const wolfPos = new THREE.Vector3();
                wolf.getWorldPosition(wolfPos);
                const distance = wolfPos.distanceTo(playerPos);

                if (distance < attackRadius) {
                    wolvesToDamage.push(wolf);
                }
            }

            for (const wolf of wolvesToDamage) {
                wolf.userData.health -= damage;

                if (wolf.userData.health <= 0) {
                    scene.remove(wolf);
                    const index = wolves.indexOf(wolf);
                    if (index > -1) {
                        wolves.splice(index, 1);
                    }
                    coins.push(
                        createCoin(wolf.position.x, wolf.position.z, wolf.userData.value)
                    );
                    score += wolf.userData.isAggressive ? 25 : 10;
                    playMonsterExplosionSound();
                }
            }

            // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø­Ù„
            const beesToDamage = [];
            for (let i = bees.length - 1; i >= 0; i--) {
                const bee = bees[i];
                const beePos = new THREE.Vector3();
                bee.getWorldPosition(beePos);
                const distance = beePos.distanceTo(playerPos);

                if (distance < attackRadius) {
                    beesToDamage.push(bee);
                }
            }

            for (const bee of beesToDamage) {
                bee.userData.health -= damage;

                if (bee.userData.health <= 0) {
                    scene.remove(bee);
                    const index = bees.indexOf(bee);
                    if (index > -1) {
                        bees.splice(index, 1);
                    }
                    coins.push(createCoin(bee.position.x, bee.position.z, 8));
                    score += 8;
                    playMonsterExplosionSound();
                }
            }

            if (wolvesToDamage.length > 0 || beesToDamage.length > 0) {
                effects.push({
                    particles: createStickSwingEffect(playerPos),
                    createdAt: now,
                });
            }

            updateUI();
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªÙØ¬ÙŠØ± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© - ØªÙ… ØªØ­Ø³ÙŠÙ†Ù‡Ø§ Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù‚ÙˆØ©
        function explodeBomb() {
            if (!gameStarted || gameOver || isRoundTransition || bombs <= 0) return;

            // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø´Ø­Ù† Ù„ØªØ­Ø¯ÙŠØ¯ Ù‚ÙˆØ© Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
            const explosionRadius = bombMaxRadius * bombCharge;

            // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¶Ø±Ø± Ø¨Ø´ÙƒÙ„ ÙƒØ¨ÙŠØ±
            const damage = 150 + (bombCharge * 100); // Ø¶Ø±Ø± ÙŠØªØ±Ø§ÙˆØ­ Ø¨ÙŠÙ† 150 Ùˆ 250 (Ø²ÙŠØ§Ø¯Ø© ÙƒØ¨ÙŠØ±Ø©)

            bombs--; // ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„
            updateUI();

            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            // ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„Ø§Ù†ÙØ¬Ø§Ø±
            playBombSound();

            // Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø§Ù†ÙØ¬Ø§Ø±
            effects.push({
                particles: createBombExplosionEffect(playerPos),
                createdAt: Date.now(),
            });

            // Ø¥Ø¸Ù‡Ø§Ø± Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø¯Ù‰
            showBombRangeIndicator(playerPos, explosionRadius);

            const wolvesToDamage = [];
            for (let i = wolves.length - 1; i >= 0; i--) {
                const wolf = wolves[i];
                const wolfPos = new THREE.Vector3();
                wolf.getWorldPosition(wolfPos);
                const distance = wolfPos.distanceTo(playerPos);

                if (distance < explosionRadius) {
                    wolvesToDamage.push(wolf);
                }
            }

            for (const wolf of wolvesToDamage) {
                // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¶Ø±Ø± Ø¨Ø´ÙƒÙ„ ÙƒØ¨ÙŠØ±
                wolf.userData.health -= damage;

                if (wolf.userData.health <= 0) {
                    scene.remove(wolf);
                    const index = wolves.indexOf(wolf);
                    if (index > -1) {
                        wolves.splice(index, 1);
                    }
                    coins.push(
                        createCoin(wolf.position.x, wolf.position.z, wolf.userData.value)
                    );
                    score += wolf.userData.isAggressive ? 25 : 10;
                    playMonsterExplosionSound();
                }
            }

            // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø­Ù„
            const beesToDamage = [];
            for (let i = bees.length - 1; i >= 0; i--) {
                const bee = bees[i];
                const beePos = new THREE.Vector3();
                bee.getWorldPosition(beePos);
                const distance = beePos.distanceTo(playerPos);

                if (distance < explosionRadius) {
                    beesToDamage.push(bee);
                }
            }

            for (const bee of beesToDamage) {
                // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¶Ø±Ø± Ø¨Ø´ÙƒÙ„ ÙƒØ¨ÙŠØ±
                bee.userData.health -= damage;

                if (bee.userData.health <= 0) {
                    scene.remove(bee);
                    const index = bees.indexOf(bee);
                    if (index > -1) {
                        bees.splice(index, 1);
                    }
                    coins.push(createCoin(bee.position.x, bee.position.z, 8));
                    score += 8;
                    playMonsterExplosionSound();
                }
            }

            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø´Ø­Ù†
            bombCharge = 0;
            isChargingBomb = false;
            bombChargeIndicator.style.display = "none";
            bombBtn.classList.remove("charging");

            updateUI();
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¨Ø¯Ø¡ Ø´Ø­Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
        function startBombCharge() {
            if (!gameStarted || gameOver || isRoundTransition || bombs <= 0) return;

            isChargingBomb = true;
            bombCharge = 0;
            bombChargeIndicator.style.display = "block";
            bombBtn.classList.add("charging");
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø´Ø­Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
        function updateBombCharge() {
            if (!isChargingBomb) return;

            bombCharge = Math.min(1, bombCharge + bombChargeSpeed);
            bombChargeBar.style.width = `${bombCharge * 100}%`;

            // Ø¥Ø¸Ù‡Ø§Ø± Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø¯Ù‰ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø´Ø­Ù†
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);
            const explosionRadius = bombMaxRadius * bombCharge;
            showBombRangeIndicator(playerPos, explosionRadius);

            // Ø¥Ø°Ø§ ÙˆØµÙ„ Ø§Ù„Ø´Ø­Ù† Ø¥Ù„Ù‰ Ø£Ù‚ØµØ§Ù‡ØŒ ØªÙØ¬ÙŠØ± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
            if (bombCharge >= 1) {
                explodeBomb();
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¥Ø¸Ù‡Ø§Ø± Ù…Ø¤Ø´Ø± Ù…Ø¯Ù‰ Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
        function showBombRangeIndicator(position, radius) {
            // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø¤Ø´Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
            if (bombRangeIndicator) {
                scene.remove(bombRangeIndicator);
            }

            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¤Ø´Ø± Ø¬Ø¯ÙŠØ¯
            const geometry = new THREE.RingGeometry(radius - 0.5, radius + 0.5, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff5722,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            bombRangeIndicator = new THREE.Mesh(geometry, material);
            bombRangeIndicator.rotation.x = -Math.PI / 2;
            bombRangeIndicator.position.set(position.x, 0.1, position.z);
            scene.add(bombRangeIndicator);

            // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø¤Ø´Ø± Ø¨Ø¹Ø¯ ÙØªØ±Ø©
            setTimeout(() => {
                if (bombRangeIndicator) {
                    scene.remove(bombRangeIndicator);
                    bombRangeIndicator = null;
                }
            }, 2000);
        }

        function updateEffects() {
            const now = Date.now();
            for (let i = effects.length - 1; i >= 0; i--) {
                const effect = effects[i];
                if (now - effect.createdAt > 500) {
                    effect.particles.forEach((particle) => {
                        scene.remove(particle);
                    });
                    effects.splice(i, 1);
                } else {
                    effect.particles.forEach((particle) => {
                        particle.position.add(particle.userData.velocity);
                        particle.material.opacity = 0.8 * (1 - (now - effect.createdAt) / 500);
                    });
                }
            }
        }

        function rotateCoins() {
            coins.forEach((coin) => {
                coin.rotation.y += coin.userData.spinSpeed;

                coin.children.forEach((child) => {
                    if (child.userData && child.userData.angle !== undefined) {
                        child.userData.angle += coin.userData.sparkleSpeed;
                        child.position.set(
                            Math.cos(child.userData.angle) * 0.7,
                            0.1,
                            Math.sin(child.userData.angle) * 0.7
                        );
                        child.material.opacity = 0.5 + 0.5 * Math.sin(child.userData.angle * 2);
                    }
                });
            });
        }

        // ØªØ­Ø¯ÙŠØ« ÙˆÙ…ÙŠØ¶ ÙØªÙŠÙ„ ØµÙ†Ø§Ø¯ÙŠÙ‚ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„
        function updateBombBoxes() {
            const now = Date.now();
            bombBoxes.forEach((box) => {
                if (box.userData && box.userData.spark) {
                    box.userData.sparkTimer += 100;
                    if (box.userData.sparkTimer >= 500) {
                        box.userData.spark.visible = !box.userData.spark.visible;
                        box.userData.sparkTimer = 0;
                    }
                }
            });
        }

        // Ø¯Ø§Ù„Ø© Ø§Ù„Ù‚ÙØ²
        function jump() {
            if (!isJumping && !isRoundTransition) {
                isJumping = true;
                jumpVelocity = jumpPower;
                playJumpSound();

                // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø¨ØµØ±ÙŠ Ù„Ù„Ù‚ÙØ²
                const jumpEffect = document.createElement("div");
                jumpEffect.className = "jump-effect";

                const playerPos = new THREE.Vector3();
                player.getWorldPosition(playerPos);
                const vector = new THREE.Vector3(
                    playerPos.x,
                    playerPos.y,
                    playerPos.z
                );
                vector.project(camera);

                jumpEffect.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
                jumpEffect.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
                document.querySelector(".scene-container").appendChild(jumpEffect);

                setTimeout(() => {
                    jumpEffect.remove();
                }, 500);
            }
        }

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚ÙØ² ÙˆØ§Ù„Ø¬Ø§Ø°Ø¨ÙŠØ©
        function updateJumpAndGravity() {
            if (isJumping) {
                player.position.y += jumpVelocity;
                jumpVelocity -= gravity;

                if (player.position.y <= 0) {
                    player.position.y = 0;
                    isJumping = false;
                    jumpVelocity = 0;

                    // ØªØ£Ø«ÙŠØ± Ù‡Ø¨ÙˆØ·
                    playSound(300, "sine", 0.1, 0.2);
                }
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø­Ø±ÙƒØ© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
        function updatePlayerMovementFromJoystick() {
            if (!joystickActive) {
                velocity.multiplyScalar(deceleration);
                return;
            }

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§ØªØ¬Ø§Ù‡ Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
            const speed = Math.sqrt(joystickDirection.x ** 2 + joystickDirection.y ** 2);
            const normalizedSpeed = Math.min(speed, 1);

            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const forward = new THREE.Vector3()
                .copy(direction)
                .setY(0)
                .normalize();
            const right = new THREE.Vector3().crossVectors(
                forward,
                new THREE.Vector3(0, 1, 0)
            );

            // Ø­Ø³Ø§Ø¨ Ù…ØªØ¬Ù‡ Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ… ÙˆØ§ØªØ¬Ø§Ù‡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            const moveVector = new THREE.Vector3();
            moveVector.addScaledVector(right, joystickDirection.x * normalizedSpeed * maxSpeed);
            // Ø§Ù„ØªØµØ­ÙŠØ­: Ø¹ÙƒØ³ Ø¥Ø´Ø§Ø±Ø© joystickDirection.y Ù„ØªØµØ­ÙŠØ­ Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ù…Ø§Ù… ÙˆØ§Ù„Ø®Ù„Ù
            moveVector.addScaledVector(forward, -joystickDirection.y * normalizedSpeed * maxSpeed);

            velocity.x = moveVector.x;
            velocity.z = moveVector.z;
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø­Ø±ÙƒØ© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        function updatePlayerMovementFromKeyboard() {
            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const forward = new THREE.Vector3()
                .copy(direction)
                .setY(0)
                .normalize();
            const right = new THREE.Vector3().crossVectors(
                forward,
                new THREE.Vector3(0, 1, 0)
            );

            // Ø­Ø³Ø§Ø¨ Ù…ØªØ¬Ù‡ Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            const moveVector = new THREE.Vector3();

            // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… WASD Ø£Ùˆ Ø§Ù„Ø£Ø³Ù‡Ù…
            if (keys.w || keys.arrowup) {
                moveVector.add(forward);
            }
            if (keys.s || keys.arrowdown) {
                moveVector.sub(forward);
            }
            if (keys.a || keys.arrowleft) {
                moveVector.sub(right);
            }
            if (keys.d || keys.arrowright) {
                moveVector.add(right);
            }

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø³Ø±Ø¹Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø­Ø±ÙƒØ©
            if (moveVector.length() > 0) {
                moveVector.normalize();
                velocity.x = moveVector.x * maxSpeed;
                velocity.z = moveVector.z * maxSpeed;
            } else {
                // Ø¥Ø¨Ø·Ø§Ø¡ Ø§Ù„Ø­Ø±ÙƒØ© Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø¥Ø¯Ø®Ø§Ù„
                velocity.multiplyScalar(deceleration);
            }
        }

        function movePlayer() {
            if (isRoundTransition) return;

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
            updatePlayerMovementFromJoystick();

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            updatePlayerMovementFromKeyboard();

            let newPosition = player.position.clone().add(velocity);
            newPosition = checkWorldBounds(newPosition);

            let collisionDetected = false;
            const playerBoundingSphere = new THREE.Sphere(newPosition, 2);

            // ÙØ­Øµ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ù…Ø¹ Ø§Ù„Ø¬Ø¨Ø§Ù„ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¨ÙŠÙˆØª
            for (const mountain of mountains) {
                mountain.children.forEach((child) => {
                    const childBox = new THREE.Box3().setFromObject(child);
                    if (childBox.intersectsSphere(playerBoundingSphere)) {
                        collisionDetected = true;
                    }
                });
                if (collisionDetected) break;
            }

            // ÙØ­Øµ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ù…Ø¹ Ø§Ù„Ù…Ù†ØµØ§Øª
            if (!collisionDetected) {
                for (const platform of platforms) {
                    const platformBox = new THREE.Box3().setFromObject(platform);
                    if (platformBox.intersectsSphere(playerBoundingSphere)) {
                        collisionDetected = true;
                        if (
                            newPosition.y < platform.position.y + platform.geometry.parameters.height / 2 + 1
                        ) {
                            newPosition.y = platform.position.y + platform.geometry.parameters.height / 2;
                            isJumping = false;
                            jumpVelocity = 0;
                        }
                    }
                }
            }

            if (!collisionDetected) {
                player.position.x = newPosition.x;
                player.position.z = newPosition.z;
            } else {
                velocity.set(0, 0, 0);
            }

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚ÙØ²
            updateJumpAndGravity();

            // ØªØ­Ø¯ÙŠØ« Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø±ÙƒØ©
            if (velocity.length() > 0.1) {
                const targetAngle = Math.atan2(velocity.x, velocity.z);
                playerModel.rotation.y = targetAngle;
            }
        }

        // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù„Ø´Ø®Øµ Ø«Ø§Ù„Ø« - ØªÙ… ØªØ­Ø³ÙŠÙ†Ù‡Ø§
        function updateThirdPersonCamera() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            // Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø®Ù„Ù Ø§Ù„Ù„Ø§Ø¹Ø¨
            const cameraOffset = new THREE.Vector3(
                Math.sin(cameraAngle) * cameraDistance,
                cameraHeight,
                Math.cos(cameraAngle) * cameraDistance
            );

            // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            camera.position.copy(playerPos).add(cameraOffset);

            // ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„ÙƒØ§Ù…Ø±Ø§ Ù†Ø­Ùˆ Ø§Ù„Ù„Ø§Ø¹Ø¨
            camera.lookAt(playerPos);
        }

        function collectCoins() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            for (let i = coins.length - 1; i >= 0; i--) {
                const coinPos = new THREE.Vector3();
                coins[i].getWorldPosition(coinPos);
                const distance = playerPos.distanceTo(coinPos);

                if (distance < 3) {
                    coinsCollected += coins[i].userData.value;
                    showCoinAnimation(
                        coinPos.x,
                        coinPos.y + 2,
                        coinPos.z,
                        coins[i].userData.value
                    );
                    scene.remove(coins[i]);
                    coins.splice(i, 1);
                    updateUI();
                    playCoinSound();
                }
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¬Ù…Ø¹ Ø§Ù„Ø®Ø±Ø§Ù
        function collectSheep() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            for (let i = sheeps.length - 1; i >= 0; i--) {
                const sheepPos = new THREE.Vector3();
                sheeps[i].getWorldPosition(sheepPos);
                const distance = playerPos.distanceTo(sheepPos);

                if (distance < 5) {
                    sheepCollected++;
                    showSheepAnimation(
                        sheepPos.x,
                        sheepPos.y + 2,
                        sheepPos.z
                    );
                    scene.remove(sheeps[i]);
                    sheeps.splice(i, 1);
                    updateUI();
                    playSheepSound();

                    // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø²Ø§Ù„Ø© Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ winGame() ÙˆØ§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙ‚Ø·
                    // Ù‡Ø°Ø§ ÙŠØ³Ù…Ø­ Ø¨Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ¹Ø±Ø¶ Ø²Ø± Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
                    if (sheepCollected >= 5) {
                        // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø¶Ø§ÙØ© Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†Ø¬Ø§Ø­ Ø¹Ù†Ø¯ Ø¬Ù…Ø¹ 5 Ø®Ø±Ø§Ù
                        showSuccessMessage();
                        updateUI(); // Ù‡Ø°Ø§ Ø³ÙŠØ¸Ù‡Ø± Ø²Ø± Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
                    }
                }
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¬Ù…Ø¹ ØµÙ†Ø§Ø¯ÙŠÙ‚ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„
        function collectBombBoxes() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            for (let i = bombBoxes.length - 1; i >= 0; i--) {
                const boxPos = new THREE.Vector3();
                bombBoxes[i].getWorldPosition(boxPos);
                const distance = playerPos.distanceTo(boxPos);

                if (distance < 3) {
                    bombs += 1; // Ø¥Ø¶Ø§ÙØ© Ù‚Ù†Ø¨Ù„Ø© ÙˆØ§Ø­Ø¯Ø©
                    showBombAnimation(boxPos.x, boxPos.y + 2, boxPos.z);
                    scene.remove(bombBoxes[i]);
                    bombBoxes.splice(i, 1);
                    updateUI();
                    playGiftSound();
                }
            }
        }

        function showCoinAnimation(x, y, z, value) {
            const coinDiv = document.createElement("div");
            coinDiv.className = "coin-animation";
            coinDiv.textContent = `+${value}`;

            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);

            coinDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            coinDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(coinDiv);

            setTimeout(() => {
                coinDiv.remove();
            }, 1500);
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø¹ Ø§Ù„Ø®Ø±Ø§Ù
        function showSheepAnimation(x, y, z) {
            const sheepDiv = document.createElement("div");
            sheepDiv.className = "coin-animation";
            sheepDiv.textContent = `+1 Ø®Ø±ÙˆÙ`;
            sheepDiv.style.color = "#ffffff";

            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);

            sheepDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            sheepDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(sheepDiv);

            setTimeout(() => {
                sheepDiv.remove();
            }, 1500);
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø¹ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„
        function showBombAnimation(x, y, z) {
            const bombDiv = document.createElement("div");
            bombDiv.className = "coin-animation";
            bombDiv.textContent = `+1 Ù‚Ù†Ø¨Ù„Ø©`;
            bombDiv.style.color = "#ff5722";

            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);

            bombDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            bombDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(bombDiv);

            setTimeout(() => {
                bombDiv.remove();
            }, 1500);
        }

        function increaseDifficulty() {
            if (score >= level * 100) {
                level++;
                updateUI();
            }
        }

        function checkGameState() {
            if (playerHealth <= 0) {
                gameOverPanel.querySelector("h2").textContent = "Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!";
                gameOverPanel.querySelector("p").textContent = "ØµØ­ØªÙƒ ÙˆØµÙ„Øª Ù„Ù„ØµÙØ±!";
                endGame();
                return;
            }

            // Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø´Ø±Ø· Ø§Ù„Ø°ÙŠ ÙŠÙ†ØªÙ‡ÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù†Ø¯ Ø¬Ù…Ø¹ 5 Ø®Ø±Ø§Ù
            // Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø°Ù„ÙƒØŒ Ø³ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø¸Ù‡ÙˆØ± Ø²Ø± Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© ÙÙ‚Ø·
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ÙÙˆØ² Ø¨Ø§Ù„Ù„Ø¹Ø¨Ø©
        function winGame() {
            gameOverPanel.querySelector("h2").textContent = "ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! Ù„Ù‚Ø¯ ÙØ²Øª!";
            gameOverPanel.querySelector("p").textContent = "Ù„Ù‚Ø¯ Ø¬Ù…Ø¹Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®Ø±Ø§Ù Ø§Ù„Ø¶Ø§Ø¦Ø¹Ø©!";
            endGame();
        }

        function endGame() {
            gameStarted = false;
            gameOver = true;
            finalScore.textContent = score;
            finalCoins.textContent = coinsCollected;
            gameOverPanel.style.display = "block";
        }

        function restartGame() {
            wolves.forEach((wolf) => scene.remove(wolf));
            wolves.length = 0;

            wolfProjectiles.forEach((p) => scene.remove(p));
            wolfProjectiles.length = 0;

            effects.forEach((effect) => {
                effect.particles.forEach((particle) => {
                    scene.remove(particle);
                });
            });
            effects.length = 0;

            coins.forEach((coin) => scene.remove(coin));
            coins.length = 0;

            sheeps.forEach((sheep) => scene.remove(sheep));
            sheeps.length = 0;

            treasureBoxes.forEach((box) => scene.remove(box));
            treasureBoxes.length = 0;

            bombBoxes.forEach((box) => scene.remove(box));
            bombBoxes.length = 0;

            platforms.forEach((platform) => scene.remove(platform));
            platforms.length = 0;

            mountains.forEach((mountain) => scene.remove(mountain)); // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¬Ø¨Ø§Ù„
            mountains.length = 0;

            bees.forEach((bee) => scene.remove(bee));
            bees.length = 0;

            beeStings.forEach((sting) => scene.remove(sting));
            beeStings.length = 0;

            score = 0;
            coinsCollected = 0;
            sheepCollected = 0; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø®Ø±Ø§Ù Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
            bombs = 0; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„
            level = 1;
            round = 1;
            gameOver = false;
            playerSpeed = 1.0; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø³Ø±Ø¹Ø©
            playerHealth = 100;
            isJumping = false;

            player.position.set(0, 0, 0);
            player.rotation.set(0, 0, 0);
            camera.position.set(0, 5, 8);
            camera.rotation.set(0, 0, 0);

            updateUI();
            gameOverPanel.style.display = "none";
            gameStarted = true;

            spawnMountains(); // Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¨Ø§Ù„
            createWorldBoundsVisual();
            spawnPlatforms();
            spawnNewSheeps();
            spawnWavesForRound();
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªÙ‡ÙŠØ¦Ø© Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ… - Ù…Ø¹Ø¯Ù„Ø© ÙˆÙ…Ø­Ø³Ù†Ø©
        function setupJoystickControls() {
            const joystickContainer = document.querySelector('.joystick-container');
            
            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù„Ù…Ø³ Ù„Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
            joystickContainer.addEventListener('touchstart', handleJoystickStart, {
                passive: false
            });
            window.addEventListener('touchmove', handleJoystickMove, {
                passive: false
            });
            window.addEventListener('touchend', handleJoystickEnd, {
                passive: false
            });

            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø§ÙˆØ³ Ù„Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
            joystickContainer.addEventListener('mousedown', handleJoystickStart);
            window.addEventListener('mousemove', handleJoystickMove);
            window.addEventListener('mouseup', handleJoystickEnd);
            
            // Ù…Ù†Ø¹ Ø§Ù„Ø³Ù„ÙˆÙƒ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù…Ù†Ø¹ Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø¹Ù†Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¹Ø¬Ù„Ø©
            joystickContainer.addEventListener('touchstart', (e) => e.preventDefault());
            joystickContainer.addEventListener('touchmove', (e) => e.preventDefault());
        }

        function handleJoystickStart(e) {
            if (!gameStarted || gameOver || isRoundTransition) return;

            e.preventDefault();
            joystickActive = true;
            joystickHandle.classList.add('active');

            // Ø­Ø³Ø§Ø¨ Ù…Ø±ÙƒØ² Ø§Ù„Ø¹Ø¬Ù„Ø© Ø¹Ù†Ø¯ ÙƒÙ„ Ø¨Ø¯Ø¡ Ù„Ù…Ø³
            const rect = joystickBase.getBoundingClientRect();
            joystickCenterX = rect.left + rect.width / 2;
            joystickCenterY = rect.top + rect.height / 2;

            // Ø¨Ø¯Ø¡ Ø§Ù„Ø­Ø±ÙƒØ© Ù…Ù† Ø§Ù„Ù…Ø±ÙƒØ²
            joystickDirection.x = 0;
            joystickDirection.y = 0;

            if (e.type === 'touchstart') {
                joystickTouchId = e.changedTouches[0].identifier;
                // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ù‚Ø¨Ø¶ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„Ù„Ù…Ø³
                updateJoystickPosition(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            } else {
                // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ù‚Ø¨Ø¶ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø§ÙˆØ³
                updateJoystickPosition(e.clientX, e.clientY);
            }
        }

        function handleJoystickMove(e) {
            if (!joystickActive) return;

            e.preventDefault();

            let clientX, clientY;

            if (e.type === 'touchmove') {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickTouchId);
                if (!touch) return;
                clientX = touch.clientX;
                clientY = touch.clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ù‚Ø¨Ø¶
            updateJoystickPosition(clientX, clientY);
        }

        function updateJoystickPosition(clientX, clientY) {
            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© Ù…Ù† Ù…Ø±ÙƒØ² Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
            const deltaX = clientX - joystickCenterX;
            const deltaY = clientY - joystickCenterY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚Ø© Ù…ÙŠØªØ© (5% Ù…Ù† Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±)
            const deadZone = joystickRadius * 0.05;

            if (distance <= deadZone) {
                joystickDirection.x = 0;
                joystickDirection.y = 0;
                joystickHandle.style.transform = 'translate(-50%, -50%)';
                return;
            }

            // ØªØ­Ø¯ÙŠØ¯ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù†Ù‚Ø·Ø© Ø¯Ø§Ø®Ù„ Ø¯Ø§Ø¦Ø±Ø© Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
            if (distance <= joystickRadius) {
                // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø± Ù…Ø¹ Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…ÙŠØªØ©
                const effectiveDistance = Math.min(distance, joystickRadius);
                const normalizedDistance = (effectiveDistance - deadZone) / (joystickRadius - deadZone);
                
                joystickDirection.x = (deltaX / distance) * normalizedDistance;
                joystickDirection.y = (deltaY / distance) * normalizedDistance;

                // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ù‚Ø¨Ø¶
                joystickHandle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            } else {
                // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù†Ù‚Ø·Ø© Ø®Ø§Ø±Ø¬ Ø¯Ø§Ø¦Ø±Ø© Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…ØŒ Ù†Ø­Ø¯Ù‡Ø§ Ø¥Ù„Ù‰ Ø¯Ø§Ø¦Ø±Ø© Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±
                const angle = Math.atan2(deltaY, deltaX);
                joystickDirection.x = Math.cos(angle);
                joystickDirection.y = Math.sin(angle);

                // Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ù‚Ø¨Ø¶ Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯
                const limitedX = Math.cos(angle) * joystickRadius;
                const limitedY = Math.sin(angle) * joystickRadius;
                
                joystickHandle.style.transform = `translate(calc(-50% + ${limitedX}px), calc(-50% + ${limitedY}px))`;
            }
        }

        function handleJoystickEnd(e) {
            if (!joystickActive) return;

            e.preventDefault();

            if (e.type === 'touchend') {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickTouchId);
                if (!touch) return;
            }

            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
            joystickActive = false;
            joystickTouchId = null;
            joystickDirection.x = 0;
            joystickDirection.y = 0;
            joystickHandle.classList.remove('active');
            joystickHandle.style.transform = 'translate(-50%, -50%)';
        }

        function getTouchTarget(touch) {
            return document.elementFromPoint(touch.clientX, touch.clientY);
        }

        function isMovementButton(element) {
            return element.classList.contains("movement-btn");
        }

        function isAttackButton(element) {
            return element.id === "attackBtn";
        }

        function isJumpButton(element) {
            return element.id === "jumpBtn";
        }

        function isBombButton(element) {
            return element.id === "bombBtn";
        }

        function setupMultiTouchControls() {
            window.addEventListener(
                "touchstart",
                (e) => {
                    if (!gameStarted || gameOver || isRoundTransition) return;

                    for (const touch of e.changedTouches) {
                        const targetElement = getTouchTarget(touch);

                        if (isAttackButton(targetElement)) {
                            buttonTouchIds.set(touch.identifier, targetElement);
                            stickAttack();
                        } else if (isJumpButton(targetElement)) {
                            buttonTouchIds.set(touch.identifier, targetElement);
                            jump();
                        } else if (isBombButton(targetElement)) {
                            buttonTouchIds.set(touch.identifier, targetElement);
                            // Ø¨Ø¯Ø¡ Ø´Ø­Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ØªÙØ¬ÙŠØ±Ù‡Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©
                            startBombCharge();
                        } else if (!cameraTouchId) {
                            cameraTouchId = touch.identifier;
                            previousTouchX = touch.clientX;
                            previousTouchY = touch.clientY;
                        }
                    }
                }, {
                    passive: true
                }
            );

            window.addEventListener(
                "touchmove",
                (e) => {
                    if (!gameStarted || gameOver || isRoundTransition) return;

                    for (const touch of e.changedTouches) {
                        if (touch.identifier === cameraTouchId) {
                            const deltaX = touch.clientX - previousTouchX;
                            const deltaY = touch.clientY - previousTouchY;

                            // ØªØ¯ÙˆÙŠØ± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø­ÙˆÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨
                            cameraAngle -= deltaX * touchSensitivity;
                            cameraHeight = Math.max(
                                1,
                                Math.min(10, cameraHeight - deltaY * 0.01)
                            );

                            previousTouchX = touch.clientX;
                            previousTouchY = touch.clientY;
                        }
                    }
                }, {
                    passive: true
                }
            );

            window.addEventListener("touchend", (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;

                for (const touch of e.changedTouches) {
                    if (touch.identifier === cameraTouchId) {
                        cameraTouchId = null;
                    } else if (buttonTouchIds.has(touch.identifier)) {
                        const targetElement = buttonTouchIds.get(touch.identifier);
                        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø²Ø± Ø§Ù„Ù…Ø¶ØºÙˆØ· Ù‡Ùˆ Ø²Ø± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©ØŒ ØªÙØ¬ÙŠØ± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
                        if (isBombButton(targetElement) && isChargingBomb) {
                            explodeBomb();
                        }
                        buttonTouchIds.delete(touch.identifier);
                    }
                }
            });
        }

        function setupMouseControls() {
            window.addEventListener("mousedown", (e) => {
                if (!gameStarted || e.target !== canvas || gameOver || isRoundTransition) return;
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
                document.body.classList.add("dragging");
            });

            window.addEventListener("mouseup", () => {
                isDragging = false;
                document.body.classList.remove("dragging");
            });

            window.addEventListener("mousemove", (e) => {
                if (!gameStarted || !isDragging || gameOver || isRoundTransition) return;
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;

                // ØªØ¯ÙˆÙŠØ± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø­ÙˆÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨
                cameraAngle -= deltaX * mouseSensitivity;
                cameraHeight = Math.max(1, Math.min(10, cameraHeight - deltaY * 0.01));

                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            });
        }

        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        function setupKeyboardControls() {
            document.addEventListener("keydown", (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;

                const key = e.key.toLowerCase();
                
                // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ø¶ØºÙˆØ·Ø©
                if (keys.hasOwnProperty(key)) {
                    keys[key] = true;
                }

                switch (key) {
                    case " ": // Ù…ÙØªØ§Ø­ Ø§Ù„Ù…Ø³Ø§ÙØ© Ù„Ù„Ù‚ÙØ²
                        jump();
                        break;
                    case "f": // Ù…ÙØªØ§Ø­ F Ù„Ù„Ù‡Ø¬ÙˆÙ… Ø¨Ø§Ù„Ø¹ØµØ§
                        stickAttack();
                        break;
                    case "b": // Ù…ÙØªØ§Ø­ B Ù„ØªÙØ¬ÙŠØ± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
                        if (e.repeat) return; // Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
                        startBombCharge();
                        break;
                }
            });

            document.addEventListener("keyup", (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;

                const key = e.key.toLowerCase();
                
                // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ø±ÙÙˆØ¹Ø©
                if (keys.hasOwnProperty(key)) {
                    keys[key] = false;
                }

                switch (key) {
                    case "b": // Ù…ÙØªØ§Ø­ B Ù„ØªÙØ¬ÙŠØ± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
                        if (isChargingBomb) {
                            explodeBomb();
                        }
                        break;
                }
            });
        }

        // ØªØ¹Ø¯ÙŠÙ„ Ø£Ø­Ø¯Ø§Ø« Ø²Ø± Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© Ù„Ø¯Ø¹Ù… Ø§Ù„Ø´Ø­Ù†
        bombBtn.addEventListener("mousedown", startBombCharge);
        bombBtn.addEventListener("mouseup", explodeBomb);
        bombBtn.addEventListener("mouseleave", () => {
            if (isChargingBomb) {
                explodeBomb();
            }
        });

        attackBtn.addEventListener("mousedown", stickAttack);
        jumpBtn.addEventListener("mousedown", jump);

        restartBtn.addEventListener("click", restartGame);
        nextRoundBtn.addEventListener("click", nextRound);

        // Ù‡Ù†Ø§ ÙŠÙƒÙ…Ù† Ø§Ù„Ø­Ù„!
        startGameBtn.addEventListener("click", () => {
            startScreen.style.display = "none";
            scoreDisplay.style.display = "block";
            coinsDisplay.style.display = "block";
            sheepDisplay.style.display = "block"; // Ø¥Ø¸Ù‡Ø§Ø± Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø±Ø§Ù
            bombsDisplay.style.display = "block"; // Ø¥Ø¸Ù‡Ø§Ø± Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„
            healthIndicator.style.display = "block";
            roundIndicator.style.display = "block";
            laserSight.style.display = "block";

            gameStarted = true;
            spawnMountains(); // Ø§Ø³ØªØ¨Ø¯Ù„ spawnHouses Ø¨Ù€ spawnMountains
            createWorldBoundsVisual();
            spawnPlatforms();
            spawnNewSheeps();
            spawnWavesForRound();
            updateUI();

            setupMouseControls();
            setupMultiTouchControls();
            setupJoystickControls(); // ØªÙ‡ÙŠØ¦Ø© Ø¹Ø¬Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ…
            setupKeyboardControls(); // ØªÙ‡ÙŠØ¦Ø© ØªØ­ÙƒÙ… Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        });

        function checkTreasureBoxCollision() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            for (let i = treasureBoxes.length - 1; i >= 0; i--) {
                const box = treasureBoxes[i];
                const boxPos = new THREE.Vector3();
                box.getWorldPosition(boxPos);
                const distance = playerPos.distanceTo(boxPos);

                if (distance < 3 && box.userData.isHealthBox) {
                    freezeGame();
                    showMathQuestion(box);
                    playBoxSound();
                    return;
                }
            }
        }

        function freezeGame() {
            isGameFrozen = true;
            cancelAnimationFrame(gameLoopId);
        }

        function unfreezeGame() {
            isGameFrozen = false;
            animate();
        }

        function showMathQuestion(box) {
            const questionData = generateMathQuestion();
            questionText.textContent = questionData.question;

            // Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ© ÙÙŠ Ø³Ø·Ø± Ù…Ø³ØªÙ‚Ù„
            if (questionData.sequence) {
                displaySequence(questionData.sequence);
                sequenceContainer.style.display = 'block';
            } else {
                sequenceContainer.style.display = 'none';
            }

            optionsContainer.innerHTML = "";
            questionData.options.forEach((option) => {
                const button = document.createElement("button");
                button.className = "option-btn";
                button.textContent = option;
                button.addEventListener("click", () => {
                    handleAnswer(option, questionData.answer, box);
                });
                optionsContainer.appendChild(button);
            });

            questionPanel.style.display = "block";
        }

        function handleAnswer(selectedOption, correctAnswer, box) {
            const isCorrect = selectedOption === correctAnswer;
            let prizeMessage = "Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©!";
            let isWin = false;

            if (isCorrect) {
                isWin = true;
                const rewardType = Math.floor(Math.random() * 3);
                switch (rewardType) {
                    case 0:
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 20);
                        prizeMessage = "Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: ØµØ­Ø© Ø¥Ø¶Ø§ÙÙŠØ©!";
                        break;
                    case 1:
                        bombs += 2; // Ø¥Ø¶Ø§ÙØ© Ù‚Ù†Ø§Ø¨Ù„ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ù‚ÙˆØ© Ø¥Ø¶Ø§ÙÙŠØ©
                        prizeMessage = "Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: Ù‚Ù†Ø§Ø¨Ù„ Ø¥Ø¶Ø§ÙÙŠØ©!";
                        break;
                    case 2:
                        const sheepX = Math.random() * 800 - 400;
                        const sheepZ = Math.random() * 800 - 400;
                        sheeps.push(createSheep(sheepX, 2, sheepZ));
                        totalSheeps++;
                        prizeMessage = "Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: Ø´Ø§Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ù‚Ø·ÙŠØ¹!";
                        break;
                }
                playGiftSound();
            }

            showAnswerMessage(isWin, prizeMessage);
            scene.remove(box);
            const boxIndex = treasureBoxes.indexOf(box);
            if (boxIndex > -1) {
                treasureBoxes.splice(boxIndex, 1);
            }
            questionPanel.style.display = "none";
            unfreezeGame();
            updateUI();
        }

        function showAnswerMessage(isCorrect, message) {
            const messageDiv = document.createElement("div");
            messageDiv.className = "answer-message";
            if (!isCorrect) {
                messageDiv.classList.add("incorrect");
            }
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                messageDiv.remove();
            }, 1500);
        }

        let lastTime = 0;

        function animate(time) {
            gameLoopId = requestAnimationFrame(animate);

            if (isGameFrozen) {
                return;
            }

            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;

            if (gameStarted && !gameOver) {
                movePlayer();
                moveWolves(deltaTime); // ØªÙ…Ø±ÙŠØ± deltaTime
                moveBees(); // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù†Ø­Ù„
                moveBeeStings(); // ØªØ­Ø±ÙŠÙƒ Ù„Ø³Ø¹Ø§Øª Ø§Ù„Ù†Ø­Ù„
                updateWolfProjectiles();
                rotateCoins();
                collectCoins();
                collectSheep(); // Ø¥Ø¶Ø§ÙØ© Ø¬Ù…Ø¹ Ø§Ù„Ø®Ø±Ø§Ù
                collectBombBoxes(); // Ø¥Ø¶Ø§ÙØ© Ø¬Ù…Ø¹ ØµÙ†Ø§Ø¯ÙŠÙ‚ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„
                checkTreasureBoxCollision();
                updateEffects();
                updateBombBoxes(); // ØªØ­Ø¯ÙŠØ« ØµÙ†Ø§Ø¯ÙŠÙ‚ Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„

                // ØªØ­Ø¯ÙŠØ« Ø´Ø­Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©
                if (isChargingBomb) {
                    updateBombCharge();
                }

                increaseDifficulty();
                checkGameState();
                updateUI();

                // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
                updateThirdPersonCamera();

                // ØªØ­Ø±ÙŠÙƒ ÙŠØ¯ Ø§Ù„Ø±Ø§Ø¹ÙŠ ÙˆØ£Ø±Ø¬Ù„Ù‡Ø§ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø´ÙŠ
                if ((joystickActive && (joystickDirection.x !== 0 || joystickDirection.y !== 0)) || 
                    (keys.w || keys.a || keys.s || keys.d || keys.arrowup || keys.arrowleft || keys.arrowdown || keys.arrowright)) {
                    animateWalking(playerModel, deltaTime);
                    animateLegs(playerModel, deltaTime);
                } else {
                    // Ø¥ÙŠÙ‚Ø§Ù Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ø±Ø¬Ù„ ÙˆØ§Ù„Ø£Ø°Ø±Ø¹ Ø¹Ù†Ø¯ Ø§Ù„ØªÙˆÙ‚Ù
                    playerModel.userData.walkCycle = 0;
                }

                // ØªØ­Ø±ÙŠÙƒ ÙŠØ¯ Ø§Ù„Ø±Ø§Ø¹ÙŠ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù‡Ø¬ÙˆÙ…
                animateStickAttack(playerModel, deltaTime);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener("resize", () => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        window.onload = function() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);

            animate();
        };
    </script>
</body>
</html>
