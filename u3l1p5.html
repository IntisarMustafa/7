<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>لعبة البجعة في البحيرة الكبيرة</title>
    <!-- استدعاء MathJax لعرض المعادلات الرياضية بشكل جميل -->
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            direction: rtl;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            touch-action: none;
            user-select: none;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 100;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            font-size: 1.5rem;
        }
        #game-stats {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }
        .stat-item {
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 1.1rem;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        #controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            max-width: 250px;
            z-index: 100;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
            display: none;
        }
        #controls-info h3 {
            margin: 0 0 10px 0;
            color: #FFD700;
        }
        #joystick-container {
            position: absolute;
            bottom: 100px;
            right: 100px;
            width: 120px;
            height: 120px;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #joystick {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
        }
        #joystick-handle {
            width: 40px;
            height: 40px;
            background-color: rgba(50, 50, 200, 0.7);
            border-radius: 50%;
            cursor: move;
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 25px;
            border-radius: 20px;
            text-align: center;
            z-index: 200;
            width: 85%;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.5);
        }
        .instructions h2 {
            margin-top: 0;
            color: #FFD700;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .instructions p {
            margin: 15px 0;
            font-size: 18px;
            line-height: 1.6;
        }
        .instructions-list {
            text-align: right;
            margin: 20px 0;
            padding: 0 15px;
        }
        .instructions-list li {
            margin-bottom: 12px;
            font-size: 16px;
        }
        .key-icon {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 5px;
            margin: 0 5px;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .duck-icon {
            font-size: 40px;
            margin: 10px 0;
            display: block;
        }
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 300;
            display: none;
            transition: opacity 0.3s ease;
        }
        #game-modal {
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            color: white;
            border: 3px solid gold;
            max-width: 500px;
            width: 80%;
            display: none;
            transition: transform 0.3s ease;
        }
        #game-modal h2 {
            color: gold;
            margin-top: 0;
        }
        #restart-button {
            background: linear-gradient(to bottom, #2196F3, #1976D2);
            color: white;
            border: none;
            padding: 12px 30px;
            margin-top: 20px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
        }
        #restart-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(to bottom, #42A5F5, #2196F3);
        }
        #quiz-modal {
            background-color: #87CEEB;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            display: none;
            text-align: center;
            color: #333;
            max-width: 600px;
            width: 90%;
            transition: transform 0.3s ease;
        }
        .quiz-question-box {
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #555;
            margin-bottom: 20px;
        }
        #math-question-text {
            font-size: 2.5rem;
            font-weight: bold;
            margin: 0;
            color: #1a1a1a;
        }
        .options-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .option-button {
            background-color: #f0f0f0;
            color: #333;
            border: 2px solid #ccc;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        .option-button:hover {
            background-color: #ddd;
            border-color: #999;
        }
        .option-button.correct {
            background-color: #4CAF50;
            color: white;
            border-color: #388E3C;
        }
        .option-button.incorrect {
            background-color: #F44336;
            color: white;
            border-color: #D32F2F;
        }
        @media (max-width: 768px) {
            .instructions {
                width: 90%;
                padding: 20px;
            }
            .instructions h2 {
                font-size: 24px;
            }
            .instructions p {
                font-size: 16px;
            }
            #joystick-container {
                bottom: 80px;
                right: 50px;
                width: 100px;
                height: 100px;
            }
            #joystick {
                width: 70px;
                height: 70px;
            }
            #joystick-handle {
                width: 35px;
                height: 35px;
            }
            #controls-info {
                bottom: 15px;
                left: 15px;
                padding: 10px;
                font-size: 14px;
                max-width: 200px;
            }
            .options-container {
                grid-template-columns: 1fr;
            }
            #math-question-text {
                font-size: 1.5rem;
            }
        }
        #music-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            width: 45px;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }
        #start-button {
            background: linear-gradient(to bottom, #4CAF50, #388E3C);
            color: white;
            border: none;
            padding: 12px 30px;
            margin-top: 20px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 201;
        }
        #start-button:hover {
            transform: translate(-50%, -2px);
            box-shadow: 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(to bottom, #66BB6A, #4CAF50);
        }
        .game-playing #info {
            display: none;
        }
        .game-playing #welcome-message, .game-playing #start-button {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h1>البجعة في البحيرة</h1>
        <p>اعثر على الأعشاش والماسات لتكمل اللعبة!</p>
    </div>
    
    <div id="game-stats">
        <div id="timer" class="stat-item">الوقت المتبقي: 15s</div>
        <div id="score" class="stat-item">الأعشاش المتبقية: 10</div>
    </div>
    
    <button id="music-button">🎵</button>
    
    <div id="joystick-container">
        <div id="joystick">
            <div id="joystick-handle"></div>
        </div>
    </div>
    
    <div id="controls-info">
        <h3>مفاتيح التحكم:</h3>
        <p>↑ ↓ → ← : تحريك البجعة</p>
        <p>استخدم دائرة التحكم للتحريك على الشاشات التي تعمل باللمس</p>
    </div>
    
    <div class="instructions" id="welcome-message">
        <h2>لعبة البجعة في البحيرة</h2>
        <div class="duck-icon">🦢</div>
        <p>ابحث عن جميع الأعشاش المخبأة في البحيرة قبل نفاد الوقت!</p>
        
        <div class="instructions-list">
            <p><strong>طريقة اللعب:</strong></p>
            <ul>
                <li>استخدم مفاتيح الأسهم <span class="key-icon">← ↑ → ↓</span> للتحكم في البجعة</li>
                <li>ابحث عن الأعشاش المخبأة بين الأخشاب والصخور</li>
                <li>عند الوصول للعش، أجب على سؤال الرياضيات لتحصل على وقت إضافي!</li>
                <li><strong>الماسات الزرقاء</strong>: تمنحك وقتًا إضافيًا</li>
                <li><strong>الماسات الحمراء</strong>: تمنحك سرعة إضافية مؤقتة</li>
                <li>استخدم دائرة التحكم للتحرك على الشاشات التي تعمل باللمس</li>
            </ul>
        </div>
        
    </div>
    <button id="start-button" onclick="startGame()">ابدأ اللعب الآن</button>

    <div id="game-overlay">
        <div id="game-modal" class="game-completed">
            <h2 id="game-result-title"></h2>
            <p id="game-result-message"></p>
            <p>هل تريد اللعب مرة أخرى؟</p>
            <button id="restart-button" onclick="restartGame()">إعادة اللعب</button>
        </div>
        
        <div id="quiz-modal">
            <div class="quiz-question-box">
                <p id="math-question-text"></p>
            </div>
            <div id="options-container" class="options-container">
                <!-- Buttons will be dynamically generated here -->
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main game variables
        let scene, camera, renderer, duck, water;
        let duckDirection = new THREE.Vector3(0, 0, 0);
        let duckSpeed = 0.2;
        let nests = [];
        let nestsFound = 0;
        let totalNests = 10;
        let timeDiamonds = [];
        let speedDiamonds = [];
        let gameTimer = 15;
        let isSpeedBoostActive = false;
        let speedBoostTimer = 0;
        const SPEED_BOOST_DURATION = 5;
        const SPEED_BOOST_MULTIPLIER = 2;
        const TIME_DIAMOND_BONUS = 15;
        const NEST_TIME_BONUS = 10;
        const NEST_TIME_PENALTY = 5;
        let clock = new THREE.Clock();
        let isTouchDevice = 'ontouchstart' in window;
        let joystickActive = false;
        let waterUniforms;
        let bridge;
        
        // متغيرات للحيوانات التي تتحرك بشكل عشوائي
        let aiSwans = [];
        let otherObjects = [];
        const AI_COUNT_SWANS = 40; 
        const LAKE_RADIUS = 98;

        // متغيرات جديدة لسؤال الرياضيات
        let isGamePaused = false;
        let isGameCompleted = false; // متغير جديد لتحديد ما إذا كانت اللعبة قد انتهت
        let currentNest = null;
        let currentQuestion = null;
        
        // Music Variables
        const noteFrequencies = {
            "F3": 174.61, "G3": 196.00, "A3": 220.00, "B3": 246.94,
            "C4": 261.63, "C#4": 277.18, "D4": 293.66, "D#4": 311.13,
            "E4": 329.63, "F4": 349.23, "F#4": 369.99, "G4": 392.00,
            "G#4": 415.30, "A4": 440.00, "A#4": 466.16, "B4": 493.88,
            "C5": 523.25
        };
        const fullScore = [
            { time: 0, note: "C4", duration: 1000, volume: 0.4 },
            { time: 1000, note: "E4", duration: 1000, volume: 0.4 },
            { time: 2000, note: "G4", duration: 1000, volume: 0.4 },
            { time: 3000, note: "A4", duration: 1000, volume: 0.4 },
            { time: 4000, note: "G4", duration: 1000, volume: 0.4 },
            { time: 5000, note: "E4", duration: 1000, volume: 0.4 },
            { time: 6000, note: "C4", duration: 1000, volume: 0.4 },
            { time: 0, note: "C3", duration: 2000, volume: 0.2 },
            { time: 2000, note: "G3", duration: 2000, volume: 0.2 },
            { time: 4000, note: "F3", duration: 2000, volume: 0.2 },
            { time: 6000, note: "C4", duration: 1000, volume: 0.2 }
        ];
        const totalDuration = 7000;
        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let playing = false;
        let mainLoopTimeout = null;

        // Play a sound using an oscillator
        function playSound(frequency, duration, volume) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.value = frequency;
            
            const now = audioContext.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            
            oscillator.start(now);
            oscillator.stop(now + duration);
        }

        function playCollectSound() {
            playSound(700, 0.1, 0.5);
            setTimeout(() => playSound(850, 0.1, 0.5), 100);
        }

        function playBoostSound() {
            playSound(1200, 0.1, 0.5);
            setTimeout(() => playSound(1400, 0.1, 0.5), 50);
        }
        
        function playLoseSound() {
            playSound(100, 0.3, 0.5);
            setTimeout(() => playSound(80, 0.3, 0.5), 200);
        }
        
        function playCorrectSound() {
            playSound(1000, 0.1, 0.5);
            setTimeout(() => playSound(1500, 0.1, 0.5), 100);
        }

        function playIncorrectSound() {
            playSound(200, 0.1, 0.5);
            setTimeout(() => playSound(100, 0.1, 0.5), 100);
        }

        function startPlayback() {
            if (playing) return;
            playing = true;
            document.getElementById('music-button').textContent = '⏸️';

            function playSection() {
                if (!playing) return;

                fullScore.forEach(event => {
                    const frequency = noteFrequencies[event.note];
                    if (frequency) {
                        setTimeout(() => {
                            playSound(frequency, event.duration / 1000, event.volume);
                        }, event.time);
                    }
                });

                mainLoopTimeout = setTimeout(playSection, totalDuration);
            }

            playSection();
        }

        function stopPlayback() {
            if (!playing) return;
            playing = false;
            if (mainLoopTimeout) {
                clearTimeout(mainLoopTimeout);
            }
            document.getElementById('music-button').textContent = '🎵';
        }

        // Initialize the scene
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createLake();
            createBridge();
            
            setupGame();
            
            camera.position.set(0, 10, 30);
            camera.lookAt(0, 0, 0);
            
            setupEventListeners();
        }

        function startGame() {
            document.body.classList.add('game-playing');
            // Start the music and animation loop
            startPlayback();
            animate();
        }

        function setupGame() {
            nests = [];
            nestsFound = 0;
            timeDiamonds = [];
            speedDiamonds = [];
            aiSwans = [];
            otherObjects = [];
            gameTimer = 15;
            isGameCompleted = false; // إعادة تعيين حالة اللعبة عند البدء
            
            createDuck();
            createObstacles();
            createWanderingAnimals();
            createEnvironment();
        }

        function createLake() {
            const waterGeometry = new THREE.CircleGeometry(100, 256);
            waterUniforms = {
                time: { type: "f", value: 0.0 }
            };
            
            const waterMaterial = new THREE.ShaderMaterial({
                uniforms: waterUniforms,
                vertexShader: `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        pos.y += sin(time + position.x * 1.5) * 0.2;
                        pos.y += cos(time + position.z * 1.5) * 0.2;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    void main() {
                        vec3 color = mix(vec3(0.0, 0.3, 0.7), vec3(0.0, 0.5, 0.9), vUv.y);
                        gl_FragColor = vec4(color, 0.8);
                    }
                `,
                transparent: true
            });
            
            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -0.5;
            water.name = "water";
            scene.add(water);
            
            const lakeBottomGeometry = new THREE.CircleGeometry(100, 256);
            const lakeBottomMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8
            });
            const lakeBottom = new THREE.Mesh(lakeBottomGeometry, lakeBottomMaterial);
            lakeBottom.rotation.x = -Math.PI / 2;
            lakeBottom.position.y = -1;
            scene.add(lakeBottom);
            
            const landGeometry = new THREE.RingGeometry(100, 130, 256);
            const landMaterial = new THREE.MeshStandardMaterial({
                color: 0x4CAF50,
                roughness: 0.9
            });
            const land = new THREE.Mesh(landGeometry, landMaterial);
            land.rotation.x = -Math.PI / 2;
            land.position.y = -0.49;
            scene.add(land);
        }

        function createBridge() {
            const bridgeGeometry = new THREE.BoxGeometry(20, 0.5, 2.5);
            const bridgeMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9
            });
            
            bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
            bridge.position.set(0, -0.25, 0);
            bridge.rotation.y = Math.PI / 2;
            bridge.name = "bridge";
            scene.add(bridge);
            
            const railingGeometry = new THREE.BoxGeometry(0.2, 0.5, 20);
            const railingMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
            
            const rightRailing = new THREE.Mesh(railingGeometry, railingMaterial);
            rightRailing.position.set(1.2, 0, 0);
            bridge.add(rightRailing);
            
            const leftRailing = new THREE.Mesh(railingGeometry, railingMaterial);
            leftRailing.position.set(-1.2, 0, 0);
            bridge.add(leftRailing);
        }

        function createDuck() {
            const bodyGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            bodyGeometry.scale(1.5, 1, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);

            const neckGeometry = new THREE.CylinderGeometry(0.1, 0.2, 1, 32);
            const neckMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const neck = new THREE.Mesh(neckGeometry, neckMaterial);
            neck.position.y = 0.8;
            neck.position.x = 0.5;

            const headGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.position.x = 0.5;

            const beakGeometry = new THREE.ConeGeometry(0.1, 0.4, 32);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.y = 1.5;
            beak.position.x = 0.8;
            beak.rotation.z = -Math.PI / 2;

            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.7, 1.55, 0.15);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.7, 1.55, -0.15);
            
            const tailGeometry = new THREE.ConeGeometry(0.3, 0.6, 32);
            const tailMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.9, 0, 0);
            tail.rotation.z = Math.PI / 2;
            
            duck = new THREE.Group();
            duck.add(body);
            duck.add(neck);
            duck.add(head);
            duck.add(beak);
            duck.add(leftEye);
            duck.add(rightEye);
            duck.add(tail);
            duck.position.set(0, 0, 0);
            scene.add(duck);
        }

        function createAISwan() {
            const bodyGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            bodyGeometry.scale(1.5, 1, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);

            const neckGeometry = new THREE.CylinderGeometry(0.1, 0.2, 1, 32);
            const neckMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const neck = new THREE.Mesh(neckGeometry, neckMaterial);
            neck.position.y = 0.8;
            neck.position.x = 0.5;

            const headGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.position.x = 0.5;
            
            const beakGeometry = new THREE.ConeGeometry(0.1, 0.4, 32);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.y = 1.5;
            beak.position.x = 0.8;
            beak.rotation.z = -Math.PI / 2;
            
            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.7, 1.55, 0.15);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.7, 1.55, -0.15);

            const tailGeometry = new THREE.ConeGeometry(0.3, 0.6, 32);
            const tailMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.9, 0, 0);
            tail.rotation.z = Math.PI / 2;
            
            const aiSwan = new THREE.Group();
            aiSwan.add(body);
            aiSwan.add(neck);
            aiSwan.add(head);
            aiSwan.add(beak);
            aiSwan.add(leftEye);
            aiSwan.add(rightEye);
            aiSwan.add(tail);
            
            return aiSwan;
        }

        function createWanderingAnimals() {
            for (let i = 0; i < AI_COUNT_SWANS; i++) {
                const aiSwan = createAISwan();
                const radius = Math.random() * (LAKE_RADIUS - 5);
                const angle = Math.random() * Math.PI * 2;
                aiSwan.position.x = Math.cos(angle) * radius;
                aiSwan.position.z = Math.sin(angle) * radius;
                aiSwan.userData.target = new THREE.Vector3(
                    Math.cos(Math.random() * Math.PI * 2) * (LAKE_RADIUS - 5),
                    0,
                    Math.sin(Math.random() * Math.PI * 2) * (LAKE_RADIUS - 5)
                );
                aiSwan.userData.speed = 0.05 + Math.random() * 0.05;
                scene.add(aiSwan);
                aiSwans.push(aiSwan);
            }
        }

        function createSingleNest(position) {
            const nestGeometry = new THREE.CylinderGeometry(0.7, 1, 0.3, 32);
            const nestMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            const nest = new THREE.Mesh(nestGeometry, nestMaterial);
            
            nest.position.copy(position);
            
            const eggGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const eggMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const egg = new THREE.Mesh(eggGeometry, eggMaterial);
            egg.position.y = 0.2;
            nest.add(egg);
            
            scene.add(nest);
            nests.push(nest);
            return nest;
        }

        function createTimeDiamond(position) {
            const diamondGeometry = new THREE.DodecahedronGeometry(0.5, 0);
            const diamondMaterial = new THREE.MeshStandardMaterial({
                color: 0x00BFFF,
                emissive: 0x0033CC,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const diamond = new THREE.Mesh(diamondGeometry, diamondMaterial);
            diamond.position.copy(position);
            diamond.name = 'timeDiamond';
            scene.add(diamond);
            timeDiamonds.push(diamond);
        }

        function createSpeedDiamond(position) {
            const diamondGeometry = new THREE.DodecahedronGeometry(0.5, 0);
            const diamondMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                emissive: 0xCC3300,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const diamond = new THREE.Mesh(diamondGeometry, diamondMaterial);
            diamond.position.copy(position);
            diamond.name = 'speedDiamond';
            scene.add(diamond);
            speedDiamonds.push(diamond);
        }

        function createLogObstacle(nestPosition) {
            const logMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8
            });
            const logRadius = 0.8;
            const logHeight = 15;
            
            const logs = [
                new THREE.CylinderGeometry(logRadius, logRadius, logHeight, 32),
                new THREE.CylinderGeometry(logRadius * 0.9, logRadius * 0.9, logHeight * 0.9, 32),
                new THREE.CylinderGeometry(logRadius * 1.1, logRadius * 1.1, logHeight * 1.1, 32),
            ];
            
            const logY = -0.3;
            const scatterRadius = 8;
            const minClearance = 3;

            for (let i = 0; i < logs.length; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = minClearance + Math.random() * (scatterRadius - minClearance);
                const log = new THREE.Mesh(logs[i], logMaterial);
                log.rotation.z = Math.PI / 2;
                log.rotation.y = Math.random() * Math.PI * 2;
                log.position.set(
                    nestPosition.x + Math.cos(angle) * distance,
                    logY,
                    nestPosition.z + Math.sin(angle) * distance
                );
                scene.add(log);
                otherObjects.push(log);
            }
        }
        
        function createScatteredRockObstacle(nestPosition) {
            const rockMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 1.0
            });
            
            const scatterRadius = 8;
            const minClearance = 3;
            
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = minClearance + Math.random() * (scatterRadius - minClearance);
                
                const rockGeometry = new THREE.DodecahedronGeometry(0.7 + Math.random() * 0.5, 0);
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                rock.position.set(
                    nestPosition.x + Math.cos(angle) * distance,
                    -0.4 + Math.random() * 0.2,
                    nestPosition.z + Math.sin(angle) * distance
                );
                
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                
                scene.add(rock);
                otherObjects.push(rock);
            }
        }
        
        function createTallGrassObstacle(nestPosition) {
            const grassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00CC00,
                roughness: 0.9
            });
            const scatterRadius = 8;
            const minClearance = 3;
            const grassCount = 200;
            
            for (let i = 0; i < grassCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = minClearance + Math.random() * (scatterRadius - minClearance);
                
                const grassHeight = 2.5 + Math.random() * 2.5;
                const grassGeometry = new THREE.CylinderGeometry(0.02, 0.05, grassHeight, 8);
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                
                grass.rotation.x = Math.random() * 0.2;
                grass.rotation.z = Math.random() * 0.2;
                grass.position.set(
                    nestPosition.x + Math.cos(angle) * distance,
                    -0.45,
                    Math.sin(angle) * distance
                );
                
                scene.add(grass);
                otherObjects.push(grass);
            }
        }

        function createBoatObstacle(nestPosition) {
            const boatMaterial = new THREE.MeshStandardMaterial({
                color: 0x7A5230,
                roughness: 0.9
            });
            
            // Adjusting boat position to ensure it does not cover the nest
            const boatOffset = new THREE.Vector3(
                (Math.random() * 5 + 3) * (Math.random() > 0.5 ? 1 : -1),
                0,
                (Math.random() * 5 + 3) * (Math.random() > 0.5 ? 1 : -1)
            );

            const boatHull = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.5, 12),
                boatMaterial
            );
            boatHull.position.set(nestPosition.x + boatOffset.x, -0.2, nestPosition.z + boatOffset.z); 
            scene.add(boatHull);
            otherObjects.push(boatHull);

            const frontGeometry = new THREE.ConeGeometry(2, 2, 4);
            const front = new THREE.Mesh(frontGeometry, boatMaterial);
            front.rotation.z = Math.PI / 2;
            front.position.set(boatHull.position.x, boatHull.position.y + 0.5, boatHull.position.z + 6);
            scene.add(front);
            otherObjects.push(front);

            const mastMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033 });
            const mast = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 5),
                mastMaterial
            );
            mast.position.set(boatHull.position.x, boatHull.position.y + 2.5, boatHull.position.z - 2);
            scene.add(mast);
            otherObjects.push(mast);
        }
        
        const obstacleTypes = [
            createLogObstacle,
            createScatteredRockObstacle,
            createTallGrassObstacle,
            createBoatObstacle
        ];
        
        function createObstacles() {
            const usedPositions = [];
            // تم تعديل هذه القيم لضمان أن الأعشاش والماسات تظهر بعيدًا عن نقطة البداية.
            const minDistance = 25; // Minimum distance from the origin
            const maxDistance = 90; // Max distance for objects
            
            for(let i = 0; i < totalNests; i++) {
                let position;
                let isTooClose = true;
                while (isTooClose) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = minDistance + Math.random() * (maxDistance - minDistance);
                    
                    position = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        -0.35,
                        Math.sin(angle) * radius
                    );
                    
                    isTooClose = usedPositions.some(p => p.distanceTo(position) < 20);
                }
                usedPositions.push(position);
                
                createSingleNest(position);
                
                const randomObstacleFunc = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                randomObstacleFunc(position);
            }
            
            // إضافة الماسات في أماكن عشوائية
            for (let i = 0; i < 4; i++) {
                let position;
                let isTooClose = true;
                while (isTooClose) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = minDistance + Math.random() * (maxDistance - minDistance);
                    
                    position = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        -0.35,
                        Math.sin(angle) * radius
                    );
                    
                    isTooClose = usedPositions.some(p => p.distanceTo(position) < 15);
                }
                usedPositions.push(position);
                createTimeDiamond(position);
            }

            for (let i = 0; i < 3; i++) {
                let position;
                let isTooClose = true;
                while (isTooClose) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = minDistance + Math.random() * (maxDistance - minDistance);
                    
                    position = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        -0.35,
                        Math.sin(angle) * radius
                    );
                    
                    isTooClose = usedPositions.some(p => p.distanceTo(position) < 15);
                }
                usedPositions.push(position);
                createSpeedDiamond(position);
            }
        }

        function createEnvironment() {
            for (let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 2;
                const radius = 105 + Math.random() * 10;
                
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 32);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                
                const leavesGeometry = new THREE.SphereGeometry(1.5, 32, 32);
                const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 1.5;
                trunk.add(leaves);
                
                scene.add(trunk);
                otherObjects.push(trunk);
            }
            
            for (let i = 0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 95;
                
                const lilyPadGeometry = new THREE.CircleGeometry(0.5, 32);
                const lilyPadMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x008000,
                    roughness: 0.8
                });
                const lilyPad = new THREE.Mesh(lilyPadGeometry, lilyPadMaterial);
                lilyPad.rotation.x = -Math.PI / 2;
                lilyPad.position.set(
                    Math.cos(angle) * radius,
                    -0.45,
                    Math.sin(angle) * radius
                );
                
                scene.add(lilyPad);
                otherObjects.push(lilyPad);
            }

            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 98 + Math.random() * 5;
                
                const rockGeometry = new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.5, 0);
                const rockMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x808080,
                    roughness: 1.0
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.position.set(
                    Math.cos(angle) * radius,
                    -0.4 + Math.random() * 0.2,
                    Math.sin(angle) * radius
                );
                
                scene.add(rock);
                otherObjects.push(rock);
            }
            
            for (let i = 0; i < 150; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 100 + Math.random() * 25;
                
                const grassGeometry = new THREE.CylinderGeometry(0.02, 0.05, 0.5 + Math.random() * 1, 8);
                const grassMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00CC00,
                    roughness: 0.9
                });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = Math.random() * 0.2;
                grass.rotation.z = Math.random() * 0.2;
                grass.position.set(
                    Math.cos(angle) * radius,
                    -0.45,
                    Math.sin(angle) * radius
                );
                
                scene.add(grass);
                otherObjects.push(grass);
            }
            
            for (let i = 0; i < 60; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 100 + Math.random() * 25;
                
                const bushGeometry = new THREE.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16);
                const bushMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x228822,
                    roughness: 0.9
                });
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                bush.position.set(
                    Math.cos(angle) * radius,
                    -0.3,
                    Math.sin(angle) * radius
                );
                
                scene.add(bush);
                otherObjects.push(bush);
            }
        }

        function setupEventListeners() {
            document.addEventListener('keydown', (event) => {
                if (isGamePaused || isGameCompleted) return; // توقف التحكم عند اكتمال اللعبة
                switch(event.key) {
                    case 'ArrowUp':
                        duckDirection.set(0, 0, -1);
                        break;
                    case 'ArrowDown':
                        duckDirection.set(0, 0, 1);
                        break;
                    case 'ArrowLeft':
                        duckDirection.set(-1, 0, 0);
                        break;
                    case 'ArrowRight':
                        duckDirection.set(1, 0, 0);
                        break;
                }
            });
            
            document.addEventListener('keyup', () => {
                if (isGamePaused || isGameCompleted) return; // توقف التحكم عند اكتمال اللعبة
                duckDirection.set(0, 0, 0);
            });
            
            if (isTouchDevice) {
                const joystick = document.getElementById('joystick');
                const handle = document.getElementById('joystick-handle');
                const joystickContainer = document.getElementById('joystick-container');
                
                let touchId = null;
                const joystickRect = joystickContainer.getBoundingClientRect();
                const joystickRadius = joystickRect.width / 2;
                const handleRadius = handle.offsetWidth / 2;
                const centerX = joystickRect.left + joystickRadius;
                const centerY = joystickRect.top + joystickRadius;
                
                joystickContainer.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (isGamePaused || isGameCompleted) return; // توقف التحكم عند اكتمال اللعبة
                    if (touchId === null) {
                        touchId = event.changedTouches[0].identifier;
                        joystickActive = true;
                    }
                });
                
                document.addEventListener('touchmove', (event) => {
                    if (!joystickActive || isGamePaused || isGameCompleted) return; // توقف التحكم عند اكتمال اللعبة
                    
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        if (event.changedTouches[i].identifier === touchId) {
                            const touch = event.changedTouches[i];
                            const touchX = touch.clientX;
                            const touchY = touch.clientY;
                            
                            const deltaX = touchX - centerX;
                            const deltaY = touchY - centerY;
                            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                            
                            if (distance > 5) {
                                const angle = Math.atan2(deltaY, deltaX);
                                
                                const maxDistance = joystickRadius - handleRadius;
                                const limitedDistance = Math.min(distance, maxDistance);
                                
                                const handleX = limitedDistance * Math.cos(angle);
                                const handleY = limitedDistance * Math.sin(angle);
                                
                                handle.style.transform = `translate(${handleX}px, ${handleY}px)`;
                                
                                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                    duckDirection.set(deltaX > 0 ? 1 : -1, 0, 0);
                                } else {
                                    duckDirection.set(0, 0, deltaY > 0 ? 1 : -1);
                                }
                                
                                break;
                            }
                            
                            break;
                        }
                    }
                }, { passive: false });
                
                document.addEventListener('touchend', (event) => {
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        if (event.changedTouches[i].identifier === touchId) {
                            handle.style.transform = 'translate(0, 0)';
                            touchId = null;
                            joystickActive = false;
                            duckDirection.set(0, 0, 0);
                            break;
                        }
                    }
                });
            }
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.getElementById('music-button').addEventListener('click', async () => {
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                if (playing) {
                    stopPlayback();
                } else {
                    startPlayback();
                }
            });
        }

        // دالة جديدة لتوليد أسئلة المعادلات الخطية
        function generateMathQuestion() {
            // أنواع مختلفة من الأسئلة
            const questionTypes = [
                'distribution',
                'variablesOnBothSides',
                'fractions',
                'combined' // النوع الجديد
            ];
            
            // اختيار نوع عشوائي
            const type = questionTypes[Math.floor(Math.random() * questionTypes.length)];
            
            let questionText, correctAnswer;
            
            // دالة لتوليد عدد صحيح عشوائي (يستبعد الصفر)
            const randomInt = (min, max) => {
                let num = 0;
                while (num === 0) {
                    num = Math.floor(Math.random() * (max - min + 1)) + min;
                }
                return num;
            };

            // بناء السؤال وحلّه
            if (type === 'distribution') {
                const answer = randomInt(-5, 5); // ابدأ بالإجابة
                const a = randomInt(2, 5);
                const b = randomInt(1, 5);
                const c = a * (answer + b); // احسب الطرف الأيمن
                
                questionText = `حل المعادلة: $$${a}(x + ${b}) = ${c}$$`;
                correctAnswer = answer;

            } else if (type === 'variablesOnBothSides') {
                const answer = randomInt(-5, 5);
                const a = randomInt(2, 5);
                let c = randomInt(2, 5);
                while (c === a) { // تأكد من أن a و c غير متساويين
                    c = randomInt(2, 5);
                }
                const b = randomInt(1, 10);
                const d = a * answer + b - c * answer;
                
                questionText = `حل المعادلة: $$${a}x + ${b} = ${c}x + ${d}$$`;
                correctAnswer = answer;

            } else if (type === 'fractions') {
                const answer = randomInt(-5, 5);
                const b = randomInt(2, 5);
                const c = randomInt(1, 10);
                const a = c * b - answer;
                
                questionText = `حل المعادلة: $$\\frac{x + ${a}}{${b}} = ${c}$$`;
                correctAnswer = answer;

            } else if (type === 'combined') {
                const answer = randomInt(-3, 3);
                const a = randomInt(2, 5);
                const b = randomInt(2, 5);
                const c = randomInt(1, 5);
                const d = randomInt(-5, 5);
                const e = randomInt(1, 5);

                const leftSideValue = (a * (b * answer + c)) + d;
                const f = leftSideValue - (e * answer);

                let leftSide = `${a}(${b}x + ${c})`;
                if (d !== 0) {
                    leftSide += (d > 0 ? ` + ${d}` : ` - ${-d}`);
                }
                let rightSide = `${e}x`;
                if (f !== 0) {
                    rightSide += (f > 0 ? ` + ${f}` : ` - ${-f}`);
                }

                questionText = `حل المعادلة: $$${leftSide} = ${rightSide}$$`;
                correctAnswer = answer;
            }

            // توليد إجابات خاطئة
            const options = [correctAnswer];
            while(options.length < 4) {
                let newOption = 0;
                // توليد إجابة خاطئة معقولة (مثلاً، بفارق بسيط أو خطأ شائع)
                const mistakeType = Math.floor(Math.random() * 3);
                if (mistakeType === 0) {
                    newOption = correctAnswer + randomInt(-2, 2);
                } else if (mistakeType === 1) {
                    newOption = -correctAnswer;
                } else {
                    newOption = randomInt(correctAnswer - 5, correctAnswer + 5);
                }
                
                if (!options.includes(newOption)) {
                    options.push(newOption);
                }
            }
            
            options.sort(() => Math.random() - 0.5);

            return { question: questionText, answer: correctAnswer, options: options };
        }

        function showQuiz(nestObject) {
            isGamePaused = true;
            currentNest = nestObject;
            document.getElementById('game-overlay').style.display = 'flex';
            document.getElementById('quiz-modal').style.display = 'block';
            document.getElementById('game-modal').style.display = 'none';
            
            const questionData = generateMathQuestion();
            currentQuestion = questionData;
            document.getElementById('math-question-text').textContent = questionData.question;
            
            // عرض السؤال باستخدام MathJax
            MathJax.typesetPromise().then(() => {
                // ...
            });
            
            const optionsContainer = document.getElementById('options-container');
            optionsContainer.innerHTML = '';
            
            questionData.options.forEach(option => {
                const button = document.createElement('button');
                button.textContent = option;
                button.classList.add('option-button');
                button.addEventListener('click', () => checkAnswer(option));
                optionsContainer.appendChild(button);
            });
        }
        
        // تم تعديل هذا الجزء بناءً على طلب المستخدم
        function checkAnswer(userAnswer) {
            const isCorrect = userAnswer === currentQuestion.answer;
            const optionButtons = document.querySelectorAll('.option-button');
            
            optionButtons.forEach(button => {
                if (parseInt(button.textContent) === currentQuestion.answer) {
                    button.classList.add('correct');
                } else if (parseInt(button.textContent) === userAnswer && !isCorrect) {
                    button.classList.add('incorrect');
                }
                button.disabled = true;
            });
            
            setTimeout(() => {
                if (isCorrect) {
                    playCorrectSound();
                    gameTimer += NEST_TIME_BONUS;
                    
                    const nestIndex = nests.indexOf(currentNest);
                    if (nestIndex > -1) {
                        scene.remove(currentNest);
                        nests.splice(nestIndex, 1);
                        nestsFound++;
                    }
                    
                    if (nestsFound === totalNests) {
                        endGame(true);
                    } else {
                        // إخفاء الـ overlay بالكامل إذا لم تنته اللعبة
                        document.getElementById('game-overlay').style.display = 'none';
                    }
                } else {
                    playIncorrectSound();
                    gameTimer -= NEST_TIME_PENALTY; // خصم 5 ثواني
                    
                    // إخفاء الـ overlay بعد الإجابة الخاطئة للعودة للعب
                    document.getElementById('game-overlay').style.display = 'none';

                    // التحقق مما إذا كان الوقت قد نفد بعد الخصم
                    if (gameTimer <= 0) {
                       endGame(false);
                    }
                }

                document.getElementById('quiz-modal').style.display = 'none';
                // استئناف اللعبة بعد التحقق من الإجابة
                isGamePaused = false;
            }, 1000);
        }

        function checkCollision() {
            if (isGamePaused || isGameCompleted) return;

            const duckPosition = duck.position;
            const collisionRadius = 1.5;

            // Collision with nests
            for (let i = 0; i < nests.length; i++) {
                const nest = nests[i];
                if (nest && duckPosition.distanceTo(nest.position) < collisionRadius) {
                    showQuiz(nest);
                    return;
                }
            }
            
            // Collision with time diamonds
            for (let i = 0; i < timeDiamonds.length; i++) {
                const diamond = timeDiamonds[i];
                if (diamond && duckPosition.distanceTo(diamond.position) < collisionRadius) {
                    scene.remove(diamond);
                    timeDiamonds.splice(i, 1);
                    gameTimer += TIME_DIAMOND_BONUS;
                    playCollectSound();
                    return;
                }
            }

            // Collision with speed diamonds
            for (let i = 0; i < speedDiamonds.length; i++) {
                const diamond = speedDiamonds[i];
                if (diamond && duckPosition.distanceTo(diamond.position) < collisionRadius) {
                    scene.remove(diamond);
                    speedDiamonds.splice(i, 1);
                    isSpeedBoostActive = true;
                    speedBoostTimer = SPEED_BOOST_DURATION;
                    duckSpeed *= SPEED_BOOST_MULTIPLIER;
                    playBoostSound();
                    return;
                }
            }
        }

        function endGame(isWin) {
            stopPlayback();
            document.getElementById('game-overlay').style.display = 'flex';
            document.getElementById('game-modal').style.display = 'block';
            if (isWin) {
                isGameCompleted = true; // تعيين حالة اكتمال اللعبة
                document.getElementById('game-result-title').textContent = "🏆مبارك!🎉 لقد أكملت اللعبة!";
                document.getElementById('game-result-message').textContent = "لقد وجدت البجعة جميع الأعشاش في البحيرة الكبيرة!";
            } else {
                playLoseSound();
                document.getElementById('game-result-title').textContent = "انتهى الوقت!";
                document.getElementById('game-result-message').textContent = "لم تتمكن البجعة من العثور على جميع الأعشاش في الوقت المحدد.";
            }
        }

        function restartGame() {
            document.getElementById('game-overlay').style.display = 'none';
            
            // Remove old nests, diamonds, and other objects
            [...nests, ...timeDiamonds, ...speedDiamonds, ...aiSwans, ...otherObjects].forEach(obj => {
                if (obj && obj.parent) scene.remove(obj);
            });
            nests = [];
            timeDiamonds = [];
            speedDiamonds = [];
            aiSwans = [];
            otherObjects = [];
            
            // Reset duck's position and speed
            scene.remove(duck);
            duckSpeed = 0.2; // Reset to updated original speed
            isSpeedBoostActive = false;
            speedBoostTimer = 0;
            isGamePaused = false;
            isGameCompleted = false; // إعادة تعيين حالة اكتمال اللعبة
            document.body.classList.remove('game-playing');

            // Recreate all game elements
            setupGame();
            
            startPlayback(); // Start music again on restart
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();

            // Update game timer only if not paused and not completed
            if (!isGamePaused && !isGameCompleted) {
                if (gameTimer > 0) {
                    gameTimer -= delta;
                }
                
                // End the game if time is less than or equal to zero
                if (gameTimer <= 0) {
                    gameTimer = 0;
                    endGame(false);
                }
                
                // Display the timer, making sure it doesn't show negative numbers
                document.getElementById('timer').textContent = `الوقت المتبقي: ${Math.floor(Math.max(0, gameTimer))}s`;
                document.getElementById('score').textContent = `الأعشاش المتبقية: ${totalNests - nestsFound}`;
            }

            // Handle speed boost duration
            if (isSpeedBoostActive) {
                speedBoostTimer -= delta;
                if (speedBoostTimer <= 0) {
                    isSpeedBoostActive = false;
                    duckSpeed = 0.2; // Reset to original speed
                }
            }

            // Rotate diamonds
            timeDiamonds.forEach(diamond => diamond.rotation.y += 0.02);
            speedDiamonds.forEach(diamond => diamond.rotation.y += 0.02);
            
            if (waterUniforms) {
                waterUniforms.time.value += delta;
            }
            
            if (!isGamePaused && !isGameCompleted && duckDirection.length() > 0) { // توقف حركة البجعة عند اكتمال اللعبة
                duck.position.x += duckDirection.x * duckSpeed;
                duck.position.z += duckDirection.z * duckSpeed;
                
                const targetRotation = Math.atan2(duckDirection.x, duckDirection.z) + Math.PI / 2 + Math.PI;
                
                let deltaRotation = targetRotation - duck.rotation.y;
                if (deltaRotation > Math.PI) deltaRotation -= 2 * Math.PI;
                if (deltaRotation < -Math.PI) deltaRotation += 2 * Math.PI;
                duck.rotation.y += deltaRotation * 0.1;

                duck.position.y = Math.sin(performance.now() * 0.005) * 0.1;
            }
            
            const aiSpeedModifier = 0.5;
            aiSwans.forEach(animal => {
                const distanceToTarget = animal.position.distanceTo(animal.userData.target);

                if (distanceToTarget < 2) {
                    const newRadius = Math.random() * (LAKE_RADIUS - 10);
                    animal.userData.target.set(
                        Math.cos(Math.random() * Math.PI * 2) * newRadius,
                        0,
                        Math.sin(Math.random() * Math.PI * 2) * newRadius
                    );
                }

                const direction = animal.userData.target.clone().sub(animal.position).normalize();
                
                animal.position.add(direction.multiplyScalar(animal.userData.speed * aiSpeedModifier));

                const targetRotation = Math.atan2(direction.x, direction.z) + Math.PI / 2 + Math.PI;
                animal.rotation.y += (targetRotation - animal.rotation.y) * 0.05;
                
                animal.position.y = Math.sin(performance.now() * 0.005 + animal.position.x) * 0.1;
            });

            if (!isGamePaused && !isGameCompleted) {
                const maxDistance = 98;
                const duckDistance = Math.sqrt(duck.position.x * duck.position.x + duck.position.z * duck.position.z);
                if (duckDistance > maxDistance) {
                    duck.position.x = (duck.position.x / duckDistance) * maxDistance;
                    duck.position.z = (duck.position.z / duckDistance) * maxDistance;
                }
                
                checkCollision();
            }
            
            camera.position.x = duck.position.x;
            camera.position.z = duck.position.z + 20;
            camera.lookAt(duck.position.x, 0, duck.position.z);
            
            renderer.render(scene, camera);
        }

        window.onload = function() {
            init();
        }
    </script>
</body>
</html>
