<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Waves - Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…ÙˆØ¬Ø§Øª Ø§Ù„ÙØ¶Ø§Ø¦ÙŠØ©</title>
    <!-- ØªØ¶Ù…ÙŠÙ† Ù…ÙƒØªØ¨Ø© MathJax Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Ø£Ù†Ù…Ø§Ø· CSS Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ø¬Ø³Ù… ÙˆØ§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¹Ø§Ù… */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #fff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        /* Ø®Ù„ÙÙŠØ© Ø§Ù„Ù†Ø¬ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ© */
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="1" fill="white" opacity="0.1"/></svg>');
            background-size: 150px 150px;
            opacity: 0.3;
            z-index: -1;
        }

        #gameCanvas {
            background: #000428;
            display: block;
            touch-action: none;
            width: 100vw;
            height: 100vh;
            cursor: none; /* Ø¥Ø®ÙØ§Ø¡ Ù…Ø¤Ø´Ø± Ø§Ù„ÙØ£Ø±Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ù„Ø¹Ø¨Ø© */
        }
        
        /* Ø§Ù„Ø·Ø¨Ù‚Ø§Øª Ø§Ù„Ø´ÙØ§ÙØ© Ø§Ù„ØªÙŠ ØªØ¸Ù‡Ø± ÙÙˆÙ‚ Ø§Ù„Ù„Ø¹Ø¨Ø© (Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©ØŒ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©ØŒ Ø¥Ù„Ø®) */
        .game-overlay, .question-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.85);
            text-align: center;
            padding: 20px;
            z-index: 50;
            transition: opacity 0.5s ease;
        }

        .game-overlay.hidden, .question-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .game-overlay h1 {
            font-size: clamp(2rem, 8vw, 4rem);
            color: #4fc3f7;
            text-shadow: 0 0 15px rgba(79, 195, 247, 0.9);
            letter-spacing: 2px;
            margin-bottom: 20px;
        }

        .game-overlay p {
            font-size: clamp(1rem, 4vw, 1.5rem);
            color: #bbdefb;
            margin-bottom: 30px;
        }

        .game-overlay .btn {
            background: linear-gradient(to right, #1a2980, #26d0ce);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: clamp(1rem, 4vw, 1.5rem);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), 0 0 10px #26d0ce;
            margin-top: 10px;
        }

        .game-overlay .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4), 0 0 15px #26d0ce;
        }

        .game-overlay .btn:active {
            transform: translateY(1px);
        }

        /* Ø´Ø±ÙŠØ· Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙÙŠ Ø§Ù„Ø£Ø¹Ù„Ù‰ */
        .stats {
            position: absolute;
            top: 15px;
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 0 20px;
            z-index: 10;
        }

        .stat-item {
            font-size: clamp(1rem, 3vw, 1.3rem);
            background: rgba(0, 30, 60, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(79, 195, 247, 0.5);
        }

        .stat-value {
            font-weight: bold;
            color: #4fc3f7;
            text-shadow: 0 0 5px #4fc3f7;
        }
        
        #soundToggle {
            background: rgba(26, 41, 128, 0.7);
            color: white;
            border: none;
            padding: 8px 15px;
            font-size: clamp(0.8rem, 2.5vw, 1.2rem);
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(79, 195, 247, 0.5);
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        #soundToggle:hover {
            background: rgba(38, 208, 206, 0.7);
        }
        
        #levelUpMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2rem, 10vw, 5rem);
            color: #26d0ce;
            text-shadow: 0 0 20px #26d0ce, 0 0 40px #26d0ce;
            opacity: 0;
            animation: fadeInOut 2s forwards;
            z-index: 100;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            25% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            75% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }
        
        .difficulty-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(0.8rem, 3vw, 1.2rem);
            background: rgba(255, 50, 50, 0.7);
            padding: 5px 15px;
            border-radius: 20px;
            text-align: center;
            z-index: 20;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(255, 50, 50, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 50, 50, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 50, 50, 0.5); }
        }

        /* --- Question Overlay Styles --- */
        .question-overlay {
            justify-content: center;
            padding: 20px;
        }

        .question-overlay .question-content {
            background: rgba(15, 32, 39, 0.95);
            padding: clamp(20px, 5vw, 40px);
            border-radius: 20px;
            max-width: 90%;
            width: 600px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 15px #4fc3f7;
            border: 2px solid #2c5364;
        }

        .question-overlay h2 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #4fc3f7;
        }
        
        /* Ø¬Ø¹Ù„ Ù†ØµÙˆØµ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª ØªØ¨Ø¯Ùˆ Ø£ÙƒØ¨Ø± ÙˆØ£ÙƒØ«Ø± ÙˆØ¶ÙˆØ­Ù‹Ø§ */
        .question-overlay .question-content mjx-container {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            color: white;
        }
        
        .question-overlay .answer-options mjx-container {
            font-size: clamp(1rem, 4vw, 1.2rem);
            color: #0f2027;
        }

        .question-overlay .answer-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }

        .question-overlay .answer-btn {
            background: linear-gradient(to right, #005aa7, #fffde4);
            color: #0f2027;
            border: none;
            padding: 15px;
            font-size: clamp(1rem, 4vw, 1.2rem);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            text-align: center;
            font-weight: bold;
        }

        .question-overlay .answer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .question-overlay .answer-btn:active {
            transform: translateY(0);
        }

        .question-overlay .answer-btn.correct {
            background: linear-gradient(to right, #00b09b, #96c93d);
            color: white;
        }

        .question-overlay .answer-btn.incorrect {
            background: linear-gradient(to right, #c04848, #d84545);
            color: white;
        }

        .question-overlay .message-box {
            margin-top: 20px;
            font-size: clamp(1rem, 4vw, 1.3rem);
            font-weight: bold;
        }
        
        /* Ø´Ø§Ø±Ø© Ø§Ù„Ø§Ø­ØªÙØ§Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© */
        .celebration-badge {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: clamp(2rem, 10vw, 5rem);
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700, 0 0 20px #ffea00;
            animation: popIn 0.5s forwards, pulse 1.5s infinite 0.5s;
            z-index: 100;
            display: none;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            80% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="gameOverlay" class="game-overlay">
        <h1 id="overlayTitle">Space Waves</h1>
        <p id="overlayMessage">Ø§Ù„Ø¹Ø¨ ÙˆØªØ¬Ù†Ø¨ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†</p>
        <button id="overlayBtn" class="btn">Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
    </div>
    
    <!-- Question Overlay -->
    <div id="questionOverlay" class="question-overlay hidden">
        <div class="question-content">
            <h2 id="questionText"></h2>
            <div id="answerOptions" class="answer-options">
                <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª ÙŠØªÙ… Ø¥Ø¯Ø±Ø§Ø¬Ù‡Ø§ Ù‡Ù†Ø§ -->
            </div>
            <p id="feedbackMessage" class="message-box"></p>
        </div>
    </div>

    <!-- Ø´Ø§Ø±Ø© Ø§Ù„Ø§Ø­ØªÙØ§Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© -->
    <div id="celebrationBadge" class="celebration-badge">ğŸ‰</div>

    <div class="stats">
        <div class="stat-item">Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <span id="level" class="stat-value">1</span></div>
        <div class="stat-item">Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="score" class="stat-value">0</span></div>
        <div class="stat-item">Ø§Ù„Ø²Ù…Ù†: <span id="time" class="stat-value">0</span> Ø«Ø§Ù†ÙŠØ©</div>
        <button id="soundToggle">Ø§Ù„ØµÙˆØª: ØªØ´ØºÙŠÙ„</button>
    </div>
    
    <div class="difficulty-indicator">Ù…Ø³Ø§Ø± Ø¬Ø¨Ù„ÙŠ Ø­Ø§Ø¯ ÙˆØ¹Ù‚Ø¨Ø§Øª Ø¯Ø§Ø®Ù„ÙŠØ©!</div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const timeElement = document.getElementById('time');
            const levelElement = document.getElementById('level');
            const overlay = document.getElementById('gameOverlay');
            const overlayTitle = document.getElementById('overlayTitle');
            const overlayMessage = document.getElementById('overlayMessage');
            const overlayBtn = document.getElementById('overlayBtn');
            const soundToggleBtn = document.getElementById('soundToggle');
            
            // Ø¹Ù†Ø§ØµØ± Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
            const questionOverlay = document.getElementById('questionOverlay');
            const questionTextElement = document.getElementById('questionText');
            const answerOptionsContainer = document.getElementById('answerOptions');
            const feedbackMessageElement = document.getElementById('feedbackMessage');
            
            // Ø´Ø§Ø±Ø© Ø§Ù„Ø§Ø­ØªÙØ§Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            const celebrationBadge = document.getElementById('celebrationBadge');
            
            let GAME_WIDTH;
            let GAME_HEIGHT;
            
            // Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
            let gameState = {
                level: 1,
                currentLevelScore: 0, 
                totalScore: 0,
                gameTime: 0,
                gameOver: false,
                gameStarted: false,
                paused: true,
                isLevelComplete: false,
                isQuestionActive: false,
                pathPoints: [],
                pathWidth: 150,
                pathSpeed: 1,
                targetPathSpeed: 4,
                lastTime: 0,
                
                obstacles: [],
                obstacleGenerationInterval: 1000,
                
                // Ø¥Ø¶Ø§ÙØ© Ø­Ø§Ù„Ø© Ø£Ø²Ø±Ø§Ø± Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
                keys: {
                    ArrowUp: false,
                    ArrowDown: false,
                    w: false,
                    s: false
                }
            };
            
            // Ù…ØµÙÙˆÙØ© Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚ Ù„ÙƒÙ„ Ù…Ø³ØªÙˆÙ‰
            const levelColors = ['#ff6b6b', '#ffd166', '#06d6a0', '#118ab2', '#073b4c'];

            // Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
            let touchState = {
                isTouched: false,
                lastY: null
            };

            // Ù…ØªØºÙŠØ±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙØ£Ø±Ø©
            let mouseState = {
                isDown: false,
                lastY: null
            };

            // Ù…ØµÙÙˆÙØ© Ù†Ø¬ÙˆÙ… Ø§Ù„Ø®Ù„ÙÙŠØ©
            let stars = [];
            const numStars = 200;
            const starSpeed = 0.7;
            
            // Ù…ØªØºÙŠØ± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ØµÙˆØª
            let soundEnabled = true;

            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØµÙˆØª
            let audioContext;
            let thrusterOscillator = null;
            let backgroundMelodyTimeoutId = null;
            let isBackgroundMelodyPlaying = false;
            
            const gMajorScale = {
                'G3': 196.00, 'A3': 220.00, 'B3': 246.94, 'D4': 293.66,
                'E4': 329.63, 'F#4': 369.99, 'G4': 392.00, 'A4': 440.00,
                'B4': 493.88, 'D5': 587.33, 'E5': 659.25, 'G5': 783.99
            };

            const cheerfulPianoMelody = [
                { main: 'G4', bass: 'G3', duration: 0.2 },
                { main: 'B4', duration: 0.2 },
                { main: 'D5', duration: 0.2 },
                { main: 'E5', bass: 'G3', duration: 0.4 },
                { main: 'D5', duration: 0.2 },
                { main: 'B4', bass: 'A3', duration: 0.4 },
                { main: 'A4', duration: 0.2 },
                { main: 'G4', bass: 'G3', duration: 0.8 },

                { main: 'G4', bass: 'G3', duration: 0.2 },
                { main: 'D5', duration: 0.2 },
                { main: 'B4', duration: 0.2 },
                { main: 'E5', bass: 'G3', duration: 0.4 },
                { main: 'D5', duration: 0.2 },
                { main: 'B4', bass: 'A3', duration: 0.4 },
                { main: 'A4', duration: 0.2 },
                { main: 'G4', bass: 'G3', duration: 0.8 },
            ];

            // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø­Ø¯Ø«Ø© Ø¨ØµÙŠØºØ© LaTeX
            // ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¯Ù‚Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ÙˆØ§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª
            const questions = [
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(0.5\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{1}{2} \\)", "\\( \\frac{5}{100} \\)", "\\( \\frac{5}{1} \\)", "\\( \\frac{2}{1} \\)"],
                    correctAnswerIndex: 0
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(0.25\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{25}{10} \\)", "\\( \\frac{1}{4} \\)", "\\( \\frac{2}{5} \\)", "\\( \\frac{1}{25} \\)"],
                    correctAnswerIndex: 1
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(3\\frac{1}{2}\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{7}{2} \\)", "\\( \\frac{31}{2} \\)", "\\( \\frac{6}{2} \\)", "\\( \\frac{2}{7} \\)"],
                    correctAnswerIndex: 0
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(-4\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{4}{1} \\)", "\\( -\\frac{4}{1} \\)", "\\( -\\frac{1}{4} \\)", "\\( \\frac{4}{4} \\)"],
                    correctAnswerIndex: 1
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ Ø§Ù„Ø¯ÙˆØ±ÙŠ \\(0.666...\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{6}{10} \\)", "\\( \\frac{2}{3} \\)", "\\( \\frac{6}{100} \\)", "\\( \\frac{1}{6} \\)"],
                    correctAnswerIndex: 1
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(0.8\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{8}{100} \\)", "\\( \\frac{4}{5} \\)", "\\( \\frac{1}{8} \\)", "\\( \\frac{8}{1} \\)"],
                    correctAnswerIndex: 1
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(5\\frac{1}{3}\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{16}{3} \\)", "\\( \\frac{51}{3} \\)", "\\( \\frac{1}{53} \\)", "\\( \\frac{8}{3} \\)"],
                    correctAnswerIndex: 0
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(0.1\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{1}{100} \\)", "\\( \\frac{1}{10} \\)", "\\( \\frac{10}{1} \\)", "\\( \\frac{1}{1} \\)"],
                    correctAnswerIndex: 1
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(2\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{2}{2} \\)", "\\( \\frac{2}{1} \\)", "\\( \\frac{1}{2} \\)", "\\( \\frac{8}{2} \\)"],
                    correctAnswerIndex: 1
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(0.7\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{7}{100} \\)", "\\( \\frac{7}{10} \\)", "\\( \\frac{7}{1} \\)", "\\( \\frac{1}{7} \\)"],
                    correctAnswerIndex: 1
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(1.5\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{15}{100} \\)", "\\( \\frac{3}{2} \\)", "\\( \\frac{1}{5} \\)", "\\( \\frac{1}{2} \\)"],
                    correctAnswerIndex: 1
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(-0.8\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( -\\frac{8}{10} \\)", "\\( \\frac{4}{5} \\)", "\\( \\frac{8}{100} \\)", "\\( -\\frac{1}{8} \\)"],
                    correctAnswerIndex: 0
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(6\\frac{2}{3}\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{20}{3} \\)", "\\( \\frac{62}{3} \\)", "\\( \\frac{12}{3} \\)", "\\( \\frac{3}{20} \\)"],
                    correctAnswerIndex: 0
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ Ø§Ù„Ø¯ÙˆØ±ÙŠ \\(0.444...\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{4}{10} \\)", "\\( \\frac{4}{9} \\)", "\\( \\frac{1}{4} \\)", "\\( \\frac{44}{100} \\)"],
                    correctAnswerIndex: 1
                },
                {
                    question: "Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø¨ÙŠ \\(1.25\\) Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ \\( \\frac{a}{b} \\).",
                    options: ["\\( \\frac{5}{4} \\)", "\\( \\frac{125}{10} \\)", "\\( \\frac{4}{5} \\)", "\\( \\frac{1}{25} \\)"],
                    correctAnswerIndex: 0
                }
            ];
            
            // Ù…ØªØºÙŠØ± Ù„ØªØªØ¨Ø¹ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ
            let currentQuestion = null;
            // Ù…ØªØºÙŠØ± Ø¬Ø¯ÙŠØ¯ Ù„ØªØ®Ø²ÙŠÙ† ÙÙ‡Ø±Ø³ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ø¨Ø¹Ø¯ Ø®Ù„Ø· Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª
            let currentCorrectIndex = -1;
            
            // Ù…ØªØºÙŠØ±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
            let questionPool = [];
            
            // Ø¯Ø§Ù„Ø© Ù„Ø®Ù„Ø· Ø¹Ù†Ø§ØµØ± Ù…ØµÙÙˆÙØ©
            function shuffleArray(array) {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            }
            
            // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ù„Ù„Ù…Ø³ØªÙˆÙ‰
            function setupQuestionPool() {
                questionPool = shuffleArray(questions);
            }

            function playSound(frequency, type = 'sine', duration = 0.5, volume = 0.5) {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                if (!soundEnabled) return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = type;
                oscillator.frequency.value = frequency;

                const currentTime = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, currentTime + 0.02);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, currentTime + duration);

                oscillator.start(currentTime);
                oscillator.stop(currentTime + duration);
            }

            function playNoteOrChord(notes, duration, volume) {
                if (Array.isArray(notes)) {
                    notes.forEach(note => {
                        const frequency = gMajorScale[note];
                        if (frequency) {
                            playSound(frequency, 'sine', duration, volume);
                        }
                    });
                } else {
                    const frequency = gMajorScale[notes];
                    if (frequency) {
                        playSound(frequency, 'sine', duration, volume);
                    }
                }
            }
            
            function playContinuousMelody(melody, index = 0) {
                if (!isBackgroundMelodyPlaying) {
                    return;
                }

                const noteData = melody[index];
                const nextIndex = (index + 1) % melody.length;
                const delay = noteData.duration * 1000;
                
                playNoteOrChord(noteData.main, noteData.duration, 0.4);

                if (noteData.bass) {
                    playSound(gMajorScale[noteData.bass], 'sine', noteData.duration, 0.4);
                }

                backgroundMelodyTimeoutId = setTimeout(() => {
                    playContinuousMelody(melody, nextIndex);
                }, delay);
            }
            
            function startBackgroundMelody() {
                if (!soundEnabled) return;
                if (isBackgroundMelodyPlaying) return;
                
                isBackgroundMelodyPlaying = true;
                playContinuousMelody(cheerfulPianoMelody);
            }
            
            function stopBackgroundMelody() {
                if (isBackgroundMelodyPlaying) {
                    clearTimeout(backgroundMelodyTimeoutId);
                    isBackgroundMelodyPlaying = false;
                }
            }
            
            // ØªÙ… ØªØ¹Ø¯ÙŠÙ„ ØµÙˆØª Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ù„ÙŠÙƒÙˆÙ† Ø£ÙƒØ«Ø± Ø§Ø­ØªÙØ§Ù„ÙŠØ©
            function playLevelUpSound() {
                playSound(1000, 'sine', 0.1, 0.4);
                setTimeout(() => playSound(1200, 'sine', 0.1, 0.4), 100);
                setTimeout(() => playSound(1500, 'sine', 0.1, 0.4), 200);
            }

            function playCollisionSound() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const now = audioContext.currentTime;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.linearRampToValueAtTime(100, now + 0.3);
                
                gainNode.gain.setValueAtTime(0.6, now);
                gainNode.gain.linearRampToValueAtTime(0.001, now + 0.4);
                
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }

            // ØµÙˆØª Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
            function playCorrectSound() {
                playSound(1000, 'sine', 0.2, 0.6);
                setTimeout(() => playSound(1500, 'sine', 0.2, 0.6), 100);
            }

            // ØµÙˆØª Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø®Ø§Ø·Ø¦Ø©
            function playIncorrectSound() {
                playSound(400, 'triangle', 0.3, 0.5);
                setTimeout(() => playSound(200, 'triangle', 0.3, 0.5), 100);
            }

            function startThrusterSound() {
                if (!soundEnabled) return;
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (thrusterOscillator) return;
                
                thrusterOscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                thrusterOscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                thrusterOscillator.type = 'sine';
                thrusterOscillator.frequency.value = 80;
                gainNode.gain.value = 0.1;
                
                thrusterOscillator.start();
            }

            function stopThrusterSound() {
                if (thrusterOscillator) {
                    thrusterOscillator.stop();
                    thrusterOscillator.disconnect();
                    thrusterOscillator = null;
                }
            }
            
            let thrusterParticles = [];
            // Ù…ØªØºÙŠØ± Ø¬Ø¯ÙŠØ¯ Ù„Ø¬Ø³ÙŠÙ…Ø§Øª Ø§Ù„Ø§Ø­ØªÙØ§Ù„
            let celebrationParticles = [];

            const ship = {
                x: 0,
                y: 0,
                width: 30,
                height: 50,
                velocity: { x: 0, y: 0 },
                maxSpeed: 8,
                rotation: Math.PI / 2,
                color: '#4fc3f7',
                draw: function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);

                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(0, -this.height / 2);
                    ctx.lineTo(-this.width / 2, this.height / 2);
                    ctx.lineTo(-this.width / 4, this.height / 4);
                    ctx.lineTo(this.width / 4, this.height / 4);
                    ctx.lineTo(this.width / 2, this.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#e1f5fe';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(0, -this.height / 4, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            };

            function generateThrusterParticles() {
                const particleCount = 3;
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.PI;
                    const spread = Math.random() * Math.PI / 8 - Math.PI / 16;
                    const pAngle = angle + spread;
                    const pSpeed = Math.random() * 3 + 2;
                    
                    thrusterParticles.push({
                        x: ship.x,
                        y: ship.y,
                        vx: Math.cos(pAngle) * pSpeed,
                        vy: Math.sin(pAngle) * pSpeed,
                        size: Math.random() * 8 + 3,
                        life: 60,
                        color: `rgba(255, 100, 50, ${Math.random() * 0.7 + 0.3})`
                    });
                }
            }

            function updateThrusterParticles() {
                thrusterParticles = thrusterParticles.filter(p => p.life > 0);
                thrusterParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    p.size *= 0.95;
                });
            }

            function drawThrusterParticles() {
                thrusterParticles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.shadowColor = 'rgba(255, 100, 50, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            }
            
            // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø¬Ø³ÙŠÙ…Ø§Øª Ø§Ù„Ø§Ø­ØªÙØ§Ù„
            function generateCelebrationParticles() {
                const colors = ['#ffd700', '#ff6b6b', '#ffd166', '#06d6a0', '#118ab2'];
                const particleCount = 50;
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    celebrationParticles.push({
                        x: GAME_WIDTH / 2,
                        y: GAME_HEIGHT / 2,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: Math.random() * 5 + 3,
                        life: 120,
                        color: colors[Math.floor(Math.random() * colors.length)]
                    });
                }
            }

            function updateCelebrationParticles() {
                celebrationParticles = celebrationParticles.filter(p => p.life > 0);
                celebrationParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    p.size *= 0.98;
                    p.vy += 0.1; // Ø¥Ø¶Ø§ÙØ© Ø¬Ø§Ø°Ø¨ÙŠØ© Ø¨Ø³ÙŠØ·Ø©
                });
            }

            function drawCelebrationParticles() {
                celebrationParticles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            }

            function createStars() {
                stars = [];
                for (let i = 0; i < numStars; i++) {
                    stars.push({
                        x: Math.random() * GAME_WIDTH,
                        y: Math.random() * GAME_HEIGHT,
                        size: Math.random() * 2,
                        speed: Math.random() * starSpeed + 0.1,
                        color: `rgba(255, 255, 255, ${Math.random() * 0.7 + 0.3})`
                    });
                }
            }

            function drawStars() {
                stars.forEach(star => {
                    ctx.fillStyle = star.color;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function updateStars() {
                stars.forEach(star => {
                    star.x -= star.speed * gameState.pathSpeed / 2;
                    if (star.x < 0) {
                        star.x = GAME_WIDTH;
                        star.y = Math.random() * GAME_HEIGHT;
                    }
                });
            }
            
            function getSawtoothPathY(x, timeOffset) {
                const period = 500;
                const amplitude = 150;
                const speedFactor = 0.5;

                const adjustedX = x + timeOffset * gameState.pathSpeed * speedFactor;
                const normalizedX = (adjustedX % period) / period;

                let yOffset;
                if (normalizedX < 0.5) {
                    yOffset = normalizedX * 2;
                } else {
                    yOffset = (1 - normalizedX) * 2;
                }

                return yOffset * amplitude - amplitude / 2;
            }
            
            // ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø§Ù„Ø³Ø±ÙŠØ¹.
            // Ø§Ù„Ø¢Ù† ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø± Ù„ÙŠØ¨Ø¯Ø£ Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø±ÙƒØ¨Ø© Ø¨Ù…Ø³Ø§ÙØ© ÙƒØ§ÙÙŠØ© Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù….
            function initializePath() {
                gameState.pathPoints = [];
                const segments = 100;
                const segmentWidth = GAME_WIDTH / 10; 
                const initialYOffset = GAME_HEIGHT / 2;
                
                // Ù†Ø¨Ø¯Ø£ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ù…Ù† Ù…ÙˆÙ‚Ø¹ Ø£Ø¨Ø¹Ø¯ Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø± Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø§Ù„ÙÙˆØ±ÙŠ.
                // ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¢Ù† Ù…Ù† -GAME_WIDTH*2 Ù„Ø¶Ù…Ø§Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§Ø± Ø¢Ù…Ù†.
                for (let i = -20; i <= segments; i++) {
                    const x = i * segmentWidth;
                    const y = getSawtoothPathY(x, gameState.gameTime) + initialYOffset;
                    gameState.pathPoints.push({ x: x, y: y });
                }
            }
            
            function updatePath() {
                gameState.pathPoints.forEach(point => {
                    point.x -= gameState.pathSpeed;
                });

                // Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø·Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¹Ù†Ø¯ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø³Ø§Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©
                if (gameState.pathPoints[0].x < -GAME_WIDTH) {
                    gameState.pathPoints.shift();
                    const lastPoint = gameState.pathPoints[gameState.pathPoints.length - 1];
                    
                    const newX = lastPoint.x + (GAME_WIDTH / 10);
                    const newY = getSawtoothPathY(newX, gameState.gameTime) + GAME_HEIGHT / 2;
                    gameState.pathPoints.push({ x: newX, y: newY });
                }
            }
            
            function drawPath() {
                ctx.strokeStyle = 'rgba(79, 195, 247, 0.4)';
                ctx.lineWidth = gameState.pathWidth;
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
                
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 4;
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y - gameState.pathWidth / 2);
                    } else {
                        ctx.lineTo(point.x, point.y - gameState.pathWidth / 2);
                    }
                });
                ctx.stroke();
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y + gameState.pathWidth / 2);
                    } else {
                        ctx.lineTo(point.x, point.y + gameState.pathWidth / 2);
                    }
                });
                ctx.stroke();
                
                ctx.strokeStyle = '#26d0ce';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 10]);
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y - gameState.pathWidth / 4);
                    } else {
                        ctx.lineTo(point.x, point.y - gameState.pathWidth / 4);
                    }
                });
                ctx.stroke();
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y + gameState.pathWidth / 4);
                    } else {
                        ctx.lineTo(point.x, point.y + gameState.pathWidth / 4);
                    }
                });
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            let lastObstacleTime = 0;
            function generateObstacles(timestamp) {
                if (timestamp - lastObstacleTime > gameState.obstacleGenerationInterval) {
                    const pathPoint = gameState.pathPoints.find(p => p.x > GAME_WIDTH * 0.9);
                    
                    if (pathPoint) {
                        // ØªØ¹Ø¯ÙŠÙ„: Ø²ÙŠØ§Ø¯Ø© Ø­Ø¬Ù… Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚ Ø¨Ø¹Ø¯ Ø§Ù„Ø«Ø§Ù†ÙŠØ© 16
                        let obstacleRadius;
                        if (gameState.gameTime >= 16) {
                            // Ø­Ø¬Ù… Ø£ÙƒØ¨Ø± Ø¨Ø¹Ø¯ 16 Ø«Ø§Ù†ÙŠØ©
                            obstacleRadius = Math.random() * 10 + 15; // Ø­Ø¬Ù… Ø¨ÙŠÙ† 15 Ùˆ 25
                        } else {
                            // Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø£ØµÙ„ÙŠ
                            obstacleRadius = Math.random() * 5 + 10; // Ø­Ø¬Ù… Ø¨ÙŠÙ† 10 Ùˆ 15
                        }

                        let randomY;
                        
                        // ÙˆØ¶Ø¹ Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚ Ø¹Ù„Ù‰ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø³Ø§Ø±
                        if (Math.random() > 0.5) {
                            // Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø¹Ù„ÙˆÙŠ Ù„Ù„Ù…Ø³Ø§Ø±
                            randomY = pathPoint.y - gameState.pathWidth / 2 + obstacleRadius;
                        } else {
                            // Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø³ÙÙ„ÙŠ Ù„Ù„Ù…Ø³Ø§Ø±
                            randomY = pathPoint.y + gameState.pathWidth / 2 - obstacleRadius;
                        }

                        const colorIndex = (gameState.level - 1) % levelColors.length;
                        const obstacleColor = levelColors[colorIndex];

                        gameState.obstacles.push({
                            x: GAME_WIDTH,
                            y: randomY,
                            radius: obstacleRadius,
                            color: obstacleColor
                        });
                    }
                    
                    lastObstacleTime = timestamp;
                    // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ÙØ§ØµÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚ Ù…Ø¹ ØªÙ‚Ø¯Ù… Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØµØ¹ÙˆØ¨Ø©
                    gameState.obstacleGenerationInterval = Math.max(500, 1000 - gameState.level * 50);
                }
            }
            
            function drawObstacles() {
                gameState.obstacles.forEach(obstacle => {
                    ctx.fillStyle = obstacle.color; 
                    ctx.shadowColor = obstacle.color;
                    ctx.shadowBlur = 20;

                    const spikes = 8;
                    const outerRadius = obstacle.radius * 1.5;
                    const innerRadius = obstacle.radius * 0.7;
                    const rotationAngle = gameState.gameTime * 0.5;

                    ctx.save();
                    ctx.translate(obstacle.x, obstacle.y);
                    ctx.rotate(rotationAngle);
                    
                    ctx.beginPath();
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (Math.PI / spikes) * i;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(0, 0, innerRadius * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                });
            }

            function updateObstacles() {
                gameState.obstacles.forEach(obstacle => {
                    obstacle.x -= gameState.pathSpeed;
                });
                gameState.obstacles = gameState.obstacles.filter(obstacle => obstacle.x + obstacle.radius > 0);
            }

            function checkPathCollision() {
                let minDistance = Infinity;
                
                for (let i = 0; i < gameState.pathPoints.length - 1; i++) {
                    const pointA = gameState.pathPoints[i];
                    const pointB = gameState.pathPoints[i + 1];
                    
                    const dx = pointB.x - pointA.x;
                    const dy = pointB.y - pointA.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    
                    if (length === 0) continue;

                    const t = Math.max(0, Math.min(1, 
                        ((ship.x - pointA.x) * dx + (ship.y - pointA.y) * dy) / (length * length)
                    ));
                    
                    const projectionX = pointA.x + t * dx;
                    const projectionY = pointA.y + t * dy;
                    
                    const distance = Math.sqrt(
                        Math.pow(ship.x - projectionX, 2) + 
                        Math.pow(ship.y - projectionY, 2)
                    );
                    
                    minDistance = Math.min(minDistance, distance);
                }
                
                if (minDistance > gameState.pathWidth / 2 - 25) { 
                    return true;
                }
                
                return false;
            }
            
            function checkObstacleCollision() {
                for (const obstacle of gameState.obstacles) {
                    const distance = Math.sqrt(
                        Math.pow(ship.x - obstacle.x, 2) + 
                        Math.pow(ship.y - obstacle.y, 2)
                    );
                    if (distance < (ship.height / 2) + obstacle.radius) {
                        return true;
                    }
                }
                return false;
            }

            // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…: Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø£ÙŠ Ø§ØµØ·Ø¯Ø§Ù…ØŒ Ø³ÙŠØªÙ… Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø³Ø¤Ø§Ù„.
            function checkCollision() {
                if (checkPathCollision() || checkObstacleCollision()) {
                    handleQuestionCollision();
                }
            }

            // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… ÙˆØ¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø³Ø¤Ø§Ù„
            function handleQuestionCollision() {
                playCollisionSound();
                gameState.paused = true;
                gameState.isQuestionActive = true;
                stopThrusterSound();
                stopBackgroundMelody();

                // ===== Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ø¹Ø¯Ø© =====
                if (questionPool.length === 0) {
                    setupQuestionPool(); // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹Ø¨Ø¦Ø© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ÙØ§Ø±ØºØ©
                }
                currentQuestion = questionPool.pop();
                // =====================================================================

                showQuestion(currentQuestion);
            }

            // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… MathJax
            function showQuestion(question) {
                questionTextElement.innerHTML = question.question;
                answerOptionsContainer.innerHTML = '';
                feedbackMessageElement.textContent = '';
                
                // === Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: Ù†Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø®Ù„Ø· ===
                // Ù‡Ø°Ø§ ÙŠÙ…Ù†Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙÙ‡Ø±Ø³ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ù„Ø³Ø¤Ø§Ù„ ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
                const correctAnswerText = question.options[question.correctAnswerIndex];
                
                const shuffledOptions = shuffleArray([...question.options]);
                
                // === Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: Ù†Ø¬Ø¯ Ø§Ù„ÙÙ‡Ø±Ø³ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© ÙˆÙ†Ø®Ø²Ù†Ù‡ ÙÙŠ Ù…ØªØºÙŠØ± Ù…Ø¤Ù‚Øª ===
                currentCorrectIndex = shuffledOptions.findIndex(option => option === correctAnswerText);
                
                shuffledOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.classList.add('answer-btn');
                    button.innerHTML = option;
                    button.addEventListener('click', () => handleAnswer(index));
                    answerOptionsContainer.appendChild(button);
                });
                
                questionOverlay.classList.remove('hidden');

                // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù‚Ø¨Ù„ Ø·Ù„Ø¨ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¹Ø±Ø¶ Ù„Ø¶Ù…Ø§Ù† ØªØ­Ù…ÙŠÙ„ MathJax
                setTimeout(() => {
                     if (window.MathJax) {
                        window.MathJax.typesetPromise([questionTextElement, answerOptionsContainer]).catch((err) => console.error('MathJax typesetting failed:', err));
                    }
                }, 100); // 100 Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ© ÙƒØ§ÙÙŠØ© Ø¹Ø§Ø¯Ø©Ù‹
            }

            // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
            function handleAnswer(selectedIndex) {
                // === Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: Ù†Ù‚Ø§Ø±Ù† Ø§Ù„ÙÙ‡Ø±Ø³ Ø§Ù„Ù…Ø®ØªØ§Ø± Ø¨Ø§Ù„ÙÙ‡Ø±Ø³ Ø§Ù„ØµØ­ÙŠØ­ Ø§Ù„Ù…Ø¤Ù‚Øª ===
                const isCorrect = (selectedIndex === currentCorrectIndex);
                const buttons = answerOptionsContainer.querySelectorAll('.answer-btn');
                
                buttons.forEach((btn, index) => {
                    btn.disabled = true;
                    if (index === currentCorrectIndex) {
                        btn.classList.add('correct');
                    } else if (index === selectedIndex) {
                        btn.classList.add('incorrect');
                    }
                });

                if (isCorrect) {
                    playCorrectSound();
                    feedbackMessageElement.textContent = "Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨.";
                    feedbackMessageElement.style.color = "#00b09b";
                    
                    // Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø· Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ø¥Ù„Ù‰ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ
                    gameState.currentLevelScore += 50; 
                    scoreElement.textContent = gameState.totalScore + gameState.currentLevelScore;

                    setTimeout(() => {
                        questionOverlay.classList.add('hidden');
                        gameState.isQuestionActive = false;
                        
                        // ===== Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù„Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: Ø¥Ø¹Ø§Ø¯Ø© ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© =====
                        // Ø¥Ø¹Ø§Ø¯Ø© ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø³Ø§Ø± ÙˆØ¬Ù…ÙŠØ¹ Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù„Ø¹Ø¨Ø© Ù„ØªÙˆÙÙŠØ± Ø¨ÙŠØ¦Ø© Ø¢Ù…Ù†Ø© Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯.
                        initializePath();
                        gameState.obstacles = [];
                        gameState.pathSpeed = 1; // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø³Ø±Ø¹Ø© Ø¥Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
                        positionShipOnPath();
                        gameState.paused = false;
                        gameState.lastTime = performance.now(); // Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ÙˆÙ‚Øª Ø¹Ù†Ø¯ Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø©
                        // ====================================================================================

                        startBackgroundMelody(); // Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ©
                        startThrusterSound(); // Ø§Ø³ØªØ¦Ù†Ø§Ù ØµÙˆØª Ø§Ù„Ø¯ÙØ¹
                    }, 1500);
                } else {
                    // Ø§Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø®Ø§Ø·Ø¦Ø©
                    playIncorrectSound();
                    feedbackMessageElement.textContent = "Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©. Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!";
                    feedbackMessageElement.style.color = "#c04848";
                    setTimeout(() => {
                        questionOverlay.classList.add('hidden');
                        gameState.gameOver = true; // Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
                    }, 1500);
                }
            }

            // Ø¯Ø§Ù„Ø© Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±ÙƒØ¨Ø© ÙÙŠ Ù…Ù†ØªØµÙ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¢Ù…Ù†
            function positionShipOnPath() {
                const shipX = GAME_WIDTH * 0.2;
                let foundSegment = false;
                
                for (let i = 0; i < gameState.pathPoints.length - 1; i++) {
                    const pointA = gameState.pathPoints[i];
                    const pointB = gameState.pathPoints[i + 1];
                    
                    if (pointA.x <= shipX && pointB.x >= shipX) {
                        const t = (shipX - pointA.x) / (pointB.x - pointA.x);
                        ship.y = pointA.y + t * (pointB.y - pointA.y);
                        ship.x = shipX;
                        foundSegment = true;
                        break;
                    }
                }
                
                if (!foundSegment && gameState.pathPoints.length > 0) {
                    ship.x = gameState.pathPoints[0].x;
                    ship.y = gameState.pathPoints[0].y;
                }
            }

            function resizeCanvas() {
                GAME_WIDTH = window.innerWidth;
                GAME_HEIGHT = window.innerHeight;
                
                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;

                if (gameState.gameStarted) {
                    initializePath();
                    positionShipOnPath();
                }
            }

            // ===== ØªØ­Ø¯ÙŠØ«: ØªØ¹Ø¯ÙŠÙ„ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø£Ø­Ø¯Ø§Ø« Ø§Ù„ÙØ£Ø±Ø© Ù„ØªØ¹Ù…Ù„ Ù…Ø«Ù„ Ø§Ù„Ù„Ù…Ø³ =====
            canvas.addEventListener('mousedown', (e) => {
                if (gameState.gameStarted && !gameState.paused && !gameState.isQuestionActive) {
                    mouseState.isDown = true;
                    mouseState.lastY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', () => {
                mouseState.isDown = false;
                mouseState.lastY = null;
            });

            canvas.addEventListener('mousemove', (e) => {
                // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙØ£Ø±Ø© ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø²Ø± Ø§Ù„ÙØ£Ø±Ø© Ù…Ø¶ØºÙˆØ·Ø§Ù‹
                if (mouseState.isDown && gameState.gameStarted && !gameState.paused && !gameState.isQuestionActive) {
                    const deltaY = e.clientY - mouseState.lastY;
                    ship.y += deltaY;
                    mouseState.lastY = e.clientY;
                    // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø±ÙƒØ¨Ø© Ù„Ø§ ØªØ®Ø±Ø¬ Ø¹Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø´Ø§Ø´Ø©
                    ship.y = Math.max(30, Math.min(GAME_HEIGHT - 30, ship.y));
                }
            });
            // ===== Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ =====
            
            // Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù„Ù…Ø³
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);

            function handleTouchStart(e) {
                if (gameState.paused || gameState.gameOver || !gameState.gameStarted || gameState.isLevelComplete) return;
                e.preventDefault();
                touchState.isTouched = true;
                const touch = e.changedTouches[0];
                touchState.lastY = touch.clientY;
            }

            function handleTouchMove(e) {
                if (!touchState.isTouched) return;
                e.preventDefault();
                const touch = e.changedTouches[0];
                const deltaY = touch.clientY - touchState.lastY;
                ship.y += deltaY;
                touchState.lastY = touch.clientY;
                ship.y = Math.max(30, Math.min(GAME_HEIGHT - 30, ship.y));
            }
            
            function handleTouchEnd(e) {
                touchState.isTouched = false;
                touchState.lastY = null;
            }

            function draw() {
                ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                updateStars();
                drawStars();
                
                drawPath();
                
                drawObstacles();

                generateThrusterParticles();
                updateThrusterParticles();
                drawThrusterParticles();
                
                ship.draw();
                
                // Ø±Ø³Ù… Ø¬Ø³ÙŠÙ…Ø§Øª Ø§Ù„Ø§Ø­ØªÙØ§Ù„
                drawCelebrationParticles();
            }
            
            // Ø¯Ø§Ù„Ø© Ù„Ù„Ø¨Ø¯Ø¡ Ø¨Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ
            function nextLevel() {
                // Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¥Ù„Ù‰ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©
                gameState.totalScore += gameState.currentLevelScore;
                
                // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØµØ¹ÙˆØ¨Ø© Ù„Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ
                gameState.level++;
                gameState.gameTime = 0;
                gameState.isLevelComplete = false;
                gameState.paused = false;
                
                // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ
                gameState.currentLevelScore = 0;
                
                // ØªØ­Ø¯ÙŠØ« Ø³Ø±Ø¹Ø© Ø§Ù„Ù…Ø³Ø§Ø± Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØµØ¹ÙˆØ¨Ø©
                gameState.pathSpeed = 1 + (gameState.level - 1) * 0.5; // Ø³Ø±Ø¹Ø© Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ© Ø£Ø³Ø±Ø¹
                gameState.targetPathSpeed = gameState.pathSpeed + 3 + (gameState.level - 1) * 1; // Ø³Ø±Ø¹Ø© Ù…Ø³ØªÙ‡Ø¯ÙØ© Ø£Ø¹Ù„Ù‰
                
                // ØªØ¶ÙŠÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø±
                gameState.pathWidth = 150 - (gameState.level - 1) * 10;
                gameState.pathWidth = Math.max(50, gameState.pathWidth);
                
                levelElement.textContent = gameState.level;
                scoreElement.textContent = gameState.totalScore;
                timeElement.textContent = gameState.gameTime;
                
                gameState.obstacles = []; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚
                
                initializePath();
                positionShipOnPath();
                
                gameState.lastTime = performance.now();
                
                startThrusterSound();
                startBackgroundMelody();
                
                // Ø¥Ø®ÙØ§Ø¡ Ø´Ø§Ø±Ø© Ø§Ù„Ø§Ø­ØªÙØ§Ù„
                celebrationBadge.style.display = 'none';
                
                // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ù„Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¬Ø¯ÙŠØ¯
                setupQuestionPool();
            }

            function update(timestamp) {
                if (gameState.paused || gameState.gameOver || !gameState.gameStarted || gameState.isQuestionActive) {
                    // ØªØ­Ø¯ÙŠØ« Ø¬Ø³ÙŠÙ…Ø§Øª Ø§Ù„Ø§Ø­ØªÙØ§Ù„ Ø­ØªÙ‰ Ø¨Ø¹Ø¯ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø©
                    updateCelebrationParticles();
                    return;
                }
                
                const deltaTime = timestamp - gameState.lastTime;
                gameState.lastTime = timestamp;
                
                gameState.gameTime += deltaTime / 1000;
                timeElement.textContent = Math.floor(gameState.gameTime);

                // Ø²ÙŠØ§Ø¯Ø© Ø³Ø±Ø¹Ø© Ø§Ù„Ù…Ø±ÙƒØ¨Ø© ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹ Ø­ØªÙ‰ ØªØµÙ„ Ù„Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ©
                if (gameState.pathSpeed < gameState.targetPathSpeed) {
                    gameState.pathSpeed += 0.01;
                }

                // === Ø§Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¨Ø¹Ø¯ 30 Ø«Ø§Ù†ÙŠØ© ===
                if (Math.floor(gameState.gameTime) >= 30 && !gameState.isLevelComplete) {
                    gameState.paused = true;
                    gameState.isLevelComplete = true;
                    playLevelUpSound();
                    stopThrusterSound();
                    stopBackgroundMelody();
                    generateCelebrationParticles(); // ØªÙˆÙ„ÙŠØ¯ Ø¬Ø³ÙŠÙ…Ø§Øª Ø§Ù„Ø§Ø­ØªÙØ§Ù„
                    celebrationBadge.style.display = 'block'; // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø´Ø§Ø±Ø©
                    return; // Ø¥ÙŠÙ‚Ø§Ù ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù„Ø¹Ø¨Ø©
                }
                
                // Ù†Ù‚Ø§Ø· Ø§Ù„ÙˆÙ‚Øª Ù„Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ
                gameState.currentLevelScore = Math.floor(gameState.gameTime * 10);
                scoreElement.textContent = gameState.totalScore + gameState.currentLevelScore;
                
                // === Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ Ù‡Ùˆ Ù…Ø§ ÙŠØ¶Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø±ÙƒØ¨Ø© Ù„Ø§ ØªØªØ­Ø±Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ===
                // ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø±ÙƒØ¨Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¶ØºØ· Ø§Ù„Ù…ÙØ§ØªÙŠØ­ ÙÙ‚Ø·.
                // Ø¥Ø°Ø§ Ù„Ù… ÙŠØ¶ØºØ· Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¹Ù„Ù‰ Ø£ÙŠ Ù…ÙØªØ§Ø­ØŒ ÙØ¥Ù† Ù‚ÙŠÙ…Ø© dy Ø³ØªÙƒÙˆÙ† ØµÙØ±Ù‹Ø§ØŒ ÙˆØ¨Ø§Ù„ØªØ§Ù„ÙŠ Ù„Ù† ØªØªØ­Ø±Ùƒ Ø§Ù„Ù…Ø±ÙƒØ¨Ø©.
                let dy = 0;
                const speed = 5; // Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ø§Ù„Ø£Ø³Ù‡Ù…
                if (gameState.keys.ArrowUp || gameState.keys.w) {
                    dy = -speed;
                }
                if (gameState.keys.ArrowDown || gameState.keys.s) {
                    dy = speed;
                }
                ship.y += dy;
                // =================================================================

                // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø±ÙƒØ¨Ø© Ù„Ø§ ØªØ®Ø±Ø¬ Ø¹Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø´Ø§Ø´Ø©
                // Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ ØªÙ… Ù†Ù‚Ù„Ù‡ Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙØ£Ø±Ø© ÙˆØ§Ù„Ù„Ù…Ø³
                // ship.y = Math.max(30, Math.min(GAME_HEIGHT - 30, ship.y));

                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³Ø§Ø± ÙˆØ§Ù„Ø¹ÙˆØ§Ø¦Ù‚
                updatePath();
                updateObstacles();
                generateObstacles(timestamp);
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…Ø§Øª
                checkCollision();

                // ØªØ­Ø¯ÙŠØ« Ø¬Ø³ÙŠÙ…Ø§Øª Ø§Ù„Ø§Ø­ØªÙØ§Ù„
                updateCelebrationParticles();
            }
            
            function gameLoop(timestamp) {
                if (!gameState.gameStarted) {
                    // Ø§Ù„Ù„Ø¹Ø¨Ø© Ù„Ù… ØªØ¨Ø¯Ø£ Ø¨Ø¹Ø¯ØŒ Ù„Ø§ ØªÙØ¹Ù„ Ø´ÙŠØ¦Ù‹Ø§
                    requestAnimationFrame(gameLoop);
                    return;
                }

                update(timestamp);
                draw();
                
                if (gameState.gameOver) {
                    overlayTitle.textContent = 'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!';
                    overlayMessage.textContent = `Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©: ${gameState.totalScore}`;
                    overlayBtn.textContent = 'Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„';
                    overlay.classList.remove('hidden');
                    stopThrusterSound();
                    stopBackgroundMelody();
                } else if (gameState.isLevelComplete) { // Ø­Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙ‰
                    overlayTitle.textContent = 'Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰!';
                    overlayMessage.textContent = `Ù„Ù‚Ø¯ Ø¬Ù…Ø¹Øª ${gameState.currentLevelScore} Ù†Ù‚Ø·Ø© ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªÙˆÙ‰.\nÙ†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©: ${gameState.totalScore + gameState.currentLevelScore}`;
                    overlayBtn.textContent = 'Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ';
                    overlay.classList.remove('hidden');
                } else if (gameState.paused && !gameState.isQuestionActive) {
                    overlayTitle.textContent = 'Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª';
                    overlayMessage.textContent = 'Ø§Ù„Ù„Ø¹Ø¨Ø© ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¤Ù‚Øª';
                    overlayBtn.textContent = 'Ø§Ø³ØªÙ…Ø±Ø§Ø±';
                    overlay.classList.remove('hidden');
                    stopThrusterSound();
                    stopBackgroundMelody();
                } else {
                    overlay.classList.add('hidden');
                    if (gameState.gameStarted && !gameState.isQuestionActive) {
                        startThrusterSound();
                        startBackgroundMelody();
                    }
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            function startGame() {
                gameState = {
                    level: 1,
                    currentLevelScore: 0,
                    totalScore: 0,
                    gameTime: 0,
                    gameOver: false,
                    gameStarted: true,
                    paused: false,
                    isLevelComplete: false,
                    isQuestionActive: false,
                    pathPoints: [],
                    pathWidth: 150,
                    pathSpeed: 1, // Ø³Ø±Ø¹Ø© Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ©
                    targetPathSpeed: 4, // Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ©
                    lastTime: performance.now(), // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø¯Ø¡
                    
                    obstacles: [],
                    obstacleGenerationInterval: 1000,
                    keys: {
                        ArrowUp: false,
                        ArrowDown: false,
                        w: false,
                        s: false
                    }
                };
                
                // Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©
                setupQuestionPool();
                
                initializePath();
                positionShipOnPath();
                
                scoreElement.textContent = '0';
                timeElement.textContent = '0';
                levelElement.textContent = '1';
                
                thrusterParticles = [];
                
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                startThrusterSound();
                startBackgroundMelody();
                
                // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
                overlay.classList.add('hidden');
            }
            
            overlayBtn.addEventListener('click', () => {
                if (gameState.gameOver || !gameState.gameStarted) {
                    startGame();
                } else if (gameState.isLevelComplete) { // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø²Ø± "Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ"
                    nextLevel();
                } else if (gameState.paused) {
                    gameState.paused = false;
                    gameState.lastTime = performance.now();
                }
            });

            soundToggleBtn.addEventListener('click', () => {
                soundEnabled = !soundEnabled;
                soundToggleBtn.textContent = `Ø§Ù„ØµÙˆØª: ${soundEnabled ? 'ØªØ´ØºÙŠÙ„' : 'Ø¥ÙŠÙ‚Ø§Ù'}`;

                if (soundEnabled && gameState.gameStarted && !gameState.gameOver && !gameState.paused) {
                    startThrusterSound();
                    startBackgroundMelody();
                } else {
                    stopThrusterSound();
                    stopBackgroundMelody();
                }
            });
            
            window.addEventListener('blur', () => {
                if (gameState.gameStarted && !gameState.gameOver && !gameState.isQuestionActive) {
                    gameState.paused = true;
                    stopThrusterSound();
                    stopBackgroundMelody();
                }
            });
            
            // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø£Ø­Ø¯Ø§Ø« Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            window.addEventListener('keydown', (e) => {
                // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø© ÙÙ‚Ø·
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'ArrowDown' || e.key === 's') {
                    e.preventDefault();
                    gameState.keys[e.key] = true;
                }
            });
            
            window.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'ArrowDown' || e.key === 's') {
                    gameState.keys[e.key] = false;
                }
            });
            
            resizeCanvas();
            createStars();
            
            // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ gameLoop Ù„Ø¨Ø¯Ø¡ Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
            requestAnimationFrame(gameLoop);
            
            // Ù„Ø§ ØªØ¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ØŒ Ø¨Ù„ Ø§Ù†ØªØ¸Ø± Ø¶ØºØ· Ø²Ø± "Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©"
        });
    </script>
</body>
</html>

