<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>لعبة تدمير النفايات بالليزر - نفايات شريرة</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Cairo', sans-serif;
        }

        /* تحديث لون الخلفية لمظهر النهار */
        body, html {
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #B0E0E6);
            color: #1a1a2e;
            height: 100%;
            width: 100%;
            cursor: grab;
        }

        body.dragging, html.dragging {
            cursor: grabbing;
        }

        /* منع التكبير باللمس */
        body {
            touch-action: none;
        }

        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            z-index: 300;
        }

        .start-screen-content {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            animation: fadeInScale 0.7s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }

        .start-screen h1 {
            color: #00b4d8;
            font-size: 40px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #00b4d8;
        }

        .start-screen h2 {
            color: #90e0ef;
            margin-top: 30px;
            margin-bottom: 10px;
            border-bottom: 2px solid #00b4d8;
            padding-bottom: 5px;
            font-size: 24px;
        }

        .start-screen p {
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: center;
        }

        .start-btn {
            background: linear-gradient(to right, #00b4d8, #0077b6);
            color: white;
            padding: 15px 35px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            margin: 20px 0;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5);
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
            align-items: center;
            justify-content: center;
        }

        .info-panel {
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            opacity: 0.95;
            display: none;
        }

        .scene-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            height: 100%;
            width: 100%;
        }

        #gameScene {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 10px;
            color: white;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #00b4d8;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.8;
        }

        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            max-width: 400px;
            display: none;
            color: white;
        }

        .title {
            font-size: 24px;
            margin-bottom: 10px;
            color: #00b4d8;
            text-align: center;
        }

        .subtitle {
            font-size: 16px;
            opacity: 0.8;
            text-align: center;
        }

        .game-ui {
            position: absolute;
            bottom: 200px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
        }

        .ui-button {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .charge-btn {
            background: linear-gradient(to bottom, #ff0000, #ff5500);
            box-shadow: 0 4-box-shadow: 0 4px 10px rgba(255, 0, 0, 0.5);
            transition: transform 0.1s ease, box-shadow 0.3s ease;
        }

        .ui-button:active {
            background: rgba(0, 180, 216, 0.5);
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .score-display {
            position: absolute;
            top: 50px;
            right: 20px;
            font-size: 24px;
            color: #005080;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }

        .coins-display {
            position: absolute;
            top: 85px;
            right: 20px;
            font-size: 20px;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }

        /* شريط صحة اللاعب الجديد */
        .health-indicator {
            position: absolute;
            top: 120px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            display: none;
            z-index: 100;
        }

        .health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #00FF00, #FFFF00, #FF0000);
            transition: width 0.3s ease;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            display: none;
            color: white;
        }

        .restart-btn {
            background: linear-gradient(to right, #00b4d8, #0077b6);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .movement-controls {
            position: absolute;
            bottom: 200px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .movement-row {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .movement-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .movement-btn:active {
            background: rgba(0, 180, 216, 0.5);
            transform: scale(0.95);
        }

        .coin-animation {
            position: absolute;
            font-size: 24px;
            color: #FFD700;
            font-weight: bold;
            animation: coinFloat 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 90;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .laser-sight {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: transparent;
            border: 3px solid #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.9);
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            pointer-events: none;
            z-index: 90;
            display: none;
        }

        .round-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 18px;
            color: #00b4d8;
            font-weight: bold;
            z-index: 100;
            display: none;
        }

        .next-round-btn {
            position: absolute;
            bottom: 200px;
            right: 20px;
            background: linear-gradient(to right, #00b4d8, #0077b6);
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 100;
            display: none;
        }

        .next-round-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .next-round-btn:disabled {
            background: linear-gradient(to right, #555, #777);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .tree-stats-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 18px;
            color: white;
            z-index: 100;
            display: none;
        }

        .tree-stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tree-stat-item .stat-value {
            font-size: 20px;
            color: #00b4d8;
            font-weight: bold;
        }

        .charge-indicator {
            position: absolute;
            bottom: 180px;
            right: 120px;
            width: 100px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            display: none;
            z-index: 100;
        }

        .charge-bar {
            width: 0;
            height: 100%;
            background: linear-gradient(to right, #00b4d8, #ff0000);
            transition: width 0.1s linear;
        }

        .world-boundary {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            color: #ff9900;
            z-index: 100;
            display: none;
            animation: boundaryPulse 2s infinite;
        }

        .round-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .round-transition.active {
            opacity: 1;
            pointer-events: all;
        }

        .round-message {
            background: rgba(255, 255, 255, 0.9);
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            font-size: 32px;
            color: #00b4d8;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .aggressive-warning {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 16px;
            color: white;
            z-index: 100;
            display: none;
            animation: warningPulse 1s infinite;
        }

        /* تنسيقات جديدة لنافذة السؤال */
        .question-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 250;
            display: none;
            color: white;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .question-panel h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .question-panel p {
            font-size: 20px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .options-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .option-btn {
            background: linear-gradient(to right, #00b4d8, #0077b6);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .option-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        /* تنسيقات صندوق الصحة الجديد */
        .health-box-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
        }

        .health-box-icon {
            font-size: 50px;
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            animation: pulse 1.5s infinite ease-in-out;
        }

        .health-box-label {
            position: absolute;
            bottom: -30px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: #00BFFF;
            text-shadow: 0 0 5px rgba(0, 191, 255, 0.5);
            font-weight: bold;
        }

        @keyframes coinFloat {
            0% {
                opacity: 1;
                transform: translate(0, 0);
            }

            100% {
                opacity: 0;
                transform: translate(0, -100px);
            }
        }

        @keyframes fadeInScale {
            0% {
                opacity: 0;
                transform: scale(0.95);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes boundaryPulse {
            0% {
                box-shadow: 0 0 5px rgba(255, 153, 0, 0.5);
            }

            50% {
                box-shadow: 0 0 15px rgba(255, 153, 0, 0.8);
            }

            100% {
                box-shadow: 0 0 5px rgba(255, 153, 0, 0.5);
            }
        }

        @keyframes warningPulse {
            0% {
                opacity: 0.7;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.7;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        .hidden {
            display: none;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }

            .info-panel {
                width: 100%;
                max-height: 45vh;
            }

            .overlay {
                font-size: 14px;
                max-width: 80%;
                left: 15px;
                top: 15px;
            }

            .overlay .title {
                font-size: 18px;
            }

            .overlay .subtitle {
                font-size: 14px;
            }

            .game-ui {
                bottom: 170px;
                right: 10px;
            }

            .ui-button {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }

            .movement-controls {
                bottom: 170px;
                left: 10px;
            }

            .movement-btn {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            .score-display {
                bottom: 150px;
                right: 10px;
                font-size: 16px;
            }

            .coins-display {
                bottom: 180px;
                right: 10px;
                font-size: 16px;
            }

            .health-indicator {
                top: 150px;
                right: 10px;
                width: 150px;
            }

            .start-screen-content {
                padding: 20px;
            }

            .start-screen h1 {
                font-size: 30px;
            }

            .start-screen h2 {
                font-size: 20px;
            }

            .start-screen p {
                font-size: 16px;
            }

            .start-btn {
                font-size: 18px;
                padding: 12px 25px;
            }

            .round-indicator {
                font-size: 16px;
                padding: 8px 15px;
            }

            .next-round-btn {
                bottom: 170px;
                right: 10px;
                font-size: 14px;
                padding: 10px 15px;
            }

            .charge-indicator {
                bottom: 150px;
                right: 90px;
                width: 80px;
            }

            .world-boundary {
                font-size: 12px;
                padding: 6px 10px;
                top: 5px;
                right: 5px;
            }

            .round-message {
                font-size: 24px;
                padding: 20px 30px;
            }
        }

        /* تنسيقات الرسالة الجديدة */
        .answer-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            color: white;
            padding: 30px;
            border-radius: 20px;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            z-index: 300;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: popIn 0.5s ease-out;
            border: 5px solid #fff;
        }

        .answer-message.incorrect {
            background: linear-gradient(45deg, #F44336, #FF9800);
        }

        @keyframes popIn {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="start-screen-content">
            <h1>لعبة تدمير النفايات بالليزر</h1>
            <h2>عن اللعبة</h2>
            <p>تهاجم النفايات الشريرة الحديقة المدرسية وتحاول تدمير الأشجار. استخدم أشعة الليزر لتدميرها قبل أن تسبب الضرر!</p>
            <button class="start-btn" id="startGameBtn">ابدأ اللعبة</button>
            <h2>كيفية اللعب</h2>
            <p>1. استخدم أزرار الحركة لتحريك مؤشر الليزر</p>
            <p>2. اضغط لفترة قصيرة لإطلاق ليزر عادي، أو اضغط مطولًا ثم اترك لإطلاق ليزر خارق!</p>
            <p>3. النقاط تزيد مع كل نفاية تدمرها</p>
            <p>4. النقود تسقط من النفايات المدمرة</p>
            <p>5. احمِ الأشجار من الهجوم (إذا التصقت نفاية بشجرة، تدمر الشجرة)</p>
            <p>6. اللعبة تعتمد على جولات - اضغط على "الجولة التالية" لاستدعاء مجموعة جديدة من النفايات</p>
            <p>7. <strong>جديد:</strong> حركة كاميرا سلسة مثل ماين كرافت - اسحب الفأرة على الشاشة أو اسحب إصبعك على الموبايل لتدوير الكاميرا والتصويب بحرية.</p>
            <p>8. <strong>تحكم متعدد باللمس:</strong> استخدم إصبعين في نفس الوقت للتحكم بالحركة وتدوير الكاميرا، أو للتحرك وإطلاق النار!</p>
            <p>9. <strong>تحسين جديد:</strong> النفايات تتجنب البيوت وتلتف حولها لتصل إلى هدفها!</p>
            <p>10. <strong>تحذير:</strong> النفايات العدوانية الجديدة ستطاردك إذا اقتربت منها!</p>
            <p>11. <strong>تحديث:</strong> النفايات العدوانية الآن تطلق النار عليك! كن حذراً!</p>
        </div>
    </div>

    <div class="laser-sight" id="laserSight"></div>
    <div class="world-boundary" id="worldBoundaryWarning">أنت تقترب من حدود العالم!</div>
    <div class="aggressive-warning" id="aggressiveWarning">نفايات شريرة تقترب منك! احذر!</div>
    <div class="round-transition" id="roundTransition">
        <div class="round-message" id="roundMessage">الجولة 1</div>
    </div>

    <div class="container">
        <div class="info-panel" id="infoPanel">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="levelDisplay">1</div>
                    <div class="stat-label">المستوى</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="wasteCount">0</div>
                    <div class="stat-label">النفايات</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="coinsCount">0</div>
                    <div class="stat-label">النقود</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="aggressiveCount">0</div>
                    <div class="stat-label">العدوانية</div>
                </div>
            </div>
        </div>
        <div class="scene-container">
            <canvas id="gameScene"></canvas>
            <div class="score-display" id="scoreDisplay">النقاط: 0</div>
            <div class="coins-display" id="coinsDisplay">النقود: 0</div>
            <div class="health-indicator" id="healthIndicator">
                <div class="health-bar" id="healthBar"></div>
            </div>
            <div class="round-indicator" id="roundIndicator">الجولة: 1</div>
            <button class="next-round-btn" id="nextRoundBtn">الجولة التالية</button>
            <div class="tree-stats-display" id="treeStatsDisplay">
                <div class="tree-stat-item">
                    <div>إجمالي الأشجار:</div>
                    <div class="stat-value" id="totalTreesDisplay">0</div>
                </div>
                <div class="tree-stat-item">
                    <div>الأشجار المتبقية:</div>
                    <div class="stat-value" id="remainingTreesDisplay">0</div>
                </div>
            </div>
            <div class="movement-controls" id="movementControls">
                <div class="movement-row">
                    <div class="movement-btn" id="upBtn">↑</div>
                </div>
                <div class="movement-row">
                    <div class="movement-btn" id="leftBtn">←</div>
                    <div class="movement-btn" id="downBtn">↓</div>
                    <div class="movement-btn" id="rightBtn">→</div>
                </div>
            </div>
            <div class="game-ui">
                <div class="ui-button" id="shootBtn">♻️</div>
                <div class="charge-indicator" id="chargeIndicator">
                    <div class="charge-bar" id="chargeBar"></div>
                </div>
            </div>
            <div class="game-over" id="gameOverPanel">
                <h2>انتهت اللعبة!</h2>
                <p>النقاط النهائية: <span id="finalScore">0</span></p>
                <p>النقود المجموعة: <span id="finalCoins">0</span></p>
                <button class="restart-btn" id="restartBtn">إعادة اللعب</button>
            </div>
        </div>
    </div>
    <div class="question-panel" id="questionPanel">
        <h2>سؤال رياضي!</h2>
        <p id="questionText"></p>
        <div class="options-container" id="optionsContainer">
        </div>
    </div>
    <script>
        // بداية إضافة الكود الصوتي 🎶
        // ---------------------------
        // Audio context for sound generation
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // The core function to generate and play sounds
        function playSound(frequency, type = 'sine', duration = 0.1, volume = 0.3) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Set sound properties
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;

            // Play the sound
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Sound effect for monster attack
        function playMonsterAttackSound() {
            const now = audioContext.currentTime;
            const duration = 0.3;
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            const gainNode = audioContext.createGain();
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.5, now);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            source.start(now);
        }

        // Sound effect for a gunshot (normal laser)
        function playShotSound() {
            const now = audioContext.currentTime;
            const duration = 0.2;
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 1;
            filter.frequency.setValueAtTime(4000, now);
            filter.frequency.linearRampToValueAtTime(500, now + duration);
            const gainNode = audioContext.createGain();
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.3, now);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            source.start(now);
            source.stop(now + duration);
        }

        // Sound effect for a powerful charged shot
        function playChargedShotSound() {
            const now = audioContext.currentTime;
            const duration = 0.3;
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 5; // Higher Q for a sharper, more focused sound
            filter.frequency.setValueAtTime(8000, now); // Higher initial frequency
            filter.frequency.linearRampToValueAtTime(200, now + duration);
            const gainNode = audioContext.createGain();
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.8, now); // Higher volume
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            source.start(now);
            source.stop(now + duration);
        }

        // Sound effect for monster explosion
        function playMonsterExplosionSound() {
            const now = audioContext.currentTime;
            const duration = 0.5;
            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = 'sawtooth';
            oscillator1.frequency.value = 60;
            gainNode1.gain.setValueAtTime(0.5, now);
            gainNode1.gain.exponentialRampToValueAtTime(0.001, now + duration);
            oscillator1.start(now);
            oscillator1.stop(now + duration);

            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = 'square';
            oscillator2.frequency.value = 1000;
            gainNode2.gain.setValueAtTime(0.3, now);
            gainNode2.gain.exponentialRampToValueAtTime(0.001, now + duration);
            oscillator2.start(now);
            oscillator2.stop(now + duration);
        }

        // Sound effect for collecting a coin
        function playCoinSound() {
            playSound(880, 'triangle', 0.1, 0.2);
        }

        // Sound effect for reaching a box
        function playBoxSound() {
            playSound(440, 'sine', 0.1, 0.3);
            setTimeout(() => playSound(660, 'sine', 0.1, 0.3), 100);
        }

        // Sound effect for getting a gift
        function playGiftSound() {
            playSound(523, 'sine', 0.1, 0.3);
            setTimeout(() => playSound(659, 'sine', 0.1, 0.3), 100);
            setTimeout(() => playSound(784, 'sine', 0.1, 0.3), 200);
        }
        // نهاية إضافة الكود الصوتي 🎶
        // ---------------------------

        // تهيئة مشهد Three.js
        const scene = new THREE.Scene();
        // تغيير لون الخلفية إلى الأزرق الفاتح
        scene.background = new THREE.Color(0x87CEEB);
        // تغيير لون الضباب إلى الأزرق الفاتح
        scene.fog = new THREE.Fog(0xADD8E6, 50, 800);

        const canvas = document.getElementById('gameScene');
        const renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true
        });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);

        // إنشاء مجموعة للاعب (تحتوي على الكاميرا)
        const player = new THREE.Group();
        scene.add(player);

        // إعداد الكاميرا بمنظور الشخص الأول
        const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.8, 0); // ارتفاع الكاميرا بالنسبة للاعب
        player.add(camera); // إضافة الكاميرا كمكوّن فرعي للاعب

        // الإضاءة
        // زيادة شدة الإضاءة المحيطة لتناسب مظهر النهار
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        // تغيير لون ضوء الشمس إلى الأبيض لإضفاء طابع النهار
        const sunLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
        sunLight.position.set(100, 200, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048; // زيادة دقة الظلال
        sunLight.shadow.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500; // زيادة نطاق الظل ليناسب الخريطة الأكبر
        scene.add(sunLight);

        // إنشاء أرضية
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100); // زيادة حجم الأرضية
        // تغيير لون الأرضية إلى أخضر زاهي يناسب النهار
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x4CAF50,
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // حدود العالم لمنع خروج اللاعب
        const worldBounds = {
            minX: -450,
            maxX: 450,
            minZ: -450,
            maxZ: 450,
            buffer: 20 // مسافة تخزين للتحذير قبل الوصول للحدود
        };

        // إنشاء حدود مرئية للعالم
        function createWorldBoundsVisual() {
            const boundsGeometry = new THREE.BoxGeometry(
                worldBounds.maxX - worldBounds.minX,
                1,
                worldBounds.maxZ - worldBounds.minZ
            );
            const boundsMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true,
                transparent: true,
                opacity: 0.1
            });
            const bounds = new THREE.Mesh(boundsGeometry, boundsMaterial);
            bounds.position.set(
                (worldBounds.maxX + worldBounds.minX) / 2,
                -0.5,
                (worldBounds.maxZ + worldBounds.minZ) / 2
            );
            scene.add(bounds);
        }

        // التحقق من حدود العالم
        function checkWorldBounds(position) {
            const warningElement = document.getElementById('worldBoundaryWarning');
            // التحقق من الحدود مع منطقة تخزين للتحذير
            if (position.x < worldBounds.minX + worldBounds.buffer || position.x > worldBounds.maxX - worldBounds.buffer || position.z < worldBounds.minZ + worldBounds.buffer || position.z > worldBounds.maxZ - worldBounds.buffer) {
                warningElement.style.display = 'block';
            } else {
                warningElement.style.display = 'none';
            }
            // منع الخروج من الحدود تماماً
            if (position.x < worldBounds.minX) return new THREE.Vector3(worldBounds.minX, position.y, position.z);
            if (position.x > worldBounds.maxX) return new THREE.Vector3(worldBounds.maxX, position.y, position.z);
            if (position.z < worldBounds.minZ) return new THREE.Vector3(position.x, position.y, worldBounds.minZ);
            if (position.z > worldBounds.maxZ) return new THREE.Vector3(position.x, position.y, worldBounds.maxZ);
            return position;
        }

        // إنشاء أشجار
        function createTree(x, z) {
            const treeGroup = new THREE.Group();
            // الجذع
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 6, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);
            // الأوراق
            const leavesGeometry = new THREE.ConeGeometry(3, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({
                color: 0x006400,
                roughness: 0.5
            });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 10;
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            treeGroup.add(leaves);
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return treeGroup;
        }

        // إنشاء بيت غير قابل للاختراق
        function createHouse(x, z, width, height, depth, color) {
            const houseGroup = new THREE.Group(); // استخدام مجموعة لتجميع البيت والنوافذ
            // هيكل البيت
            const houseGeometry = new THREE.BoxGeometry(width, height, depth);
            const houseMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.8,
                metalness: 0.1
            });
            const house = new THREE.Mesh(houseGeometry, houseMaterial);
            house.position.set(x, height / 2, z);
            house.castShadow = true;
            house.receiveShadow = true;
            houseGroup.add(house);

            // السقف
            const roofGeometry = new THREE.ConeGeometry(width * 0.7, width * 0.7, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B0000, // لون أحمر داكن للسقف
                roughness: 0.8,
                metalness: 0.1
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(x, height + width * 0.35, z);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            roof.receiveShadow = true;
            houseGroup.add(roof);

            // إضافة نوافذ
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x2C3E50, // لون داكن للنوافذ
                roughness: 0.5,
                metalness: 0.2
            });
            const windowWidth = width * 0.2;
            const windowHeight = height * 0.2;
            const windowDepth = depth * 0.05;

            // نافذة أمامية
            const frontWindow1 = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
            frontWindow1.position.set(x - width * 0.25, height / 2, z + depth / 2 + windowDepth / 2);
            houseGroup.add(frontWindow1);
            const frontWindow2 = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
            frontWindow2.position.set(x + width * 0.25, height / 2, z + depth / 2 + windowDepth / 2);
            houseGroup.add(frontWindow2);

            // نافذة خلفية
            const backWindow1 = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
            backWindow1.position.set(x - width * 0.25, height / 2, z - depth / 2 - windowDepth / 2);
            houseGroup.add(backWindow1);
            const backWindow2 = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
            backWindow2.position.set(x + width * 0.25, height / 2, z - depth / 2 - windowDepth / 2);
            houseGroup.add(backWindow2);

            // نافذة جانبية (يمين)
            const rightWindow1 = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
            rightWindow1.position.set(x + width / 2 + windowDepth / 2, height / 2, z - depth * 0.25);
            houseGroup.add(rightWindow1);
            const rightWindow2 = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
            rightWindow2.position.set(x + width / 2 + windowDepth / 2, height / 2, z + depth * 0.25);
            houseGroup.add(rightWindow2);

            // نافذة جانبية (يسار)
            const leftWindow1 = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
            leftWindow1.position.set(x - width / 2 - windowDepth / 2, height / 2, z - depth * 0.25);
            houseGroup.add(leftWindow1);
            const leftWindow2 = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
            leftWindow2.position.set(x - width / 2 - windowDepth / 2, height / 2, z + depth * 0.25);
            houseGroup.add(leftWindow2);

            scene.add(houseGroup);
            return houseGroup;
        }

        // إنشاء نفايات شريرة
        function createEvilWaste(x, z, type) {
            const wasteGroup = new THREE.Group();
            let wasteGeometry, wasteMaterial;
            let health, value;

            // ألوان النفايات العدوانية الجديدة
            const aggressiveColors = [
                0x00FF00, // أخضر
                0x00BFFF, // أزرق فاتح
                0x8A2BE2, // أرجواني
                0xFF4500, // برتقالي
                0xFFFF00 // أصفر
            ];

            // حساب المعاملات حسب الجولة الحالية
            const sizeFactor = 1 + (round - 1) * 0.5; // يزيد الحجم بمقدار 0.5 في كل جولة
            const healthFactor = 1 + (round - 1) * 0.8; // تزيد الصحة بمقدار 80% في كل جولة

            if (type === 'giant') {
                wasteGeometry = new THREE.IcosahedronGeometry(4, 0);
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: 0x990000,
                    roughness: 0.6,
                    metalness: 0.2
                });
                health = 500;
                value = 50;
            } else if (type === 'plastic') {
                wasteGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff9900,
                    roughness: 0.7
                });
                health = 100;
                value = 5;
            } else if (type === 'paper') {
                wasteGeometry = new THREE.BoxGeometry(2, 2, 2);
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffff00,
                    roughness: 0.8
                });
                health = 80;
                value = 10;
            } else if (type === 'organic') {
                wasteGeometry = new THREE.ConeGeometry(1.5, 3, 8);
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: 0xcc0000,
                    roughness: 0.6
                });
                health = 120;
                value = 15;
            } else if (type === 'aggressive') {
                // النفايات العدوانية - جديدة وسريعة
                // **تعديل: تطبيق معامل الحجم**
                wasteGeometry = new THREE.TetrahedronGeometry(2 * sizeFactor, 0);
                const randomColor = aggressiveColors[Math.floor(Math.random() * aggressiveColors.length)];
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: randomColor,
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: randomColor,
                    emissiveIntensity: 0.5
                });
                // **تعديل: تطبيق معامل الصحة**
                health = 150 * healthFactor;
                value = 25;
            }

            const waste = new THREE.Mesh(wasteGeometry, wasteMaterial);
            waste.castShadow = true;
            waste.receiveShadow = true;
            wasteGroup.add(waste);

            // عيون شريرة
            const eyeGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff
            });
            const eyeScale = type === 'giant' || type === 'aggressive' ? 1.5 : 1;
            const eyeOffset = type === 'giant' || type === 'aggressive' ? 2 : 0.5;
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.scale.set(eyeScale, eyeScale, eyeScale);
            leftEye.position.set(-eyeOffset, 0.3 * eyeScale, type === 'plastic' ? 1.4 : 1.2 * eyeScale);
            wasteGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.scale.set(eyeScale, eyeScale, eyeScale);
            rightEye.position.set(eyeOffset, 0.3 * eyeScale, type === 'plastic' ? 1.4 : 1.2 * eyeScale);
            wasteGroup.add(rightEye);

            // بؤبؤ العين
            const pupilGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const pupilMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            const pupilScale = type === 'giant' || type === 'aggressive' ? 1.5 : 1;
            const pupilOffset = type === 'giant' || type === 'aggressive' ? 2 : 0.5;
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.scale.set(pupilScale, pupilScale, pupilScale);
            leftPupil.position.set(-pupilOffset, 0.3 * pupilScale, (type === 'plastic' ? 1.4 : 1.2) * pupilScale + 0.3);
            wasteGroup.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.scale.set(pupilScale, pupilScale, pupilScale);
            rightPupil.position.set(pupilOffset, 0.3 * pupilScale, (type === 'plastic' ? 1.4 : 1.2) * pupilScale + 0.3);
            wasteGroup.add(rightPupil);

            // فم شرير
            const mouthGeometry = new THREE.TorusGeometry(0.8, 0.15, 8, 18, Math.PI);
            const mouthMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            const mouthScale = type === 'giant' || type === 'aggressive' ? 2 : 1;
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.scale.set(mouthScale, mouthScale, mouthScale);
            mouth.position.set(0, -0.5 * mouthScale, (type === 'plastic' ? 1.4 : 1.2) * mouthScale);
            mouth.rotation.x = Math.PI / 2;
            wasteGroup.add(mouth);

            // تأثير إضافي للنفايات العدوانية
            if (type === 'aggressive') {
                // تأثير توهج
                const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: wasteMaterial.color, // استخدام نفس لون المادة
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                wasteGroup.add(glow);

                // تأثير جسيمات حول النفايات العدوانية
                const particleCount = 8;
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: aggressiveColors[Math.floor(Math.random() * aggressiveColors.length)],
                        transparent: true,
                        opacity: 0.7
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 3;
                    particle.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * 0.5,
                        Math.sin(angle) * radius
                    );
                    particle.userData = {
                        angle: angle,
                        speed: 0.05
                    };
                    wasteGroup.add(particle);
                }
            }

            wasteGroup.position.set(x, type === 'giant' ? 4 : 2, z);

            // إعداد خصائص النفايات العدوانية
            const isAggressive = type === 'aggressive';
            // **التعديل هنا:** تم تخفيض سرعة النفايات بشكل طفيف
            // كانت السرعة للنفايات العادية (Math.random() * 0.05 + 0.02)
            // الآن أصبحت (Math.random() * 0.04 + 0.01)
            // وكانت السرعة للنفايات العدوانية 0.15
            // الآن أصبحت 0.12
            const baseSpeed = isAggressive ? 0.12 : (Math.random() * 0.04 + 0.01);
            wasteGroup.userData = {
                type,
                health,
                maxHealth: health,
                speed: baseSpeed,
                value,
                targetTree: null,
                isAggressive: isAggressive,
                isChasing: false,
                detectionRange: isAggressive ? 30 : 0,
                attackRange: isAggressive ? 5 : 0,
                attackDamage: isAggressive ? 10 : 0,
                lastAttackTime: 0
            };

            if (type === 'aggressive') {
                let minDistance = Infinity;
                let closestTree = null;
                trees.forEach(tree => {
                    const treePos = new THREE.Vector3();
                    tree.getWorldPosition(treePos);
                    const distance = wasteGroup.position.distanceTo(treePos);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestTree = tree;
                    }
                });
                wasteGroup.userData.targetTree = closestTree;
            }
            scene.add(wasteGroup);
            return wasteGroup;
        }

        // **دالة جديدة: إنشاء طلقة نفايات**
        function createWasteProjectile(startPos) {
            const projectileGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                blending: THREE.AdditiveBlending
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(startPos);
            projectile.userData = {
                speed: 1.0,
                damage: 10,
                createdAt: Date.now()
            };
            scene.add(projectile);
            return projectile;
        }

        // إنشاء عملة (نسخة معدلة)
        function createCoin(x, z, value) {
            const coinGroup = new THREE.Group();
            // العملة
            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
            // استخدام MeshBasicMaterial بدلاً من MeshStandardMaterial
            const coinMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700, // لون ذهبي
                transparent: true,
                opacity: 1
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.x = Math.PI / 2;
            coinGroup.add(coin);

            // إضافة هالة ذهبية حول العملة
            const haloGeometry = new THREE.RingGeometry(0.6, 0.8, 32);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.rotation.x = -Math.PI / 2;
            halo.position.y = 0.05;
            coinGroup.add(halo);

            // تأثير بريق (بديل عن الضوء الذي قد يسبب مشاكل)
            const sparkleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const sparkleMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8
            });

            // إضافة عدة بريقات حول العملة
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                sparkle.position.set(
                    Math.cos(angle) * 0.7,
                    0.1,
                    Math.sin(angle) * 0.7
                );
                sparkle.userData = {
                    angle: angle
                };
                coinGroup.add(sparkle);
            }

            coinGroup.position.set(x, 1, z);
            coinGroup.userData = {
                value,
                spinSpeed: 0.02,
                sparkleSpeed: 0.05
            };
            scene.add(coinGroup);
            return coinGroup;
        }

        // إنشاء شعاع ليزر (حجم أكبر)
        function createLaserBeam(start, end, isCharged) {
            const distance = start.distanceTo(end);
            // زيادة حجم الشعاع حسب نوع الطلقة
            const beamRadius = isCharged ? 1.5 : 0.8;
            const beamGeometry = new THREE.CylinderGeometry(beamRadius, beamRadius, distance, 8);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: isCharged ? 0x00FFFF : 0xff0000,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            const center = new THREE.Vector3().lerpVectors(start, end, 0.5);
            beam.position.copy(center);
            beam.lookAt(end);
            beam.rotation.x += Math.PI / 2;
            scene.add(beam);
            return {
                beam,
                createdAt: Date.now()
            };
        }

        // إنشاء تأثير انفجار عند الاصطدام
        function createExplosionEffect(position, isCharged) {
            const particles = [];
            const particleCount = isCharged ? 50 : 20;
            const colors = isCharged ? [0x00FFFF, 0x00BFFF, 0x00F8FF] : [0xff0000, 0xff5500, 0xffff00];
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(isCharged ? 0.4 : 0.2, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 0.1 + 0.05;
                particle.userData = {
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 0.1,
                        Math.sin(angle) * speed
                    ),
                    createdAt: Date.now()
                };
                scene.add(particle);
                particles.push(particle);
            }
            return particles;
        }

        // تهيئة اللعبة
        const trees = [];
        const wastes = [];
        const laserBeams = [];
        const coins = [];
        const effects = [];
        const houses = []; // مصفوفة لتخزين البيوت
        const wasteProjectiles = []; // **جديد: طلقات النفايات**
        // متغيرات اللعبة
        let score = 0;
        let coinsCollected = 0;
        let level = 1;
        let round = 1;
        let gameOver = false;
        let gameStarted = false;
        let isRoundTransition = false;
        let playerHealth = 100; // **جديد: صحة اللاعب**
        const maxPlayerHealth = 100; // **جديد: أقصى صحة للاعب**
        // متغيرات إطلاق الليزر
        let isCharging = false;
        let chargeStartTime = 0;
        const maxChargeTime = 2000; // 2 ثانية للشحن الكامل
        const normalShotCooldown = 200; // وقت التبريد للطلقة العادية
        let lastShotTime = 0;
        // متغيرات حركة اللاعب المحسنة
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let playerSpeed = 5.0;
        // تحسينات الحركة: إضافة التسارع والتباطؤ
        let acceleration = 0.2;
        let deceleration = 0.9;
        let maxSpeed = 5.0;
        let velocity = new THREE.Vector3();
        // متغيرات دوران الكاميرا المحسنة
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let previousTouchX = 0;
        let previousTouchY = 0;
        const mouseSensitivity = 0.002;
        const touchSensitivity = 0.003;
        // --- إضافة متغيرات التحكم باللمس المتعدد ---
        let cameraTouchId = null;
        const buttonTouchIds = new Map();
        // ------------------------------------------
        // متغيرات إحصائيات الأشجار
        let totalTrees = 0;

        // عناصر واجهة المستخدم
        const startScreen = document.getElementById('startScreen');
        const startGameBtn = document.getElementById('startGameBtn');
        const infoPanel = document.getElementById('infoPanel');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const coinsDisplay = document.getElementById('coinsDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const wasteCount = document.getElementById('wasteCount');
        const coinsCount = document.getElementById('coinsCount');
        const aggressiveCount = document.getElementById('aggressiveCount');
        const gameOverPanel = document.getElementById('gameOverPanel');
        const finalScore = document.getElementById('finalScore');
        finalScore.textContent = "0";
        const finalCoins = document.getElementById('finalCoins');
        finalCoins.textContent = "0";
        const restartBtn = document.getElementById('restartBtn');
        const shootBtn = document.getElementById('shootBtn');
        const laserSight = document.getElementById('laserSight');
        const movementControls = document.getElementById('movementControls');
        const roundIndicator = document.getElementById('roundIndicator');
        const nextRoundBtn = document.getElementById('nextRoundBtn');
        const totalTreesDisplay = document.getElementById('totalTreesDisplay');
        const remainingTreesDisplay = document.getElementById('remainingTreesDisplay');
        const treeStatsDisplay = document.getElementById('treeStatsDisplay');
        const chargeIndicator = document.getElementById('chargeIndicator');
        const chargeBar = document.getElementById('chargeBar');
        const worldBoundaryWarning = document.getElementById('worldBoundaryWarning');
        const roundTransition = document.getElementById('roundTransition');
        const roundMessage = document.getElementById('roundMessage');
        const aggressiveWarning = document.getElementById('aggressiveWarning');
        const healthIndicator = document.getElementById('healthIndicator'); // **جديد**
        const healthBar = document.getElementById('healthBar'); // **جديد**

        // أزرار الحركة
        const upBtn = document.getElementById('upBtn');
        const downBtn = document.getElementById('downBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');

        // متغيرات جديدة للأسئلة
        const questionPanel = document.getElementById('questionPanel');
        const questionText = document.getElementById('questionText');
        const optionsContainer = document.getElementById('optionsContainer');
        let isGameFrozen = false;
        let gameLoopId;

        // مصفوفة لتخزين صناديق الكنز
        const treasureBoxes = [];

        // إنشاء الأشجار للجولة الحالية
        function spawnNewTrees() {
            // **التعديل هنا:**
            // عدد الأشجار يبدأ من 20 في الجولة الأولى ثم يتناقص بمقدار 2 في كل جولة
            const initialTrees = 20;
            const treeDecrease = 2;
            const currentTreeCount = Math.max(5, initialTrees - (round - 1) * treeDecrease); // لا يقل عن 5 أشجار
            totalTrees = currentTreeCount;
            for (let i = 0; i < currentTreeCount; i++) {
                // توسيع نطاق ظهور الأشجار ليناسب الخريطة الأكبر
                const treeX = Math.random() * 900 - 450;
                const treeZ = Math.random() * 900 - 450;
                trees.push(createTree(treeX, treeZ));
            }
        }

        // إنشاء نفايات للجولة الحالية
        function spawnWavesForRound() {
            // **التعديل هنا:**
            // عدد النفايات يبدأ من 10 ويزيد بمقدار 5 كل جولة
            const currentWasteCount = 10 + (round - 1) * 5;
            for (let i = 0; i < currentWasteCount; i++) {
                let type;
                // **تم التعديل**: دائماً نختار النوع 'aggressive'
                type = 'aggressive';
                // توسيع نطاق ظهور النفايات ليناسب الخريطة الأكبر
                const wasteX = Math.random() * 900 - 450;
                const wasteZ = Math.random() * 900 - 450;
                wastes.push(createEvilWaste(wasteX, wasteZ, type));
            }
            // **التغيير هنا:** زيادة عدد صناديق الكنز في كل جولة
            const treasureBoxCount = 5 + round * 2; // يبدأ بـ 7 صناديق ويزيد 2 في كل جولة
            for (let i = 0; i < treasureBoxCount; i++) {
                const boxX = Math.random() * 800 - 400;
                const boxZ = Math.random() * 800 - 400;
                treasureBoxes.push(createHealthBox(boxX, boxZ));
            }
            updateUI();
        }

        // إنشاء بيت في أماكن ثابتة على الخريطة
        function spawnHouses() {
            const houseColors = [0x4B371C, 0xA0522D, 0xD2B48C, 0xF5F5DC, 0xCD5C5C, 0x87CEFA];
            const houseCount = 15; // زيادة عدد البيوت
            for (let i = 0; i < houseCount; i++) {
                const color = houseColors[Math.floor(Math.random() * houseColors.length)];
                const houseX = Math.random() * 800 - 400;
                const houseZ = Math.random() * 800 - 400;
                houses.push(createHouse(houseX, houseZ, 20, 10, 20, color));
            }
        }

        // دالة إنشاء صندوق الصحة (الكنز)
        function createHealthBox(x, z) {
            // إنشاء مجموعة لتجميع أجزاء الصندوق
            const boxGroup = new THREE.Group();
            // القاعدة (اللون الأزرق)
            const boxBaseGeometry = new THREE.BoxGeometry(2, 1.5, 2);
            const boxBaseMaterial = new THREE.MeshStandardMaterial({
                color: 0xD2B48C, // 🎨 لون بني فاتح
                roughness: 0.6,
                metalness: 0.3
            });
            const boxBase = new THREE.Mesh(boxBaseGeometry, boxBaseMaterial);
            boxBase.position.y = 0.75;
            boxBase.castShadow = true;
            boxBase.receiveShadow = true;
            boxGroup.add(boxBase);

            // الشريط الذهبي
            const goldBandGeometry = new THREE.BoxGeometry(2.2, 0.3, 2.2);
            const goldBandMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700, // لون ذهبي
                roughness: 0.2,
                metalness: 0.9
            });
            const goldBand = new THREE.Mesh(goldBandGeometry, goldBandMaterial);
            goldBand.position.y = 1.6;
            goldBand.castShadow = true;
            goldBand.receiveShadow = true;
            boxGroup.add(goldBand);

            // رمز الصليب الأحمر (رمز الصحة)
            const crossGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.2);
            const crossMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000 // لون أحمر
            });
            const crossHorizontal = new THREE.Mesh(crossGeometry, crossMaterial);
            crossHorizontal.position.set(0, 1.6, 1.1);
            const crossVertical = new THREE.Mesh(crossGeometry, crossMaterial);
            crossVertical.rotation.y = Math.PI / 2;
            crossVertical.position.set(0, 1.6, 1.1);
            boxGroup.add(crossHorizontal);
            boxGroup.add(crossVertical);

            // وضع مجموعة الصندوق في الموقع المحدد
            boxGroup.position.set(x, 0, z);
            scene.add(boxGroup);

            // إضافة خصائص إلى المجموعة لمتابعتها
            boxGroup.userData = {
                isHealthBox: true
            };
            return boxGroup;
        }

        function updateUI() {
            scoreDisplay.textContent = `النقاط: ${score}`;
            coinsDisplay.textContent = `النقود: ${coinsCollected}`;
            levelDisplay.textContent = level;
            wasteCount.textContent = wastes.length;
            coinsCount.textContent = coinsCollected;
            // حساب عدد النفايات العدوانية
            const aggressiveWastes = wastes.filter(w => w.userData.isAggressive).length;
            aggressiveCount.textContent = aggressiveWastes;
            roundIndicator.textContent = `الجولة: ${round}`;
            totalTreesDisplay.textContent = totalTrees;
            remainingTreesDisplay.textContent = trees.length;
            // **جديد: تحديث شريط الصحة**
            const healthPercentage = (playerHealth / maxPlayerHealth) * 100;
            healthBar.style.width = `${healthPercentage}%`;
            if (wastes.length === 0 && !gameOver && !isRoundTransition) {
                nextRoundBtn.style.display = 'block';
                nextRoundBtn.disabled = false;
            } else {
                nextRoundBtn.style.display = 'none';
            }
        }

        function nextRound() {
            isRoundTransition = true;
            nextRoundBtn.disabled = true;
            nextRoundBtn.style.display = 'none';
            roundMessage.textContent = `الجولة ${round + 1}`;
            roundTransition.classList.add('active');

            setTimeout(() => {
                round++;
                wastes.forEach(waste => scene.remove(waste));
                wastes.length = 0;
                coins.forEach(coin => scene.remove(coin));
                coins.length = 0;
                wasteProjectiles.forEach(p => scene.remove(p)); // **جديد**
                wasteProjectiles.length = 0; // **جديد**
                effects.forEach(effect => {
                    effect.particles.forEach(particle => scene.remove(particle));
                });
                effects.length = 0;

                // تحديث: إزالة جميع الأشجار الحالية وإعادة إنشائها لزيادة العدد
                trees.forEach(tree => scene.remove(tree));
                trees.length = 0;

                // إزالة الصناديق الحالية
                treasureBoxes.forEach(box => scene.remove(box));
                treasureBoxes.length = 0;

                spawnNewTrees(); // وظيفة جديدة لإنشاء الأشجار لكل جولة
                spawnWavesForRound();

                roundTransition.classList.remove('active');
                isRoundTransition = false;
                updateUI();
            }, 2000);
        }

        function moveWastes() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);
            let isPlayerInDanger = false;

            wastes.forEach(waste => {
                const wasteData = waste.userData;
                const wastePos = new THREE.Vector3();
                waste.getWorldPosition(wastePos);

                // تدوير الجسيمات حول النفايات العدوانية
                if (wasteData.isAggressive) {
                    waste.children.forEach(child => {
                        if (child.userData && child.userData.angle !== undefined) {
                            child.userData.angle += 0.05;
                            const radius = 3;
                            child.position.set(
                                Math.cos(child.userData.angle) * radius,
                                Math.sin(child.userData.angle) * 0.5,
                                Math.sin(child.userData.angle) * radius
                            );
                        }
                    });
                }

                // التحقق من مسافة اللاعب للنفايات العدوانية
                const distanceToPlayer = wastePos.distanceTo(playerPos);
                if (wasteData.isAggressive && distanceToPlayer < wasteData.detectionRange) {
                    wasteData.isChasing = true;
                    isPlayerInDanger = true;

                    // مطاردة اللاعب
                    const direction = new THREE.Vector3().subVectors(playerPos, wastePos).normalize();
                    const newPosition = wastePos.clone().add(direction.multiplyScalar(wasteData.speed * 1.5)); // زيادة السرعة عند المطاردة

                    let collisionDetected = false;
                    const wasteBoundingSphere = new THREE.Sphere(newPosition, 2);
                    for (const house of houses) {
                        house.children.forEach(child => {
                            const childBox = new THREE.Box3().setFromObject(child);
                            if (childBox.intersectsSphere(wasteBoundingSphere)) {
                                collisionDetected = true;
                            }
                        });
                        if (collisionDetected) break;
                    }
                    if (!collisionDetected) {
                        waste.position.x = newPosition.x;
                        waste.position.z = newPosition.z;
                    }
                    waste.lookAt(
                        waste.position.x + direction.x,
                        waste.position.y,
                        waste.position.z + direction.z
                    );

                    // **تعديل: الآن ستطلق النار بدلاً من تقليل الصحة مباشرة**
                    if (distanceToPlayer < wasteData.attackRange) {
                        if (Date.now() - wasteData.lastAttackTime > 1000) { // وقت تبريد 1 ثانية
                            const projectile = createWasteProjectile(wastePos);
                            const projDirection = new THREE.Vector3().subVectors(playerPos, wastePos).normalize();
                            projectile.userData.direction = projDirection;
                            projectile.userData.damage = wasteData.attackDamage; // ضرر الطلقة هو ضرر النفايات
                            wasteProjectiles.push(projectile);
                            wasteData.lastAttackTime = Date.now();
                            playMonsterAttackSound(); // تشغيل صوت هجوم الوحش
                        }
                    }

                } else if (!wasteData.targetTree || !trees.includes(wasteData.targetTree)) {
                    wasteData.isChasing = false;
                    let minDistance = Infinity;
                    let targetTree = null;
                    trees.forEach(tree => {
                        const treePos = new THREE.Vector3();
                        tree.getWorldPosition(treePos);
                        const distance = wastePos.distanceTo(treePos);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestTree = tree;
                        }
                    });

                    // للنفايات العدوانية، اختيار هدف عشوائي وليس الأقرب فقط
                    if (wasteData.isAggressive && trees.length > 0) {
                        wasteData.targetTree = trees[Math.floor(Math.random() * trees.length)];
                    } else {
                        wasteData.targetTree = targetTree;
                    }
                }

                if (wasteData.targetTree && !wasteData.isChasing) {
                    const treePos = new THREE.Vector3();
                    wasteData.targetTree.getWorldPosition(treePos);
                    const direction = new THREE.Vector3().subVectors(treePos, wastePos).normalize();
                    const newPosition = wastePos.clone().add(direction.multiplyScalar(wasteData.speed));

                    let collisionDetected = false;
                    const wasteBoundingSphere = new THREE.Sphere(newPosition, 2);
                    for (const house of houses) {
                        house.children.forEach(child => {
                            const childBox = new THREE.Box3().setFromObject(child);
                            if (childBox.intersectsSphere(wasteBoundingSphere)) {
                                collisionDetected = true;
                                // محاولة الالتفاف حول العائق
                                const avoidanceDirection = new THREE.Vector3(-direction.z, 0, direction.x);
                                newPosition.add(avoidanceDirection.multiplyScalar(wasteData.speed * 2));
                            }
                        });
                        if (collisionDetected) break;
                    }

                    if (!collisionDetected) {
                        waste.position.x = newPosition.x;
                        waste.position.z = newPosition.z;
                    } else {
                        wasteData.targetTree = null;
                    }
                    waste.lookAt(
                        waste.position.x + direction.x,
                        waste.position.y,
                        waste.position.z + direction.z
                    );

                    const distance = wastePos.distanceTo(treePos);
                    // هنا يتم تعديل الكود: النفايات لم تعد تختفي بعد اصطدامها بالأشجار
                    if (distance < 2.5) {
                        const targetTree = wasteData.targetTree;
                        if (targetTree) {
                            // نقوم بإزالة الشجرة فقط
                            scene.remove(targetTree);
                            const treeIndex = trees.indexOf(targetTree);
                            if (treeIndex > -1) {
                                trees.splice(treeIndex, 1);
                            }
                            // بدلاً من إزالة النفاية، نجعلها تبحث عن هدف جديد
                            wasteData.targetTree = null;
                        }
                    }
                }
            });

            // عرض تحذير إذا كان اللاعب في خطر
            if (isPlayerInDanger) {
                aggressiveWarning.style.display = 'block';
            } else {
                aggressiveWarning.style.display = 'none';
            }
        }

        // **دالة جديدة: تحديث طلقات النفايات واكتشاف الاصطدام باللاعب**
        function updateWasteProjectiles() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);
            for (let i = wasteProjectiles.length - 1; i >= 0; i--) {
                const projectile = wasteProjectiles[i];
                // تحريك الطلقة في اتجاهها
                projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.speed));

                // إذا كانت بعيدة جداً، قم بإزالتها
                const distanceToOrigin = projectile.position.distanceTo(new THREE.Vector3(0, 0, 0));
                if (distanceToOrigin > 1000) {
                    scene.remove(projectile);
                    wasteProjectiles.splice(i, 1);
                    continue;
                }

                // التحقق من الاصطدام باللاعب
                const distanceToPlayer = projectile.position.distanceTo(playerPos);
                if (distanceToPlayer < 2) { // إذا كانت المسافة أقل من 2، تعتبر اصطداماً
                    playerHealth -= projectile.userData.damage;
                    updateUI();
                    // إزالة الطلقة بعد الاصطدام
                    scene.remove(projectile);
                    wasteProjectiles.splice(i, 1);
                    // **جديد: إضافة تأثير بصري عند إصابة اللاعب**
                    effects.push({
                        particles: createExplosionEffect(playerPos, false),
                        createdAt: Date.now()
                    });
                }
            }
        }

        // إطلاق ليزر
        function shootLaser(isCharged) {
            if (!gameStarted || gameOver || isRoundTransition) return;
            const currentTime = Date.now();
            if (!isCharged && currentTime - lastShotTime < normalShotCooldown) return;
            lastShotTime = currentTime;

            // ** تشغيل الصوت عند إطلاق النار **
            if (isCharged) {
                playChargedShotSound();
            } else {
                playShotSound();
            }

            // إنشاء شعاع تصويب من مركز الكاميرا
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            // نقطة تأثير الطلقة
            let impactPoint;
            const intersects = raycaster.intersectObjects(
                wastes.map(w => w.children[0]), true
            );
            if (intersects.length > 0) {
                // إذا اصطدم الليزر بنفاية، فإن نقطة التأثير هي نقطة الاصطدام
                impactPoint = intersects[0].point;
            } else {
                // إذا لم يصطدم الليزر بأي نفاية، فإن نقطة التأثير تكون بعيدة في الاتجاه الذي يشير إليه الليزر
                impactPoint = raycaster.ray.at(100);
            }

            // إنشاء شعاع الليزر
            laserBeams.push(createLaserBeam(raycaster.ray.origin, impactPoint, isCharged));

            // زيادة قوة الطلقة الخارقة لتتناسب مع النفايات الأقوى
            const damage = isCharged ? 250 * round : 50;
            const blastRadius = isCharged ? 10 : 3;
            const wastesToDamage = [];

            // التحقق من النفايات ضمن نطاق الانفجار
            for (let i = wastes.length - 1; i >= 0; i--) {
                const waste = wastes[i];
                const wastePos = new THREE.Vector3();
                waste.getWorldPosition(wastePos);
                const distance = wastePos.distanceTo(impactPoint);
                if (distance < blastRadius) {
                    wastesToDamage.push(waste);
                }
            }

            // تطبيق الضرر على النفايات المتضررة
            for (const waste of wastesToDamage) {
                waste.userData.health -= damage;
                if (waste.userData.health <= 0) {
                    scene.remove(waste);
                    const index = wastes.indexOf(waste);
                    if (index > -1) {
                        wastes.splice(index, 1);
                    }
                    coins.push(createCoin(waste.position.x, waste.position.z, waste.userData.value));
                    score += waste.userData.isAggressive ? 25 : 10; // نقاط أكثر للنفايات العدوانية
                    playMonsterExplosionSound(); // تشغيل صوت تفجير الوحوش
                }
            }

            // إنشاء تأثير انفجار عند نقطة التأثير
            if (wastesToDamage.length > 0) {
                effects.push({
                    particles: createExplosionEffect(impactPoint, isCharged),
                    createdAt: Date.now()
                });
            }

            updateUI();
        }

        // تحديث حركة الشعاع الليزري
        function updateLaserBeams() {
            const now = Date.now();
            for (let i = laserBeams.length - 1; i >= 0; i--) {
                const beam = laserBeams[i];
                const age = now - beam.createdAt;
                if (age > 100) {
                    scene.remove(beam.beam);
                    laserBeams.splice(i, 1);
                }
            }
        }

        // تحديث التأثيرات البصرية
        function updateEffects() {
            const now = Date.now();
            for (let i = effects.length - 1; i >= 0; i--) {
                const effect = effects[i];
                if (now - effect.createdAt > 500) {
                    effect.particles.forEach(particle => {
                        scene.remove(particle);
                    });
                    effects.splice(i, 1);
                } else {
                    effect.particles.forEach(particle => {
                        particle.position.add(particle.userData.velocity);
                        particle.material.opacity = 0.8 * (1 - (now - effect.createdAt) / 500);
                    });
                }
            }
        }

        // تدوير النقود وتأثير البريق (نسخة معدلة)
        function rotateCoins() {
            coins.forEach(coin => {
                coin.rotation.y += coin.userData.spinSpeed;
                // تحريك البريقات لجعلها تتألق
                coin.children.forEach(child => {
                    if (child.userData && child.userData.angle !== undefined) {
                        child.userData.angle += coin.userData.sparkleSpeed;
                        child.position.set(
                            Math.cos(child.userData.angle) * 0.7,
                            0.1,
                            Math.sin(child.userData.angle) * 0.7
                        );
                        child.material.opacity = 0.5 + 0.5 * Math.sin(child.userData.angle * 2);
                    }
                });
            });
        }

        // تحديث حركة اللاعب باستخدام التسارع والتباطؤ مع التحقق من الحدود
        function movePlayer() {
            if (isRoundTransition) return;
            // الحصول على اتجاهات الحركة من دوران مجموعة اللاعب، وليس الكاميرا
            const direction = new THREE.Vector3();
            player.getWorldDirection(direction);
            const forward = new THREE.Vector3().copy(direction).setY(0).normalize();
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

            // تطبيق التسارع بناءً على إدخال المستخدم
            if (moveForward) {
                // عكس اتجاه الحركة الأمامية
                velocity.add(forward.multiplyScalar(-acceleration));
            }
            if (moveBackward) {
                // عكس اتجاه الحركة الخلفية
                velocity.add(forward.multiplyScalar(acceleration));
            }
            if (moveLeft) {
                velocity.add(right.multiplyScalar(-acceleration));
            }
            if (moveRight) {
                velocity.add(right.multiplyScalar(acceleration));
            }

            // تطبيق الاحتكاك (التباطؤ)
            velocity.multiplyScalar(deceleration);

            // الحد من السرعة القصوى
            if (velocity.length() > maxSpeed) {
                velocity.normalize().multiplyScalar(maxSpeed);
            }

            let newPosition = player.position.clone().add(velocity);
            // التحقق من حدود العالم
            newPosition = checkWorldBounds(newPosition);

            let collisionDetected = false;
            const playerBoundingSphere = new THREE.Sphere(newPosition, 2);
            for (const house of houses) {
                house.children.forEach(child => {
                    const childBox = new THREE.Box3().setFromObject(child);
                    if (childBox.intersectsSphere(playerBoundingSphere)) {
                        collisionDetected = true;
                    }
                });
                if (collisionDetected) break;
            }

            // إذا لم يكن هناك تصادم، قم بتحديث موقع اللاعب
            if (!collisionDetected) {
                player.position.copy(newPosition);
            } else {
                // إذا كان هناك تصادم، نوقف الحركة
                velocity.set(0, 0, 0);
            }
        }

        // تحديث مؤشر الليزر على الشاشة (الآن هو ثابت في المنتصف)
        function updateLaserSight() {
            // المؤشر ثابت في المنتصف، لذا لا حاجة لتحديث موقعه
        }

        // جمع النقود
        function collectCoins() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            for (let i = coins.length - 1; i >= 0; i--) {
                const coinPos = new THREE.Vector3();
                coins[i].getWorldPosition(coinPos);
                const distance = playerPos.distanceTo(coinPos);

                if (distance < 3) {
                    coinsCollected += coins[i].userData.value;
                    showCoinAnimation(coinPos.x, coinPos.y + 2, coinPos.z, coins[i].userData.value);
                    scene.remove(coins[i]);
                    coins.splice(i, 1);
                    updateUI();
                    playCoinSound(); // تشغيل صوت جمع العملة
                }
            }
        }

        // عرض رسالة جمع النقود
        function showCoinAnimation(x, y, z, value) {
            const coinDiv = document.createElement('div');
            coinDiv.className = 'coin-animation';
            coinDiv.textContent = `+${value}`;
            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);
            coinDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            coinDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector('.scene-container').appendChild(coinDiv);
            setTimeout(() => {
                coinDiv.remove();
            }, 1500);
        }

        // زيادة مستوى الصعوبة
        function increaseDifficulty() {
            if (score >= level * 100) {
                level++;
                updateUI();
            }
        }

        // التحقق من حالة اللعبة (فوز أو خسارة)
        function checkGameState() {
            // **جديد: إذا كانت صحة اللاعب أقل من أو تساوي صفر، تنتهي اللعبة**
            if (playerHealth <= 0) {
                gameOverPanel.querySelector('h2').textContent = "لقد خسرت!";
                gameOverPanel.querySelector('p').textContent = "صحتك وصلت للصفر!";
                endGame();
                return;
            }

            // إذا اختفت جميع الأشجار، خسر اللاعب
            if (trees.length === 0) {
                gameOverPanel.querySelector('h2').textContent = "لقد خسرت!";
                gameOverPanel.querySelector('p').textContent = "جميع الأشجار دمرت!";
                endGame();
                return;
            }

            // إذا اختفت جميع النفايات، فاز اللاعب
            if (wastes.length === 0 && !isRoundTransition) {
                // إذا لم تعد هناك نفايات، اظهر زر الجولة التالية للسماح للاعب بالمتابعة
                nextRoundBtn.style.display = 'block';
                nextRoundBtn.disabled = false;
            }
        }

        // انتهاء اللعبة
        function endGame() {
            gameStarted = false;
            gameOver = true;
            finalScore.textContent = score;
            finalCoins.textContent = coinsCollected;
            gameOverPanel.style.display = 'block';
        }

        // إعادة تشغيل اللعبة
        function restartGame() {
            // تأكد من مسح جميع العناصر من المشهد والقوائم بشكل كامل
            wastes.forEach(waste => scene.remove(waste));
            wastes.length = 0;
            laserBeams.forEach(beam => {
                scene.remove(beam.beam);
            });
            laserBeams.length = 0;
            wasteProjectiles.forEach(p => scene.remove(p)); // **جديد**
            wasteProjectiles.length = 0; // **جديد**
            effects.forEach(effect => {
                effect.particles.forEach(particle => {
                    scene.remove(particle);
                });
            });
            effects.length = 0;
            coins.forEach(coin => scene.remove(coin));
            coins.length = 0;
            trees.forEach(tree => scene.remove(tree));
            trees.length = 0;
            treasureBoxes.forEach(box => scene.remove(box));
            treasureBoxes.length = 0;

            score = 0;
            coinsCollected = 0;
            level = 1;
            round = 1;
            gameOver = false;
            playerSpeed = 5.0;
            playerHealth = 100; // **جديد: إعادة تعيين صحة اللاعب**

            // إعادة تعيين موقع ودوران اللاعب والكاميرا
            player.position.set(0, 0, 0);
            player.rotation.set(0, 0, 0);
            camera.position.set(0, 1.8, 0);
            camera.rotation.set(0, 0, 0);

            updateUI();
            gameOverPanel.style.display = 'none';
            gameStarted = true;

            // بدء الجولة الأولى
            spawnNewTrees();
            spawnWavesForRound();
        }

        // --- وظائف مساعدة للتحكم باللمس المتعدد ---
        function getTouchTarget(touch) {
            return document.elementFromPoint(touch.clientX, touch.clientY);
        }

        function isMovementButton(element) {
            return element.classList.contains('movement-btn');
        }

        function isShootButton(element) {
            return element.id === 'shootBtn';
        }

        // --- إعداد مستمعي الأحداث للتحكم باللمس المتعدد ---
        function setupMultiTouchControls() {
            window.addEventListener('touchstart', (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;
                // التحقق من كل لمسة جديدة
                for (const touch of e.changedTouches) {
                    const targetElement = getTouchTarget(touch);
                    if (isMovementButton(targetElement)) {
                        // إذا كانت اللمسة على زر حركة
                        buttonTouchIds.set(touch.identifier, targetElement);
                        switch (targetElement.id) {
                            case 'upBtn':
                                moveForward = true;
                                break;
                            case 'downBtn':
                                moveBackward = true;
                                break;
                            case 'leftBtn':
                                moveRight = true;
                                break;
                            case 'rightBtn':
                                moveLeft = true;
                                break;
                        }
                    } else if (isShootButton(targetElement)) {
                        // إذا كانت اللمسة على زر إطلاق النار
                        buttonTouchIds.set(touch.identifier, targetElement);
                        startCharging();
                    } else if (!cameraTouchId) {
                        // إذا كانت اللمسة على الشاشة ولم يتم تعيين لمسة للكاميرا بعد
                        cameraTouchId = touch.identifier;
                        previousTouchX = touch.clientX;
                        previousTouchY = touch.clientY;
                    }
                }
            }, {
                passive: true
            });

            window.addEventListener('touchmove', (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;
                // معالجة حركة الكاميرا إذا كانت لمسة الكاميرا نشطة
                for (const touch of e.changedTouches) {
                    if (touch.identifier === cameraTouchId) {
                        const deltaX = touch.clientX - previousTouchX;
                        const deltaY = touch.clientY - previousTouchY;
                        player.rotation.y -= deltaX * touchSensitivity;
                        camera.rotation.x -= deltaY * touchSensitivity; // استخدام touchSensitivity للكاميرا
                        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                        previousTouchX = touch.clientX;
                        previousTouchY = touch.clientY;
                    }
                }
            }, {
                passive: true
            });

            window.addEventListener('touchend', (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;
                for (const touch of e.changedTouches) {
                    if (touch.identifier === cameraTouchId) {
                        // إنهاء لمسة الكاميرا
                        cameraTouchId = null;
                    } else if (buttonTouchIds.has(touch.identifier)) {
                        // إنهاء لمسة زر الحركة أو إطلاق النار
                        const targetElement = buttonTouchIds.get(touch.identifier);
                        if (isMovementButton(targetElement)) {
                            switch (targetElement.id) {
                                case 'upBtn':
                                    moveForward = false;
                                    break;
                                case 'downBtn':
                                    moveBackward = false;
                                    break;
                                case 'leftBtn':
                                    moveRight = false;
                                    break;
                                case 'rightBtn':
                                    moveLeft = false;
                                    break;
                            }
                        } else if (isShootButton(targetElement)) {
                            endCharging();
                        }
                        buttonTouchIds.delete(touch.identifier);
                    }
                }
            });
        }

        // إعداد مستمعي أحداث الفأرة (بدون تغيير)
        function setupMouseControls() {
            window.addEventListener('mousedown', (e) => {
                if (!gameStarted || e.target !== canvas || gameOver || isRoundTransition) return;
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
                document.body.classList.add('dragging');
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                document.body.classList.remove('dragging');
            });

            window.addEventListener('mousemove', (e) => {
                if (!gameStarted || !isDragging || gameOver || isRoundTransition) return;
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;
                player.rotation.y -= deltaX * mouseSensitivity;
                camera.rotation.x -= deltaY * touchSensitivity; // استخدام touchSensitivity للكاميرا
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            });
        }

        // إعداد مستمعي الأحداث
        shootBtn.addEventListener('mousedown', startCharging);
        shootBtn.addEventListener('mouseup', endCharging);

        function startCharging() {
            if (!gameStarted || gameOver || isRoundTransition) return;
            isCharging = true;
            chargeStartTime = Date.now();
            chargeIndicator.style.display = 'block';
        }

        function endCharging() {
            if (!isCharging) return;
            isCharging = false;
            const chargeTime = Date.now() - chargeStartTime;
            const chargePercentage = Math.min(100, (chargeTime / maxChargeTime) * 100);
            shootLaser(chargeTime >= maxChargeTime);
            chargeIndicator.style.display = 'none';
            chargeBar.style.width = '0%';
        }

        // أحداث لوحة المفاتيح للحركة
        document.addEventListener('keydown', (e) => {
            if (!gameStarted || gameOver || isRoundTransition) return;
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                case 's':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRight = false;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!gameStarted || gameOver || isRoundTransition) return;
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                case 's':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                case 'a':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRight = false;
                    break;
            }
        });

        // أحداث أزرار الحركة باللمس (تم إزالتها لصالح نظام اللمس المتعدد الجديد)
        restartBtn.addEventListener('click', restartGame);
        nextRoundBtn.addEventListener('click', nextRound);

        // زر "ابدأ اللعبة"
        startGameBtn.addEventListener('click', () => {
            startScreen.style.display = 'none';
            treeStatsDisplay.style.display = 'flex';
            scoreDisplay.style.display = 'block';
            coinsDisplay.style.display = 'block';
            healthIndicator.style.display = 'block'; // **جديد**
            roundIndicator.style.display = 'block';
            laserSight.style.display = 'block';
            gameStarted = true;

            // إنشاء البيوت لمرة واحدة
            spawnHouses();
            // إنشاء الحدود المرئية
            createWorldBoundsVisual();
            // بدء الجولة الأولى
            spawnNewTrees();
            spawnWavesForRound();
            updateUI();

            // إعداد تحكمات الفأرة واللمس المتعدد
            setupMouseControls();
            setupMultiTouchControls();
        });

        // دوال مساعدة جديدة لتحويل الكسور العشرية الدورية
        // -------------------------------------------------------------------------------------------------------------------------------------------------
        /**
         * حساب القاسم المشترك الأكبر (GCD) باستخدام خوارزمية إقليدس.
         * @param {number} a - العدد الأول.
         * @param {number} b - العدد الثاني.
         * @returns {number} القاسم المشترك الأكبر.
         */
        function gcd(a, b) {
            // نستخدم القيمة المطلقة لأن الأعداد قد تكون سالبة، وخوارزمية إقليدس تعمل على الأعداد الموجبة
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        }

        /**
         * تحويل كسر عشري دوري إلى كسر فعلي أو عدد كسري.
         * @param {string} decimalString - الكسر العشري الدوري كقيمة نصية (مثال: "0.1(6)").
         * @returns {{numerator: number, denominator: number, integerPart: number}} الكسر الفعلي أو العدد الكسري.
         */
        function convertRepeatingDecimal(decimalString) {
            // 1. تحليل السلسلة النصية للحصول على الأجزاء المختلفة
            const match = decimalString.match(/(\d*)\.((\d*)?\((\d+)\))?/);
            if (!match) {
                throw new Error("تنسيق الكسر العشري الدوري غير صحيح");
            }

            const integerPart = parseInt(match[1]) || 0;
            const nonRepeatingPart = match[3] || '';
            const repeatingPart = match[4] || '';

            // 2. تطبيق القاعدة الرياضية للتحويل
            let numerator, denominator;
            if (repeatingPart === '') {
                // حالة الكسر العادي غير الدوري (لضمان عمل الدالة حتى مع الأعداد غير الدورية)
                numerator = parseInt(nonRepeatingPart);
                denominator = Math.pow(10, nonRepeatingPart.length);
            } else {
                // القاعدة:
                // البسط = (العدد الكامل بدون الفاصلة) - (الجزء غير الدوري بدون الفاصلة)
                // المقام = (عدد 9s بعدد الأرقام الدورية) + (عدد 0s بعدد الأرقام غير الدورية)
                const fullNumber = parseInt(nonRepeatingPart + repeatingPart) || 0;
                const nonRepeatingNumber = parseInt(nonRepeatingPart) || 0;
                numerator = fullNumber - nonRepeatingNumber;
                denominator = (Math.pow(10, nonRepeatingPart.length + repeatingPart.length) - Math.pow(10, nonRepeatingPart.length));
            }

            // 3. تبسيط الكسر
            const commonDivisor = gcd(numerator, denominator);
            numerator /= commonDivisor;
            denominator /= commonDivisor;

            return {
                numerator,
                denominator,
                integerPart
            };
        }
        // -------------------------------------------------------------------------------------------------------------------------------------------------

        // توليد سؤال رياضي عشوائي
        function generateMathQuestion() {
            // الأنواع الجديدة للأسئلة: تحويل كسر دوري إلى كسر عادي أو عدد كسري
            const questionTypes = ['fraction_conversion', 'mixed_number_conversion'];
            const selectedType = questionTypes[Math.floor(Math.random() * questionTypes.length)];

            if (selectedType === 'fraction_conversion') {
                // هذا الجزء يولد سؤالاً لتحويل كسر عشري دوري بسيط مثل 0.6
                // نختار رقمًا عشوائيًا بين 1 و 9 ليكون الرقم الدوري
                const repeatingDigit = Math.floor(Math.random() * 8) + 1;
                // نستخدم تنسيق LaTeX لإنشاء السلسلة النصية للرقم الدوري
                const decimalString = `0.\\overline{${repeatingDigit}}`;
                const numerator = repeatingDigit;
                const denominator = 9;
                // نقوم بتبسيط الكسر للحصول على أبسط صورة
                const commonDivisor = gcd(numerator, denominator);
                const simplifiedNumerator = numerator / commonDivisor;
                const simplifiedDenominator = denominator / commonDivisor;
                // الإجابة الصحيحة بتنسيق LaTeX
                const answer = `$$\\frac{${simplifiedNumerator}}{${simplifiedDenominator}}$$`;
                // نص السؤال
                const question = `اكتب الكسر العشري الدوري $$${decimalString}$$ على صورة كسر عادي.`;
                const options = [answer];
                // توليد خيارات خاطئة
                while (options.length < 4) {
                    let wrongNumerator = simplifiedNumerator + Math.floor(Math.random() * 3) - 1;
                    let wrongDenominator = simplifiedDenominator + Math.floor(Math.random() * 3) - 1;
                    if (wrongNumerator <= 0) wrongNumerator = 1;
                    if (wrongDenominator <= 0) wrongDenominator = 1;
                    const wrongAnswer = `$$\\frac{${wrongNumerator}}{${wrongDenominator}}$$`;
                    if (!options.includes(wrongAnswer)) {
                        options.push(wrongAnswer);
                    }
                }
                options.sort(() => Math.random() - 0.5);
                return {
                    question,
                    options,
                    answer
                };
            } else {
                // هذا الجزء يولد سؤالاً لتحويل عدد عشري دوري مختلط مثل 1.14
                // نختار رقمًا صحيحًا عشوائيًا من 1 إلى 4
                const integerPart = Math.floor(Math.random() * 4) + 1;
                // نختار رقمين عشريين عشوائيين بين 10 و 99
                let repeatingDigits = Math.floor(Math.random() * 90) + 10;
                // الإجابة الصحيحة للكسر
                const numerator = repeatingDigits;
                const denominator = 99;
                // نبسط الكسر
                const commonDivisor = gcd(numerator, denominator);
                const simplifiedNumerator = numerator / commonDivisor;
                const simplifiedDenominator = denominator / commonDivisor;
                // الإجابة الصحيحة بتنسيق LaTeX للعدد الكسري
                const answer = `$$${integerPart}\\frac{${simplifiedNumerator}}{${simplifiedDenominator}}$$`;
                // نستخدم تنسيق LaTeX لإنشاء السلسلة النصية للرقم الدوري
                const decimalString = `${integerPart}.\\overline{${repeatingDigits}}`;
                // نص السؤال
                const question = `اكتب العدد العشري الدوري $$${decimalString}$$ على صورة عدد كسري.`;
                const options = [answer];
                // توليد خيارات خاطئة
                while (options.length < 4) {
                    let wrongInteger = integerPart + Math.floor(Math.random() * 2) - 1;
                    let wrongNumerator = simplifiedNumerator + Math.floor(Math.random() * 3) - 1;
                    let wrongDenominator = simplifiedDenominator + Math.floor(Math.random() * 3) - 1;
                    if (wrongInteger <= 0) wrongInteger = 1;
                    if (wrongNumerator <= 0) wrongNumerator = 1;
                    if (wrongDenominator <= 0) wrongDenominator = 1;
                    const wrongAnswer = `$$${wrongInteger}\\frac{${wrongNumerator}}{${wrongDenominator}}$$`;
                    if (!options.includes(wrongAnswer)) {
                        options.push(wrongAnswer);
                    }
                }
                options.sort(() => Math.random() - 0.5);
                return {
                    question,
                    options,
                    answer
                };
            }
        }

        // التحقق من اصطدام اللاعب بصندوق الصحة
        function checkTreasureBoxCollision() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            for (let i = treasureBoxes.length - 1; i >= 0; i--) {
                const box = treasureBoxes[i];
                const boxPos = new THREE.Vector3();
                box.getWorldPosition(boxPos);
                const distance = playerPos.distanceTo(boxPos);

                if (distance < 3 && box.userData.isHealthBox) {
                    freezeGame();
                    showMathQuestion(box);
                    playBoxSound(); // تشغيل صوت الوصول إلى الصندوق
                    return;
                }
            }
        }

        // تجميد حلقة اللعبة
        function freezeGame() {
            isGameFrozen = true;
            cancelAnimationFrame(gameLoopId);
        }

        // استئناف حلقة اللعبة
        function unfreezeGame() {
            isGameFrozen = false;
            animate();
        }

        // عرض نافذة السؤال
        function showMathQuestion(box) {
            const questionData = generateMathQuestion();
            questionText.textContent = questionData.question;
            optionsContainer.innerHTML = '';
            questionData.options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'option-btn';
                button.textContent = option;
                button.addEventListener('click', () => {
                    handleAnswer(option, questionData.answer, box);
                });
                optionsContainer.appendChild(button);
            });
            questionPanel.style.display = 'block';

            // تحديث عرض الرموز الرياضية باستخدام MathJax
            MathJax.typesetPromise();
        }

        // معالجة الإجابة
        function handleAnswer(selectedOption, correctAnswer, box) {
            // التحقق من الإجابة
            const isCorrect = (selectedOption === correctAnswer);
            let prizeMessage = "إجابة خاطئة!"; // رسالة افتراضية للخسارة
            let isWin = false;
            if (isCorrect) {
                isWin = true;
                const rewardType = Math.floor(Math.random() * 3);
                switch (rewardType) {
                    case 0: // صحة
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 20);
                        prizeMessage = "إجابة صحيحة! الجائزة: صحة إضافية!";
                        break;
                    case 1: // شحن كامل لليزر الخارق
                        endCharging(); // إنهاء أي شحن حالي
                        isCharging = false;
                        chargeBar.style.width = '100%';
                        setTimeout(() => {
                            chargeBar.style.width = '0%';
                        }, 1000);
                        prizeMessage = "إجابة صحيحة! الجائزة: شحن الليزر الخارق!";
                        break;
                    case 2: // شجرة
                        const treeX = Math.random() * 800 - 400;
                        const treeZ = Math.random() * 800 - 400;
                        trees.push(createTree(treeX, treeZ));
                        totalTrees++;
                        prizeMessage = "إجابة صحيحة! الجائزة: شجرة جديدة للحديقة!";
                        break;
                }
                playGiftSound(); // تشغيل صوت الحصول على هدية
            }
            // عرض رسالة مخصصة بدلاً من alert()
            showAnswerMessage(isWin, prizeMessage);
            // إزالة الصندوق بعد الإجابة
            scene.remove(box);
            const boxIndex = treasureBoxes.indexOf(box);
            if (boxIndex > -1) {
                treasureBoxes.splice(boxIndex, 1);
            }
            questionPanel.style.display = 'none';
            unfreezeGame();
            updateUI();
        }

        // دالة جديدة لعرض رسالة الإجابة
        function showAnswerMessage(isCorrect, message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'answer-message';
            if (!isCorrect) {
                messageDiv.classList.add('incorrect');
            }
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            // إخفاء الرسالة بعد فترة زمنية
            setTimeout(() => {
                messageDiv.remove();
            }, 1500); // 1.5 ثانية
        }

        // حلقة اللعبة
        function animate() {
            gameLoopId = requestAnimationFrame(animate);
            // إذا كانت اللعبة متجمدة، لا تقم بأي تحديث
            if (isGameFrozen) {
                return;
            }

            if (gameStarted && !gameOver) {
                if (isCharging) {
                    const chargeTime = Date.now() - chargeStartTime;
                    const chargePercentage = Math.min(100, (chargeTime / maxChargeTime) * 100);
                    chargeBar.style.width = `${chargePercentage}%`;
                }
                movePlayer();
                moveWastes();
                updateWasteProjectiles();
                rotateCoins();
                collectCoins();
                checkTreasureBoxCollision(); // **جديد: التحقق من الصناديق**
                updateLaserBeams();
                updateEffects();
                increaseDifficulty();
                checkGameState();
                updateUI();
            }
            renderer.render(scene, camera);
        }

        // التعامل مع تغيير حجم النافذة
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            updateLaserSight();
        });

        window.onload = function () {
            // تحديث الحجم الأولي للوحة عند التحميل
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            animate();
        };
    </script>
</body>
</html>