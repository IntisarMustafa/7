<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© ØªØ¯Ù…ÙŠØ± Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø¨Ø§Ù„Ù„ÙŠØ²Ø± - Ù†ÙØ§ÙŠØ§Øª Ø´Ø±ÙŠØ±Ø©</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Cairo', sans-serif;
        }

        /* ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ© Ù„Ù…Ø¸Ù‡Ø± Ø§Ù„Ù†Ù‡Ø§Ø± */
        body, html {
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #B0E0E6);
            color: #1a1a2e;
            height: 100%;
            width: 100%;
            cursor: grab;
        }

        body.dragging, html.dragging {
            cursor: grabbing;
        }

        /* Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ¨ÙŠØ± Ø¨Ø§Ù„Ù„Ù…Ø³ */
        body {
            touch-action: none;
        }

        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            z-index: 300;
        }

        .start-screen-content {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            animation: fadeInScale 0.7s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }

        .start-screen h1 {
            color: #00b4d8;
            font-size: 40px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #00b4d8;
        }

        .start-screen h2 {
            color: #90e0ef;
            margin-top: 30px;
            margin-bottom: 10px;
            border-bottom: 2px solid #00b4d8;
            padding-bottom: 5px;
            font-size: 24px;
        }

        .start-screen p {
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: center;
        }

        .start-btn {
            background: linear-gradient(to right, #00b4d8, #0077b6);
            color: white;
            padding: 15px 35px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            margin: 20px 0;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5);
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
            align-items: center;
            justify-content: center;
        }

        .info-panel {
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            opacity: 0.95;
            display: none;
        }

        .scene-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            height: 100%;
            width: 100%;
        }

        #gameScene {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 10px;
            color: white;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #00b4d8;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.8;
        }

        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            max-width: 400px;
            display: none;
            color: white;
        }

        .title {
            font-size: 24px;
            margin-bottom: 10px;
            color: #00b4d8;
            text-align: center;
        }

        .subtitle {
            font-size: 16px;
            opacity: 0.8;
            text-align: center;
        }

        .game-ui {
            position: absolute;
            bottom: 200px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
        }

        .ui-button {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .charge-btn {
            background: linear-gradient(to bottom, #ff0000, #ff5500);
            box-shadow: 0 4-box-shadow: 0 4px 10px rgba(255, 0, 0, 0.5);
            transition: transform 0.1s ease, box-shadow 0.3s ease;
        }

        .ui-button:active {
            background: rgba(0, 180, 216, 0.5);
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .score-display {
            position: absolute;
            top: 50px;
            right: 20px;
            font-size: 24px;
            color: #005080;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }

        .coins-display {
            position: absolute;
            top: 85px;
            right: 20px;
            font-size: 20px;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }

        /* Ø´Ø±ÙŠØ· ØµØ­Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯ */
        .health-indicator {
            position: absolute;
            top: 120px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            display: none;
            z-index: 100;
        }

        .health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #00FF00, #FFFF00, #FF0000);
            transition: width 0.3s ease;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            display: none;
            color: white;
        }

        .restart-btn {
            background: linear-gradient(to right, #00b4d8, #0077b6);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .movement-controls {
            position: absolute;
            bottom: 200px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .movement-row {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .movement-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .movement-btn:active {
            background: rgba(0, 180, 216, 0.5);
            transform: scale(0.95);
        }

        .coin-animation {
            position: absolute;
            font-size: 24px;
            color: #FFD700;
            font-weight: bold;
            animation: coinFloat 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 90;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .laser-sight {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: transparent;
            border: 3px solid #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.9);
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            pointer-events: none;
            z-index: 90;
            display: none;
        }

        .round-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 18px;
            color: #00b4d8;
            font-weight: bold;
            z-index: 100;
            display: none;
        }

        .next-round-btn {
            position: absolute;
            bottom: 200px;
            right: 20px;
            background: linear-gradient(to right, #00b4d8, #0077b6);
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 100;
            display: none;
        }

        .next-round-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .next-round-btn:disabled {
            background: linear-gradient(to right, #555, #777);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .tree-stats-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 18px;
            color: white;
            z-index: 100;
            display: none;
        }

        .tree-stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tree-stat-item .stat-value {
            font-size: 20px;
            color: #00b4d8;
            font-weight: bold;
        }

        .charge-indicator {
            position: absolute;
            bottom: 180px;
            right: 120px;
            width: 100px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            display: none;
            z-index: 100;
        }

        .charge-bar {
            width: 0;
            height: 100%;
            background: linear-gradient(to right, #00b4d8, #ff0000);
            transition: width 0.1s linear;
        }

        .world-boundary {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            color: #ff9900;
            z-index: 100;
            display: none;
            animation: boundaryPulse 2s infinite;
        }

        .round-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .round-transition.active {
            opacity: 1;
            pointer-events: all;
        }

        .round-message {
            background: rgba(255, 255, 255, 0.9);
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            font-size: 32px;
            color: #00b4d8;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .aggressive-warning {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 16px;
            color: white;
            z-index: 100;
            display: none;
            animation: warningPulse 1s infinite;
        }

        /* ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø³Ø¤Ø§Ù„ */
        .question-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 250;
            display: none;
            color: white;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .question-panel h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .question-panel p {
            font-size: 20px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .options-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .option-btn {
            background: linear-gradient(to right, #00b4d8, #0077b6);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .option-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        /* ØªÙ†Ø³ÙŠÙ‚Ø§Øª ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„ØµØ­Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯ */
        .health-box-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
        }

        .health-box-icon {
            font-size: 50px;
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            animation: pulse 1.5s infinite ease-in-out;
        }

        .health-box-label {
            position: absolute;
            bottom: -30px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: #00BFFF;
            text-shadow: 0 0 5px rgba(0, 191, 255, 0.5);
            font-weight: bold;
        }

        @keyframes coinFloat {
            0% {
                opacity: 1;
                transform: translate(0, 0);
            }

            100% {
                opacity: 0;
                transform: translate(0, -100px);
            }
        }

        @keyframes fadeInScale {
            0% {
                opacity: 0;
                transform: scale(0.95);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes boundaryPulse {
            0% {
                box-shadow: 0 0 5px rgba(255, 153, 0, 0.5);
            }

            50% {
                box-shadow: 0 0 15px rgba(255, 153, 0, 0.8);
            }

            100% {
                box-shadow: 0 0 5px rgba(255, 153, 0, 0.5);
            }
        }

        @keyframes warningPulse {
            0% {
                opacity: 0.7;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.7;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        .hidden {
            display: none;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }

            .info-panel {
                width: 100%;
                max-height: 45vh;
            }

            .overlay {
                font-size: 14px;
                max-width: 80%;
                left: 15px;
                top: 15px;
            }

            .overlay .title {
                font-size: 18px;
            }

            .overlay .subtitle {
                font-size: 14px;
            }

            .game-ui {
                bottom: 170px;
                right: 10px;
            }

            .ui-button {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }

            .movement-controls {
                bottom: 170px;
                left: 10px;
            }

            .movement-btn {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            .score-display {
                bottom: 150px;
                right: 10px;
                font-size: 16px;
            }

            .coins-display {
                bottom: 180px;
                right: 10px;
                font-size: 16px;
            }

            .health-indicator {
                top: 150px;
                right: 10px;
                width: 150px;
            }

            .start-screen-content {
                padding: 20px;
            }

            .start-screen h1 {
                font-size: 30px;
            }

            .start-screen h2 {
                font-size: 20px;
            }

            .start-screen p {
                font-size: 16px;
            }

            .start-btn {
                font-size: 18px;
                padding: 12px 25px;
            }

            .round-indicator {
                font-size: 16px;
                padding: 8px 15px;
            }

            .next-round-btn {
                bottom: 170px;
                right: 10px;
                font-size: 14px;
                padding: 10px 15px;
            }

            .charge-indicator {
                bottom: 150px;
                right: 90px;
                width: 80px;
            }

            .world-boundary {
                font-size: 12px;
                padding: 6px 10px;
                top: 5px;
                right: 5px;
            }

            .round-message {
                font-size: 24px;
                padding: 20px 30px;
            }
        }

        /* ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© */
        .answer-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            color: white;
            padding: 30px;
            border-radius: 20px;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            z-index: 300;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: popIn 0.5s ease-out;
            border: 5px solid #fff;
        }

        .answer-message.incorrect {
            background: linear-gradient(45deg, #F44336, #FF9800);
        }

        @keyframes popIn {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="start-screen-content">
            <h1>Ù„Ø¹Ø¨Ø© ØªØ¯Ù…ÙŠØ± Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø¨Ø§Ù„Ù„ÙŠØ²Ø±</h1>
            <h2>Ø¹Ù† Ø§Ù„Ù„Ø¹Ø¨Ø©</h2>
            <p>ØªÙ‡Ø§Ø¬Ù… Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø´Ø±ÙŠØ±Ø© Ø§Ù„Ø­Ø¯ÙŠÙ‚Ø© Ø§Ù„Ù…Ø¯Ø±Ø³ÙŠØ© ÙˆØªØ­Ø§ÙˆÙ„ ØªØ¯Ù…ÙŠØ± Ø§Ù„Ø£Ø´Ø¬Ø§Ø±. Ø§Ø³ØªØ®Ø¯Ù… Ø£Ø´Ø¹Ø© Ø§Ù„Ù„ÙŠØ²Ø± Ù„ØªØ¯Ù…ÙŠØ±Ù‡Ø§ Ù‚Ø¨Ù„ Ø£Ù† ØªØ³Ø¨Ø¨ Ø§Ù„Ø¶Ø±Ø±!</p>
            <button class="start-btn" id="startGameBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
            <h2>ÙƒÙŠÙÙŠØ© Ø§Ù„Ù„Ø¹Ø¨</h2>
            <p>1. Ø§Ø³ØªØ®Ø¯Ù… Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ© Ù„ØªØ­Ø±ÙŠÙƒ Ù…Ø¤Ø´Ø± Ø§Ù„Ù„ÙŠØ²Ø±</p>
            <p>2. Ø§Ø¶ØºØ· Ù„ÙØªØ±Ø© Ù‚ØµÙŠØ±Ø© Ù„Ø¥Ø·Ù„Ø§Ù‚ Ù„ÙŠØ²Ø± Ø¹Ø§Ø¯ÙŠØŒ Ø£Ùˆ Ø§Ø¶ØºØ· Ù…Ø·ÙˆÙ„Ù‹Ø§ Ø«Ù… Ø§ØªØ±Ùƒ Ù„Ø¥Ø·Ù„Ø§Ù‚ Ù„ÙŠØ²Ø± Ø®Ø§Ø±Ù‚!</p>
            <p>3. Ø§Ù„Ù†Ù‚Ø§Ø· ØªØ²ÙŠØ¯ Ù…Ø¹ ÙƒÙ„ Ù†ÙØ§ÙŠØ© ØªØ¯Ù…Ø±Ù‡Ø§</p>
            <p>4. Ø§Ù„Ù†Ù‚ÙˆØ¯ ØªØ³Ù‚Ø· Ù…Ù† Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ù…Ø¯Ù…Ø±Ø©</p>
            <p>5. Ø§Ø­Ù…Ù Ø§Ù„Ø£Ø´Ø¬Ø§Ø± Ù…Ù† Ø§Ù„Ù‡Ø¬ÙˆÙ… (Ø¥Ø°Ø§ Ø§Ù„ØªØµÙ‚Øª Ù†ÙØ§ÙŠØ© Ø¨Ø´Ø¬Ø±Ø©ØŒ ØªØ¯Ù…Ø± Ø§Ù„Ø´Ø¬Ø±Ø©)</p>
            <p>6. Ø§Ù„Ù„Ø¹Ø¨Ø© ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø¬ÙˆÙ„Ø§Øª - Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©" Ù„Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ø§Ù„Ù†ÙØ§ÙŠØ§Øª</p>
            <p>7. <strong>Ø¬Ø¯ÙŠØ¯:</strong> Ø­Ø±ÙƒØ© ÙƒØ§Ù…ÙŠØ±Ø§ Ø³Ù„Ø³Ø© Ù…Ø«Ù„ Ù…Ø§ÙŠÙ† ÙƒØ±Ø§ÙØª - Ø§Ø³Ø­Ø¨ Ø§Ù„ÙØ£Ø±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© Ø£Ùˆ Ø§Ø³Ø­Ø¨ Ø¥ØµØ¨Ø¹Ùƒ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ Ù„ØªØ¯ÙˆÙŠØ± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙˆØ§Ù„ØªØµÙˆÙŠØ¨ Ø¨Ø­Ø±ÙŠØ©.</p>
            <p>8. <strong>ØªØ­ÙƒÙ… Ù…ØªØ¹Ø¯Ø¯ Ø¨Ø§Ù„Ù„Ù…Ø³:</strong> Ø§Ø³ØªØ®Ø¯Ù… Ø¥ØµØ¨Ø¹ÙŠÙ† ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø­Ø±ÙƒØ© ÙˆØªØ¯ÙˆÙŠØ± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ØŒ Ø£Ùˆ Ù„Ù„ØªØ­Ø±Ùƒ ÙˆØ¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±!</p>
            <p>9. <strong>ØªØ­Ø³ÙŠÙ† Ø¬Ø¯ÙŠØ¯:</strong> Ø§Ù„Ù†ÙØ§ÙŠØ§Øª ØªØªØ¬Ù†Ø¨ Ø§Ù„Ø¨ÙŠÙˆØª ÙˆØªÙ„ØªÙ Ø­ÙˆÙ„Ù‡Ø§ Ù„ØªØµÙ„ Ø¥Ù„Ù‰ Ù‡Ø¯ÙÙ‡Ø§!</p>
            <p>10. <strong>ØªØ­Ø°ÙŠØ±:</strong> Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø³ØªØ·Ø§Ø±Ø¯Ùƒ Ø¥Ø°Ø§ Ø§Ù‚ØªØ±Ø¨Øª Ù…Ù†Ù‡Ø§!</p>
            <p>11. <strong>ØªØ­Ø¯ÙŠØ«:</strong> Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ© Ø§Ù„Ø¢Ù† ØªØ·Ù„Ù‚ Ø§Ù„Ù†Ø§Ø± Ø¹Ù„ÙŠÙƒ! ÙƒÙ† Ø­Ø°Ø±Ø§Ù‹!</p>
        </div>
    </div>

    <div class="laser-sight" id="laserSight"></div>
    <div class="world-boundary" id="worldBoundaryWarning">Ø£Ù†Øª ØªÙ‚ØªØ±Ø¨ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù…!</div>
    <div class="aggressive-warning" id="aggressiveWarning">Ù†ÙØ§ÙŠØ§Øª Ø´Ø±ÙŠØ±Ø© ØªÙ‚ØªØ±Ø¨ Ù…Ù†Ùƒ! Ø§Ø­Ø°Ø±!</div>
    <div class="round-transition" id="roundTransition">
        <div class="round-message" id="roundMessage">Ø§Ù„Ø¬ÙˆÙ„Ø© 1</div>
    </div>

    <div class="container">
        <div class="info-panel" id="infoPanel">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="levelDisplay">1</div>
                    <div class="stat-label">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="wasteCount">0</div>
                    <div class="stat-label">Ø§Ù„Ù†ÙØ§ÙŠØ§Øª</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="coinsCount">0</div>
                    <div class="stat-label">Ø§Ù„Ù†Ù‚ÙˆØ¯</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="aggressiveCount">0</div>
                    <div class="stat-label">Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©</div>
                </div>
            </div>
        </div>
        <div class="scene-container">
            <canvas id="gameScene"></canvas>
            <div class="score-display" id="scoreDisplay">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
            <div class="coins-display" id="coinsDisplay">Ø§Ù„Ù†Ù‚ÙˆØ¯: 0</div>
            <div class="health-indicator" id="healthIndicator">
                <div class="health-bar" id="healthBar"></div>
            </div>
            <div class="round-indicator" id="roundIndicator">Ø§Ù„Ø¬ÙˆÙ„Ø©: 1</div>
            <button class="next-round-btn" id="nextRoundBtn">Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©</button>
            <div class="tree-stats-display" id="treeStatsDisplay">
                <div class="tree-stat-item">
                    <div>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø´Ø¬Ø§Ø±:</div>
                    <div class="stat-value" id="totalTreesDisplay">0</div>
                </div>
                <div class="tree-stat-item">
                    <div>Ø§Ù„Ø£Ø´Ø¬Ø§Ø± Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©:</div>
                    <div class="stat-value" id="remainingTreesDisplay">0</div>
                </div>
            </div>
            <div class="movement-controls" id="movementControls">
                <div class="movement-row">
                    <div class="movement-btn" id="upBtn">â†‘</div>
                </div>
                <div class="movement-row">
                    <div class="movement-btn" id="leftBtn">â†</div>
                    <div class="movement-btn" id="downBtn">â†“</div>
                    <div class="movement-btn" id="rightBtn">â†’</div>
                </div>
            </div>
            <div class="game-ui">
                <div class="ui-button" id="shootBtn">â™»ï¸</div>
                <div class="charge-indicator" id="chargeIndicator">
                    <div class="charge-bar" id="chargeBar"></div>
                </div>
            </div>
            <div class="game-over" id="gameOverPanel">
                <h2>Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!</h2>
                <p>Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: <span id="finalScore">0</span></p>
                <p>Ø§Ù„Ù†Ù‚ÙˆØ¯ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: <span id="finalCoins">0</span></p>
                <button class="restart-btn" id="restartBtn">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨</button>
            </div>
        </div>
    </div>
    <div class="question-panel" id="questionPanel">
        <h2>Ø³Ø¤Ø§Ù„ Ø±ÙŠØ§Ø¶ÙŠ!</h2>
        <p id="questionText"></p>
        <div class="options-container" id="optionsContainer">
        </div>
    </div>
    <script>
        // Ø¨Ø¯Ø§ÙŠØ© Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ØµÙˆØªÙŠ ğŸ¶
        // ---------------------------
        // Audio context for sound generation
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // The core function to generate and play sounds
        function playSound(frequency, type = 'sine', duration = 0.1, volume = 0.3) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Set sound properties
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;

            // Play the sound
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Sound effect for monster attack
        function playMonsterAttackSound() {
            const now = audioContext.currentTime;
            const duration = 0.3;
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            const gainNode = audioContext.createGain();
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.5, now);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            source.start(now);
        }

        // Sound effect for a gunshot (normal laser)
        function playShotSound() {
            const now = audioContext.currentTime;
            const duration = 0.2;
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 1;
            filter.frequency.setValueAtTime(4000, now);
            filter.frequency.linearRampToValueAtTime(500, now + duration);
            const gainNode = audioContext.createGain();
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.3, now);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            source.start(now);
            source.stop(now + duration);
        }

        // Sound effect for a powerful charged shot
        function playChargedShotSound() {
            const now = audioContext.currentTime;
            const duration = 0.3;
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 5; // Higher Q for a sharper, more focused sound
            filter.frequency.setValueAtTime(8000, now); // Higher initial frequency
            filter.frequency.linearRampToValueAtTime(200, now + duration);
            const gainNode = audioContext.createGain();
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.8, now); // Higher volume
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            source.start(now);
            source.stop(now + duration);
        }

        // Sound effect for monster explosion
        function playMonsterExplosionSound() {
            const now = audioContext.currentTime;
            const duration = 0.5;
            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = 'sawtooth';
            oscillator1.frequency.value = 60;
            gainNode1.gain.setValueAtTime(0.5, now);
            gainNode1.gain.exponentialRampToValueAtTime(0.001, now + duration);
            oscillator1.start(now);
            oscillator1.stop(now + duration);

            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = 'square';
            oscillator2.frequency.value = 1000;
            gainNode2.gain.setValueAtTime(0.3, now);
            gainNode2.gain.exponentialRampToValueAtTime(0.001, now + duration);
            oscillator2.start(now);
            oscillator2.stop(now + duration);
        }

        // Sound effect for collecting a coin
        function playCoinSound() {
            playSound(880, 'triangle', 0.1, 0.2);
        }

        // Sound effect for reaching a box
        function playBoxSound() {
            playSound(440, 'sine', 0.1, 0.3);
            setTimeout(() => playSound(660, 'sine', 0.1, 0.3), 100);
        }

        // Sound effect for getting a gift
        function playGiftSound() {
            playSound(523, 'sine', 0.1, 0.3);
            setTimeout(() => playSound(659, 'sine', 0.1, 0.3), 100);
            setTimeout(() => playSound(784, 'sine', 0.1, 0.3), 200);
        }
        // Ù†Ù‡Ø§ÙŠØ© Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ØµÙˆØªÙŠ ğŸ¶
        // ---------------------------

        // ØªÙ‡ÙŠØ¦Ø© Ù…Ø´Ù‡Ø¯ Three.js
        const scene = new THREE.Scene();
        // ØªØºÙŠÙŠØ± Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø²Ø±Ù‚ Ø§Ù„ÙØ§ØªØ­
        scene.background = new THREE.Color(0x87CEEB);
        // ØªØºÙŠÙŠØ± Ù„ÙˆÙ† Ø§Ù„Ø¶Ø¨Ø§Ø¨ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø²Ø±Ù‚ Ø§Ù„ÙØ§ØªØ­
        scene.fog = new THREE.Fog(0xADD8E6, 50, 800);

        const canvas = document.getElementById('gameScene');
        const renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true
        });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);

        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ù„Ø§Ø¹Ø¨ (ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§)
        const player = new THREE.Group();
        scene.add(player);

        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¨Ù…Ù†Ø¸ÙˆØ± Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ø£ÙˆÙ„
        const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.8, 0); // Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„Ø§Ø¹Ø¨
        player.add(camera); // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙƒÙ…ÙƒÙˆÙ‘Ù† ÙØ±Ø¹ÙŠ Ù„Ù„Ø§Ø¹Ø¨

        // Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
        // Ø²ÙŠØ§Ø¯Ø© Ø´Ø¯Ø© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„Ù…Ø­ÙŠØ·Ø© Ù„ØªÙ†Ø§Ø³Ø¨ Ù…Ø¸Ù‡Ø± Ø§Ù„Ù†Ù‡Ø§Ø±
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        // ØªØºÙŠÙŠØ± Ù„ÙˆÙ† Ø¶ÙˆØ¡ Ø§Ù„Ø´Ù…Ø³ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø¨ÙŠØ¶ Ù„Ø¥Ø¶ÙØ§Ø¡ Ø·Ø§Ø¨Ø¹ Ø§Ù„Ù†Ù‡Ø§Ø±
        const sunLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
        sunLight.position.set(100, 200, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048; // Ø²ÙŠØ§Ø¯Ø© Ø¯Ù‚Ø© Ø§Ù„Ø¸Ù„Ø§Ù„
        sunLight.shadow.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500; // Ø²ÙŠØ§Ø¯Ø© Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¸Ù„ Ù„ÙŠÙ†Ø§Ø³Ø¨ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø£ÙƒØ¨Ø±
        scene.add(sunLight);

        // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø±Ø¶ÙŠØ©
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100); // Ø²ÙŠØ§Ø¯Ø© Ø­Ø¬Ù… Ø§Ù„Ø£Ø±Ø¶ÙŠØ©
        // ØªØºÙŠÙŠØ± Ù„ÙˆÙ† Ø§Ù„Ø£Ø±Ø¶ÙŠØ© Ø¥Ù„Ù‰ Ø£Ø®Ø¶Ø± Ø²Ø§Ù‡ÙŠ ÙŠÙ†Ø§Ø³Ø¨ Ø§Ù„Ù†Ù‡Ø§Ø±
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x4CAF50,
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù… Ù„Ù…Ù†Ø¹ Ø®Ø±ÙˆØ¬ Ø§Ù„Ù„Ø§Ø¹Ø¨
        const worldBounds = {
            minX: -450,
            maxX: 450,
            minZ: -450,
            maxZ: 450,
            buffer: 20 // Ù…Ø³Ø§ÙØ© ØªØ®Ø²ÙŠÙ† Ù„Ù„ØªØ­Ø°ÙŠØ± Ù‚Ø¨Ù„ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø­Ø¯ÙˆØ¯
        };

        // Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø¯ÙˆØ¯ Ù…Ø±Ø¦ÙŠØ© Ù„Ù„Ø¹Ø§Ù„Ù…
        function createWorldBoundsVisual() {
            const boundsGeometry = new THREE.BoxGeometry(
                worldBounds.maxX - worldBounds.minX,
                1,
                worldBounds.maxZ - worldBounds.minZ
            );
            const boundsMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true,
                transparent: true,
                opacity: 0.1
            });
            const bounds = new THREE.Mesh(boundsGeometry, boundsMaterial);
            bounds.position.set(
                (worldBounds.maxX + worldBounds.minX) / 2,
                -0.5,
                (worldBounds.maxZ + worldBounds.minZ) / 2
            );
            scene.add(bounds);
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù…
        function checkWorldBounds(position) {
            const warningElement = document.getElementById('worldBoundaryWarning');
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯ Ù…Ø¹ Ù…Ù†Ø·Ù‚Ø© ØªØ®Ø²ÙŠÙ† Ù„Ù„ØªØ­Ø°ÙŠØ±
            if (position.x < worldBounds.minX + worldBounds.buffer || position.x > worldBounds.maxX - worldBounds.buffer || position.z < worldBounds.minZ + worldBounds.buffer || position.z > worldBounds.maxZ - worldBounds.buffer) {
                warningElement.style.display = 'block';
            } else {
                warningElement.style.display = 'none';
            }
            // Ù…Ù†Ø¹ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯ ØªÙ…Ø§Ù…Ø§Ù‹
            if (position.x < worldBounds.minX) return new THREE.Vector3(worldBounds.minX, position.y, position.z);
            if (position.x > worldBounds.maxX) return new THREE.Vector3(worldBounds.maxX, position.y, position.z);
            if (position.z < worldBounds.minZ) return new THREE.Vector3(position.x, position.y, worldBounds.minZ);
            if (position.z > worldBounds.maxZ) return new THREE.Vector3(position.x, position.y, worldBounds.maxZ);
            return position;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø´Ø¬Ø§Ø±
        function createTree(x, z) {
            const treeGroup = new THREE.Group();
            // Ø§Ù„Ø¬Ø°Ø¹
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 6, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);
            // Ø§Ù„Ø£ÙˆØ±Ø§Ù‚
            const leavesGeometry = new THREE.ConeGeometry(3, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({
                color: 0x006400,
                roughness: 0.5
            });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 10;
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            treeGroup.add(leaves);
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return treeGroup;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØª ØºÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø§Ø®ØªØ±Ø§Ù‚
        function createHouse(x, z, width, height, depth, color) {
            const houseGroup = new THREE.Group(); // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØª ÙˆØ§Ù„Ù†ÙˆØ§ÙØ°
            // Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¨ÙŠØª
            const houseGeometry = new THREE.BoxGeometry(width, height, depth);
            const houseMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.8,
                metalness: 0.1
            });
            const house = new THREE.Mesh(houseGeometry, houseMaterial);
            house.position.set(x, height / 2, z);
            house.castShadow = true;
            house.receiveShadow = true;
            houseGroup.add(house);

            // Ø§Ù„Ø³Ù‚Ù
            const roofGeometry = new THREE.ConeGeometry(width * 0.7, width * 0.7, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B0000, // Ù„ÙˆÙ† Ø£Ø­Ù…Ø± Ø¯Ø§ÙƒÙ† Ù„Ù„Ø³Ù‚Ù
                roughness: 0.8,
                metalness: 0.1
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(x, height + width * 0.35, z);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            roof.receiveShadow = true;
            houseGroup.add(roof);

            // Ø¥Ø¶Ø§ÙØ© Ù†ÙˆØ§ÙØ°
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x2C3E50, // Ù„ÙˆÙ† Ø¯Ø§ÙƒÙ† Ù„Ù„Ù†ÙˆØ§ÙØ°
                roughness: 0.5,
                metalness: 0.2
            });
            const windowWidth = width * 0.2;
            const windowHeight = height * 0.2;
            const windowDepth = depth * 0.05;

            // Ù†Ø§ÙØ°Ø© Ø£Ù…Ø§Ù…ÙŠØ©
            const frontWindow1 = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
            frontWindow1.position.set(x - width * 0.25, height / 2, z + depth / 2 + windowDepth / 2);
            houseGroup.add(frontWindow1);
            const frontWindow2 = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
            frontWindow2.position.set(x + width * 0.25, height / 2, z + depth / 2 + windowDepth / 2);
            houseGroup.add(frontWindow2);

            // Ù†Ø§ÙØ°Ø© Ø®Ù„ÙÙŠØ©
            const backWindow1 = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
            backWindow1.position.set(x - width * 0.25, height / 2, z - depth / 2 - windowDepth / 2);
            houseGroup.add(backWindow1);
            const backWindow2 = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth), windowMaterial);
            backWindow2.position.set(x + width * 0.25, height / 2, z - depth / 2 - windowDepth / 2);
            houseGroup.add(backWindow2);

            // Ù†Ø§ÙØ°Ø© Ø¬Ø§Ù†Ø¨ÙŠØ© (ÙŠÙ…ÙŠÙ†)
            const rightWindow1 = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
            rightWindow1.position.set(x + width / 2 + windowDepth / 2, height / 2, z - depth * 0.25);
            houseGroup.add(rightWindow1);
            const rightWindow2 = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
            rightWindow2.position.set(x + width / 2 + windowDepth / 2, height / 2, z + depth * 0.25);
            houseGroup.add(rightWindow2);

            // Ù†Ø§ÙØ°Ø© Ø¬Ø§Ù†Ø¨ÙŠØ© (ÙŠØ³Ø§Ø±)
            const leftWindow1 = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
            leftWindow1.position.set(x - width / 2 - windowDepth / 2, height / 2, z - depth * 0.25);
            houseGroup.add(leftWindow1);
            const leftWindow2 = new THREE.Mesh(new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth), windowMaterial);
            leftWindow2.position.set(x - width / 2 - windowDepth / 2, height / 2, z + depth * 0.25);
            houseGroup.add(leftWindow2);

            scene.add(houseGroup);
            return houseGroup;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ù†ÙØ§ÙŠØ§Øª Ø´Ø±ÙŠØ±Ø©
        function createEvilWaste(x, z, type) {
            const wasteGroup = new THREE.Group();
            let wasteGeometry, wasteMaterial;
            let health, value;

            // Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            const aggressiveColors = [
                0x00FF00, // Ø£Ø®Ø¶Ø±
                0x00BFFF, // Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­
                0x8A2BE2, // Ø£Ø±Ø¬ÙˆØ§Ù†ÙŠ
                0xFF4500, // Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ
                0xFFFF00 // Ø£ØµÙØ±
            ];

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            const sizeFactor = 1 + (round - 1) * 0.5; // ÙŠØ²ÙŠØ¯ Ø§Ù„Ø­Ø¬Ù… Ø¨Ù…Ù‚Ø¯Ø§Ø± 0.5 ÙÙŠ ÙƒÙ„ Ø¬ÙˆÙ„Ø©
            const healthFactor = 1 + (round - 1) * 0.8; // ØªØ²ÙŠØ¯ Ø§Ù„ØµØ­Ø© Ø¨Ù…Ù‚Ø¯Ø§Ø± 80% ÙÙŠ ÙƒÙ„ Ø¬ÙˆÙ„Ø©

            if (type === 'giant') {
                wasteGeometry = new THREE.IcosahedronGeometry(4, 0);
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: 0x990000,
                    roughness: 0.6,
                    metalness: 0.2
                });
                health = 500;
                value = 50;
            } else if (type === 'plastic') {
                wasteGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff9900,
                    roughness: 0.7
                });
                health = 100;
                value = 5;
            } else if (type === 'paper') {
                wasteGeometry = new THREE.BoxGeometry(2, 2, 2);
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffff00,
                    roughness: 0.8
                });
                health = 80;
                value = 10;
            } else if (type === 'organic') {
                wasteGeometry = new THREE.ConeGeometry(1.5, 3, 8);
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: 0xcc0000,
                    roughness: 0.6
                });
                health = 120;
                value = 15;
            } else if (type === 'aggressive') {
                // Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ© - Ø¬Ø¯ÙŠØ¯Ø© ÙˆØ³Ø±ÙŠØ¹Ø©
                // **ØªØ¹Ø¯ÙŠÙ„: ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø­Ø¬Ù…**
                wasteGeometry = new THREE.TetrahedronGeometry(2 * sizeFactor, 0);
                const randomColor = aggressiveColors[Math.floor(Math.random() * aggressiveColors.length)];
                wasteMaterial = new THREE.MeshStandardMaterial({
                    color: randomColor,
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: randomColor,
                    emissiveIntensity: 0.5
                });
                // **ØªØ¹Ø¯ÙŠÙ„: ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„ØµØ­Ø©**
                health = 150 * healthFactor;
                value = 25;
            }

            const waste = new THREE.Mesh(wasteGeometry, wasteMaterial);
            waste.castShadow = true;
            waste.receiveShadow = true;
            wasteGroup.add(waste);

            // Ø¹ÙŠÙˆÙ† Ø´Ø±ÙŠØ±Ø©
            const eyeGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff
            });
            const eyeScale = type === 'giant' || type === 'aggressive' ? 1.5 : 1;
            const eyeOffset = type === 'giant' || type === 'aggressive' ? 2 : 0.5;
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.scale.set(eyeScale, eyeScale, eyeScale);
            leftEye.position.set(-eyeOffset, 0.3 * eyeScale, type === 'plastic' ? 1.4 : 1.2 * eyeScale);
            wasteGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.scale.set(eyeScale, eyeScale, eyeScale);
            rightEye.position.set(eyeOffset, 0.3 * eyeScale, type === 'plastic' ? 1.4 : 1.2 * eyeScale);
            wasteGroup.add(rightEye);

            // Ø¨Ø¤Ø¨Ø¤ Ø§Ù„Ø¹ÙŠÙ†
            const pupilGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const pupilMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            const pupilScale = type === 'giant' || type === 'aggressive' ? 1.5 : 1;
            const pupilOffset = type === 'giant' || type === 'aggressive' ? 2 : 0.5;
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.scale.set(pupilScale, pupilScale, pupilScale);
            leftPupil.position.set(-pupilOffset, 0.3 * pupilScale, (type === 'plastic' ? 1.4 : 1.2) * pupilScale + 0.3);
            wasteGroup.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.scale.set(pupilScale, pupilScale, pupilScale);
            rightPupil.position.set(pupilOffset, 0.3 * pupilScale, (type === 'plastic' ? 1.4 : 1.2) * pupilScale + 0.3);
            wasteGroup.add(rightPupil);

            // ÙÙ… Ø´Ø±ÙŠØ±
            const mouthGeometry = new THREE.TorusGeometry(0.8, 0.15, 8, 18, Math.PI);
            const mouthMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            const mouthScale = type === 'giant' || type === 'aggressive' ? 2 : 1;
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.scale.set(mouthScale, mouthScale, mouthScale);
            mouth.position.set(0, -0.5 * mouthScale, (type === 'plastic' ? 1.4 : 1.2) * mouthScale);
            mouth.rotation.x = Math.PI / 2;
            wasteGroup.add(mouth);

            // ØªØ£Ø«ÙŠØ± Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©
            if (type === 'aggressive') {
                // ØªØ£Ø«ÙŠØ± ØªÙˆÙ‡Ø¬
                const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: wasteMaterial.color, // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ÙØ³ Ù„ÙˆÙ† Ø§Ù„Ù…Ø§Ø¯Ø©
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                wasteGroup.add(glow);

                // ØªØ£Ø«ÙŠØ± Ø¬Ø³ÙŠÙ…Ø§Øª Ø­ÙˆÙ„ Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©
                const particleCount = 8;
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: aggressiveColors[Math.floor(Math.random() * aggressiveColors.length)],
                        transparent: true,
                        opacity: 0.7
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 3;
                    particle.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * 0.5,
                        Math.sin(angle) * radius
                    );
                    particle.userData = {
                        angle: angle,
                        speed: 0.05
                    };
                    wasteGroup.add(particle);
                }
            }

            wasteGroup.position.set(x, type === 'giant' ? 4 : 2, z);

            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©
            const isAggressive = type === 'aggressive';
            // **Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§:** ØªÙ… ØªØ®ÙÙŠØ¶ Ø³Ø±Ø¹Ø© Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø¨Ø´ÙƒÙ„ Ø·ÙÙŠÙ
            // ÙƒØ§Ù†Øª Ø§Ù„Ø³Ø±Ø¹Ø© Ù„Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© (Math.random() * 0.05 + 0.02)
            // Ø§Ù„Ø¢Ù† Ø£ØµØ¨Ø­Øª (Math.random() * 0.04 + 0.01)
            // ÙˆÙƒØ§Ù†Øª Ø§Ù„Ø³Ø±Ø¹Ø© Ù„Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ© 0.15
            // Ø§Ù„Ø¢Ù† Ø£ØµØ¨Ø­Øª 0.12
            const baseSpeed = isAggressive ? 0.12 : (Math.random() * 0.04 + 0.01);
            wasteGroup.userData = {
                type,
                health,
                maxHealth: health,
                speed: baseSpeed,
                value,
                targetTree: null,
                isAggressive: isAggressive,
                isChasing: false,
                detectionRange: isAggressive ? 30 : 0,
                attackRange: isAggressive ? 5 : 0,
                attackDamage: isAggressive ? 10 : 0,
                lastAttackTime: 0
            };

            if (type === 'aggressive') {
                let minDistance = Infinity;
                let closestTree = null;
                trees.forEach(tree => {
                    const treePos = new THREE.Vector3();
                    tree.getWorldPosition(treePos);
                    const distance = wasteGroup.position.distanceTo(treePos);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestTree = tree;
                    }
                });
                wasteGroup.userData.targetTree = closestTree;
            }
            scene.add(wasteGroup);
            return wasteGroup;
        }

        // **Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©: Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ù‚Ø© Ù†ÙØ§ÙŠØ§Øª**
        function createWasteProjectile(startPos) {
            const projectileGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                blending: THREE.AdditiveBlending
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(startPos);
            projectile.userData = {
                speed: 1.0,
                damage: 10,
                createdAt: Date.now()
            };
            scene.add(projectile);
            return projectile;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù…Ù„Ø© (Ù†Ø³Ø®Ø© Ù…Ø¹Ø¯Ù„Ø©)
        function createCoin(x, z, value) {
            const coinGroup = new THREE.Group();
            // Ø§Ù„Ø¹Ù…Ù„Ø©
            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… MeshBasicMaterial Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† MeshStandardMaterial
            const coinMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700, // Ù„ÙˆÙ† Ø°Ù‡Ø¨ÙŠ
                transparent: true,
                opacity: 1
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.x = Math.PI / 2;
            coinGroup.add(coin);

            // Ø¥Ø¶Ø§ÙØ© Ù‡Ø§Ù„Ø© Ø°Ù‡Ø¨ÙŠØ© Ø­ÙˆÙ„ Ø§Ù„Ø¹Ù…Ù„Ø©
            const haloGeometry = new THREE.RingGeometry(0.6, 0.8, 32);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.rotation.x = -Math.PI / 2;
            halo.position.y = 0.05;
            coinGroup.add(halo);

            // ØªØ£Ø«ÙŠØ± Ø¨Ø±ÙŠÙ‚ (Ø¨Ø¯ÙŠÙ„ Ø¹Ù† Ø§Ù„Ø¶ÙˆØ¡ Ø§Ù„Ø°ÙŠ Ù‚Ø¯ ÙŠØ³Ø¨Ø¨ Ù…Ø´Ø§ÙƒÙ„)
            const sparkleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const sparkleMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8
            });

            // Ø¥Ø¶Ø§ÙØ© Ø¹Ø¯Ø© Ø¨Ø±ÙŠÙ‚Ø§Øª Ø­ÙˆÙ„ Ø§Ù„Ø¹Ù…Ù„Ø©
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                sparkle.position.set(
                    Math.cos(angle) * 0.7,
                    0.1,
                    Math.sin(angle) * 0.7
                );
                sparkle.userData = {
                    angle: angle
                };
                coinGroup.add(sparkle);
            }

            coinGroup.position.set(x, 1, z);
            coinGroup.userData = {
                value,
                spinSpeed: 0.02,
                sparkleSpeed: 0.05
            };
            scene.add(coinGroup);
            return coinGroup;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¹Ø§Ø¹ Ù„ÙŠØ²Ø± (Ø­Ø¬Ù… Ø£ÙƒØ¨Ø±)
        function createLaserBeam(start, end, isCharged) {
            const distance = start.distanceTo(end);
            // Ø²ÙŠØ§Ø¯Ø© Ø­Ø¬Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹ Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø·Ù„Ù‚Ø©
            const beamRadius = isCharged ? 1.5 : 0.8;
            const beamGeometry = new THREE.CylinderGeometry(beamRadius, beamRadius, distance, 8);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: isCharged ? 0x00FFFF : 0xff0000,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            const center = new THREE.Vector3().lerpVectors(start, end, 0.5);
            beam.position.copy(center);
            beam.lookAt(end);
            beam.rotation.x += Math.PI / 2;
            scene.add(beam);
            return {
                beam,
                createdAt: Date.now()
            };
        }

        // Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø§Ù†ÙØ¬Ø§Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
        function createExplosionEffect(position, isCharged) {
            const particles = [];
            const particleCount = isCharged ? 50 : 20;
            const colors = isCharged ? [0x00FFFF, 0x00BFFF, 0x00F8FF] : [0xff0000, 0xff5500, 0xffff00];
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(isCharged ? 0.4 : 0.2, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 0.1 + 0.05;
                particle.userData = {
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 0.1,
                        Math.sin(angle) * speed
                    ),
                    createdAt: Date.now()
                };
                scene.add(particle);
                particles.push(particle);
            }
            return particles;
        }

        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
        const trees = [];
        const wastes = [];
        const laserBeams = [];
        const coins = [];
        const effects = [];
        const houses = []; // Ù…ØµÙÙˆÙØ© Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨ÙŠÙˆØª
        const wasteProjectiles = []; // **Ø¬Ø¯ÙŠØ¯: Ø·Ù„Ù‚Ø§Øª Ø§Ù„Ù†ÙØ§ÙŠØ§Øª**
        // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
        let score = 0;
        let coinsCollected = 0;
        let level = 1;
        let round = 1;
        let gameOver = false;
        let gameStarted = false;
        let isRoundTransition = false;
        let playerHealth = 100; // **Ø¬Ø¯ÙŠØ¯: ØµØ­Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨**
        const maxPlayerHealth = 100; // **Ø¬Ø¯ÙŠØ¯: Ø£Ù‚ØµÙ‰ ØµØ­Ø© Ù„Ù„Ø§Ø¹Ø¨**
        // Ù…ØªØºÙŠØ±Ø§Øª Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù„ÙŠØ²Ø±
        let isCharging = false;
        let chargeStartTime = 0;
        const maxChargeTime = 2000; // 2 Ø«Ø§Ù†ÙŠØ© Ù„Ù„Ø´Ø­Ù† Ø§Ù„ÙƒØ§Ù…Ù„
        const normalShotCooldown = 200; // ÙˆÙ‚Øª Ø§Ù„ØªØ¨Ø±ÙŠØ¯ Ù„Ù„Ø·Ù„Ù‚Ø© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
        let lastShotTime = 0;
        // Ù…ØªØºÙŠØ±Ø§Øª Ø­Ø±ÙƒØ© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø­Ø³Ù†Ø©
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let playerSpeed = 5.0;
        // ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø­Ø±ÙƒØ©: Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØ³Ø§Ø±Ø¹ ÙˆØ§Ù„ØªØ¨Ø§Ø·Ø¤
        let acceleration = 0.2;
        let deceleration = 0.9;
        let maxSpeed = 5.0;
        let velocity = new THREE.Vector3();
        // Ù…ØªØºÙŠØ±Ø§Øª Ø¯ÙˆØ±Ø§Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ù…Ø­Ø³Ù†Ø©
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let previousTouchX = 0;
        let previousTouchY = 0;
        const mouseSensitivity = 0.002;
        const touchSensitivity = 0.003;
        // --- Ø¥Ø¶Ø§ÙØ© Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯ ---
        let cameraTouchId = null;
        const buttonTouchIds = new Map();
        // ------------------------------------------
        // Ù…ØªØºÙŠØ±Ø§Øª Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø´Ø¬Ø§Ø±
        let totalTrees = 0;

        // Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const startScreen = document.getElementById('startScreen');
        const startGameBtn = document.getElementById('startGameBtn');
        const infoPanel = document.getElementById('infoPanel');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const coinsDisplay = document.getElementById('coinsDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const wasteCount = document.getElementById('wasteCount');
        const coinsCount = document.getElementById('coinsCount');
        const aggressiveCount = document.getElementById('aggressiveCount');
        const gameOverPanel = document.getElementById('gameOverPanel');
        const finalScore = document.getElementById('finalScore');
        finalScore.textContent = "0";
        const finalCoins = document.getElementById('finalCoins');
        finalCoins.textContent = "0";
        const restartBtn = document.getElementById('restartBtn');
        const shootBtn = document.getElementById('shootBtn');
        const laserSight = document.getElementById('laserSight');
        const movementControls = document.getElementById('movementControls');
        const roundIndicator = document.getElementById('roundIndicator');
        const nextRoundBtn = document.getElementById('nextRoundBtn');
        const totalTreesDisplay = document.getElementById('totalTreesDisplay');
        const remainingTreesDisplay = document.getElementById('remainingTreesDisplay');
        const treeStatsDisplay = document.getElementById('treeStatsDisplay');
        const chargeIndicator = document.getElementById('chargeIndicator');
        const chargeBar = document.getElementById('chargeBar');
        const worldBoundaryWarning = document.getElementById('worldBoundaryWarning');
        const roundTransition = document.getElementById('roundTransition');
        const roundMessage = document.getElementById('roundMessage');
        const aggressiveWarning = document.getElementById('aggressiveWarning');
        const healthIndicator = document.getElementById('healthIndicator'); // **Ø¬Ø¯ÙŠØ¯**
        const healthBar = document.getElementById('healthBar'); // **Ø¬Ø¯ÙŠØ¯**

        // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ©
        const upBtn = document.getElementById('upBtn');
        const downBtn = document.getElementById('downBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');

        // Ù…ØªØºÙŠØ±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø£Ø³Ø¦Ù„Ø©
        const questionPanel = document.getElementById('questionPanel');
        const questionText = document.getElementById('questionText');
        const optionsContainer = document.getElementById('optionsContainer');
        let isGameFrozen = false;
        let gameLoopId;

        // Ù…ØµÙÙˆÙØ© Ù„ØªØ®Ø²ÙŠÙ† ØµÙ†Ø§Ø¯ÙŠÙ‚ Ø§Ù„ÙƒÙ†Ø²
        const treasureBoxes = [];

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø´Ø¬Ø§Ø± Ù„Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        function spawnNewTrees() {
            // **Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§:**
            // Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø´Ø¬Ø§Ø± ÙŠØ¨Ø¯Ø£ Ù…Ù† 20 ÙÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ø«Ù… ÙŠØªÙ†Ø§Ù‚Øµ Ø¨Ù…Ù‚Ø¯Ø§Ø± 2 ÙÙŠ ÙƒÙ„ Ø¬ÙˆÙ„Ø©
            const initialTrees = 20;
            const treeDecrease = 2;
            const currentTreeCount = Math.max(5, initialTrees - (round - 1) * treeDecrease); // Ù„Ø§ ÙŠÙ‚Ù„ Ø¹Ù† 5 Ø£Ø´Ø¬Ø§Ø±
            totalTrees = currentTreeCount;
            for (let i = 0; i < currentTreeCount; i++) {
                // ØªÙˆØ³ÙŠØ¹ Ù†Ø·Ø§Ù‚ Ø¸Ù‡ÙˆØ± Ø§Ù„Ø£Ø´Ø¬Ø§Ø± Ù„ÙŠÙ†Ø§Ø³Ø¨ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø£ÙƒØ¨Ø±
                const treeX = Math.random() * 900 - 450;
                const treeZ = Math.random() * 900 - 450;
                trees.push(createTree(treeX, treeZ));
            }
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ù†ÙØ§ÙŠØ§Øª Ù„Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        function spawnWavesForRound() {
            // **Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§:**
            // Ø¹Ø¯Ø¯ Ø§Ù„Ù†ÙØ§ÙŠØ§Øª ÙŠØ¨Ø¯Ø£ Ù…Ù† 10 ÙˆÙŠØ²ÙŠØ¯ Ø¨Ù…Ù‚Ø¯Ø§Ø± 5 ÙƒÙ„ Ø¬ÙˆÙ„Ø©
            const currentWasteCount = 10 + (round - 1) * 5;
            for (let i = 0; i < currentWasteCount; i++) {
                let type;
                // **ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„**: Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù†Ø®ØªØ§Ø± Ø§Ù„Ù†ÙˆØ¹ 'aggressive'
                type = 'aggressive';
                // ØªÙˆØ³ÙŠØ¹ Ù†Ø·Ø§Ù‚ Ø¸Ù‡ÙˆØ± Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ù„ÙŠÙ†Ø§Ø³Ø¨ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø£ÙƒØ¨Ø±
                const wasteX = Math.random() * 900 - 450;
                const wasteZ = Math.random() * 900 - 450;
                wastes.push(createEvilWaste(wasteX, wasteZ, type));
            }
            // **Ø§Ù„ØªØºÙŠÙŠØ± Ù‡Ù†Ø§:** Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ ØµÙ†Ø§Ø¯ÙŠÙ‚ Ø§Ù„ÙƒÙ†Ø² ÙÙŠ ÙƒÙ„ Ø¬ÙˆÙ„Ø©
            const treasureBoxCount = 5 + round * 2; // ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 7 ØµÙ†Ø§Ø¯ÙŠÙ‚ ÙˆÙŠØ²ÙŠØ¯ 2 ÙÙŠ ÙƒÙ„ Ø¬ÙˆÙ„Ø©
            for (let i = 0; i < treasureBoxCount; i++) {
                const boxX = Math.random() * 800 - 400;
                const boxZ = Math.random() * 800 - 400;
                treasureBoxes.push(createHealthBox(boxX, boxZ));
            }
            updateUI();
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØª ÙÙŠ Ø£Ù…Ø§ÙƒÙ† Ø«Ø§Ø¨ØªØ© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
        function spawnHouses() {
            const houseColors = [0x4B371C, 0xA0522D, 0xD2B48C, 0xF5F5DC, 0xCD5C5C, 0x87CEFA];
            const houseCount = 15; // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙŠÙˆØª
            for (let i = 0; i < houseCount; i++) {
                const color = houseColors[Math.floor(Math.random() * houseColors.length)];
                const houseX = Math.random() * 800 - 400;
                const houseZ = Math.random() * 800 - 400;
                houses.push(createHouse(houseX, houseZ, 20, 10, 20, color));
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¥Ù†Ø´Ø§Ø¡ ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„ØµØ­Ø© (Ø§Ù„ÙƒÙ†Ø²)
        function createHealthBox(x, z) {
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„ØªØ¬Ù…ÙŠØ¹ Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚
            const boxGroup = new THREE.Group();
            // Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© (Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø²Ø±Ù‚)
            const boxBaseGeometry = new THREE.BoxGeometry(2, 1.5, 2);
            const boxBaseMaterial = new THREE.MeshStandardMaterial({
                color: 0xD2B48C, // ğŸ¨ Ù„ÙˆÙ† Ø¨Ù†ÙŠ ÙØ§ØªØ­
                roughness: 0.6,
                metalness: 0.3
            });
            const boxBase = new THREE.Mesh(boxBaseGeometry, boxBaseMaterial);
            boxBase.position.y = 0.75;
            boxBase.castShadow = true;
            boxBase.receiveShadow = true;
            boxGroup.add(boxBase);

            // Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø°Ù‡Ø¨ÙŠ
            const goldBandGeometry = new THREE.BoxGeometry(2.2, 0.3, 2.2);
            const goldBandMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700, // Ù„ÙˆÙ† Ø°Ù‡Ø¨ÙŠ
                roughness: 0.2,
                metalness: 0.9
            });
            const goldBand = new THREE.Mesh(goldBandGeometry, goldBandMaterial);
            goldBand.position.y = 1.6;
            goldBand.castShadow = true;
            goldBand.receiveShadow = true;
            boxGroup.add(goldBand);

            // Ø±Ù…Ø² Ø§Ù„ØµÙ„ÙŠØ¨ Ø§Ù„Ø£Ø­Ù…Ø± (Ø±Ù…Ø² Ø§Ù„ØµØ­Ø©)
            const crossGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.2);
            const crossMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000 // Ù„ÙˆÙ† Ø£Ø­Ù…Ø±
            });
            const crossHorizontal = new THREE.Mesh(crossGeometry, crossMaterial);
            crossHorizontal.position.set(0, 1.6, 1.1);
            const crossVertical = new THREE.Mesh(crossGeometry, crossMaterial);
            crossVertical.rotation.y = Math.PI / 2;
            crossVertical.position.set(0, 1.6, 1.1);
            boxGroup.add(crossHorizontal);
            boxGroup.add(crossVertical);

            // ÙˆØ¶Ø¹ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚ ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯
            boxGroup.position.set(x, 0, z);
            scene.add(boxGroup);

            // Ø¥Ø¶Ø§ÙØ© Ø®ØµØ§Ø¦Øµ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ù…ØªØ§Ø¨Ø¹ØªÙ‡Ø§
            boxGroup.userData = {
                isHealthBox: true
            };
            return boxGroup;
        }

        function updateUI() {
            scoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
            coinsDisplay.textContent = `Ø§Ù„Ù†Ù‚ÙˆØ¯: ${coinsCollected}`;
            levelDisplay.textContent = level;
            wasteCount.textContent = wastes.length;
            coinsCount.textContent = coinsCollected;
            // Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©
            const aggressiveWastes = wastes.filter(w => w.userData.isAggressive).length;
            aggressiveCount.textContent = aggressiveWastes;
            roundIndicator.textContent = `Ø§Ù„Ø¬ÙˆÙ„Ø©: ${round}`;
            totalTreesDisplay.textContent = totalTrees;
            remainingTreesDisplay.textContent = trees.length;
            // **Ø¬Ø¯ÙŠØ¯: ØªØ­Ø¯ÙŠØ« Ø´Ø±ÙŠØ· Ø§Ù„ØµØ­Ø©**
            const healthPercentage = (playerHealth / maxPlayerHealth) * 100;
            healthBar.style.width = `${healthPercentage}%`;
            if (wastes.length === 0 && !gameOver && !isRoundTransition) {
                nextRoundBtn.style.display = 'block';
                nextRoundBtn.disabled = false;
            } else {
                nextRoundBtn.style.display = 'none';
            }
        }

        function nextRound() {
            isRoundTransition = true;
            nextRoundBtn.disabled = true;
            nextRoundBtn.style.display = 'none';
            roundMessage.textContent = `Ø§Ù„Ø¬ÙˆÙ„Ø© ${round + 1}`;
            roundTransition.classList.add('active');

            setTimeout(() => {
                round++;
                wastes.forEach(waste => scene.remove(waste));
                wastes.length = 0;
                coins.forEach(coin => scene.remove(coin));
                coins.length = 0;
                wasteProjectiles.forEach(p => scene.remove(p)); // **Ø¬Ø¯ÙŠØ¯**
                wasteProjectiles.length = 0; // **Ø¬Ø¯ÙŠØ¯**
                effects.forEach(effect => {
                    effect.particles.forEach(particle => scene.remove(particle));
                });
                effects.length = 0;

                // ØªØ­Ø¯ÙŠØ«: Ø¥Ø²Ø§Ù„Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø´Ø¬Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§ Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¹Ø¯Ø¯
                trees.forEach(tree => scene.remove(tree));
                trees.length = 0;

                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØµÙ†Ø§Ø¯ÙŠÙ‚ Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                treasureBoxes.forEach(box => scene.remove(box));
                treasureBoxes.length = 0;

                spawnNewTrees(); // ÙˆØ¸ÙŠÙØ© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø´Ø¬Ø§Ø± Ù„ÙƒÙ„ Ø¬ÙˆÙ„Ø©
                spawnWavesForRound();

                roundTransition.classList.remove('active');
                isRoundTransition = false;
                updateUI();
            }, 2000);
        }

        function moveWastes() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);
            let isPlayerInDanger = false;

            wastes.forEach(waste => {
                const wasteData = waste.userData;
                const wastePos = new THREE.Vector3();
                waste.getWorldPosition(wastePos);

                // ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª Ø­ÙˆÙ„ Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©
                if (wasteData.isAggressive) {
                    waste.children.forEach(child => {
                        if (child.userData && child.userData.angle !== undefined) {
                            child.userData.angle += 0.05;
                            const radius = 3;
                            child.position.set(
                                Math.cos(child.userData.angle) * radius,
                                Math.sin(child.userData.angle) * 0.5,
                                Math.sin(child.userData.angle) * radius
                            );
                        }
                    });
                }

                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ø³Ø§ÙØ© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù„Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©
                const distanceToPlayer = wastePos.distanceTo(playerPos);
                if (wasteData.isAggressive && distanceToPlayer < wasteData.detectionRange) {
                    wasteData.isChasing = true;
                    isPlayerInDanger = true;

                    // Ù…Ø·Ø§Ø±Ø¯Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨
                    const direction = new THREE.Vector3().subVectors(playerPos, wastePos).normalize();
                    const newPosition = wastePos.clone().add(direction.multiplyScalar(wasteData.speed * 1.5)); // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø±Ø¹Ø© Ø¹Ù†Ø¯ Ø§Ù„Ù…Ø·Ø§Ø±Ø¯Ø©

                    let collisionDetected = false;
                    const wasteBoundingSphere = new THREE.Sphere(newPosition, 2);
                    for (const house of houses) {
                        house.children.forEach(child => {
                            const childBox = new THREE.Box3().setFromObject(child);
                            if (childBox.intersectsSphere(wasteBoundingSphere)) {
                                collisionDetected = true;
                            }
                        });
                        if (collisionDetected) break;
                    }
                    if (!collisionDetected) {
                        waste.position.x = newPosition.x;
                        waste.position.z = newPosition.z;
                    }
                    waste.lookAt(
                        waste.position.x + direction.x,
                        waste.position.y,
                        waste.position.z + direction.z
                    );

                    // **ØªØ¹Ø¯ÙŠÙ„: Ø§Ù„Ø¢Ù† Ø³ØªØ·Ù„Ù‚ Ø§Ù„Ù†Ø§Ø± Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ØµØ­Ø© Ù…Ø¨Ø§Ø´Ø±Ø©**
                    if (distanceToPlayer < wasteData.attackRange) {
                        if (Date.now() - wasteData.lastAttackTime > 1000) { // ÙˆÙ‚Øª ØªØ¨Ø±ÙŠØ¯ 1 Ø«Ø§Ù†ÙŠØ©
                            const projectile = createWasteProjectile(wastePos);
                            const projDirection = new THREE.Vector3().subVectors(playerPos, wastePos).normalize();
                            projectile.userData.direction = projDirection;
                            projectile.userData.damage = wasteData.attackDamage; // Ø¶Ø±Ø± Ø§Ù„Ø·Ù„Ù‚Ø© Ù‡Ùˆ Ø¶Ø±Ø± Ø§Ù„Ù†ÙØ§ÙŠØ§Øª
                            wasteProjectiles.push(projectile);
                            wasteData.lastAttackTime = Date.now();
                            playMonsterAttackSound(); // ØªØ´ØºÙŠÙ„ ØµÙˆØª Ù‡Ø¬ÙˆÙ… Ø§Ù„ÙˆØ­Ø´
                        }
                    }

                } else if (!wasteData.targetTree || !trees.includes(wasteData.targetTree)) {
                    wasteData.isChasing = false;
                    let minDistance = Infinity;
                    let targetTree = null;
                    trees.forEach(tree => {
                        const treePos = new THREE.Vector3();
                        tree.getWorldPosition(treePos);
                        const distance = wastePos.distanceTo(treePos);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestTree = tree;
                        }
                    });

                    // Ù„Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©ØŒ Ø§Ø®ØªÙŠØ§Ø± Ù‡Ø¯Ù Ø¹Ø´ÙˆØ§Ø¦ÙŠ ÙˆÙ„ÙŠØ³ Ø§Ù„Ø£Ù‚Ø±Ø¨ ÙÙ‚Ø·
                    if (wasteData.isAggressive && trees.length > 0) {
                        wasteData.targetTree = trees[Math.floor(Math.random() * trees.length)];
                    } else {
                        wasteData.targetTree = targetTree;
                    }
                }

                if (wasteData.targetTree && !wasteData.isChasing) {
                    const treePos = new THREE.Vector3();
                    wasteData.targetTree.getWorldPosition(treePos);
                    const direction = new THREE.Vector3().subVectors(treePos, wastePos).normalize();
                    const newPosition = wastePos.clone().add(direction.multiplyScalar(wasteData.speed));

                    let collisionDetected = false;
                    const wasteBoundingSphere = new THREE.Sphere(newPosition, 2);
                    for (const house of houses) {
                        house.children.forEach(child => {
                            const childBox = new THREE.Box3().setFromObject(child);
                            if (childBox.intersectsSphere(wasteBoundingSphere)) {
                                collisionDetected = true;
                                // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ù„ØªÙØ§Ù Ø­ÙˆÙ„ Ø§Ù„Ø¹Ø§Ø¦Ù‚
                                const avoidanceDirection = new THREE.Vector3(-direction.z, 0, direction.x);
                                newPosition.add(avoidanceDirection.multiplyScalar(wasteData.speed * 2));
                            }
                        });
                        if (collisionDetected) break;
                    }

                    if (!collisionDetected) {
                        waste.position.x = newPosition.x;
                        waste.position.z = newPosition.z;
                    } else {
                        wasteData.targetTree = null;
                    }
                    waste.lookAt(
                        waste.position.x + direction.x,
                        waste.position.y,
                        waste.position.z + direction.z
                    );

                    const distance = wastePos.distanceTo(treePos);
                    // Ù‡Ù†Ø§ ÙŠØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙƒÙˆØ¯: Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ù„Ù… ØªØ¹Ø¯ ØªØ®ØªÙÙŠ Ø¨Ø¹Ø¯ Ø§ØµØ·Ø¯Ø§Ù…Ù‡Ø§ Ø¨Ø§Ù„Ø£Ø´Ø¬Ø§Ø±
                    if (distance < 2.5) {
                        const targetTree = wasteData.targetTree;
                        if (targetTree) {
                            // Ù†Ù‚ÙˆÙ… Ø¨Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø´Ø¬Ø±Ø© ÙÙ‚Ø·
                            scene.remove(targetTree);
                            const treeIndex = trees.indexOf(targetTree);
                            if (treeIndex > -1) {
                                trees.splice(treeIndex, 1);
                            }
                            // Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù†ÙØ§ÙŠØ©ØŒ Ù†Ø¬Ø¹Ù„Ù‡Ø§ ØªØ¨Ø­Ø« Ø¹Ù† Ù‡Ø¯Ù Ø¬Ø¯ÙŠØ¯
                            wasteData.targetTree = null;
                        }
                    }
                }
            });

            // Ø¹Ø±Ø¶ ØªØ­Ø°ÙŠØ± Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙŠ Ø®Ø·Ø±
            if (isPlayerInDanger) {
                aggressiveWarning.style.display = 'block';
            } else {
                aggressiveWarning.style.display = 'none';
            }
        }

        // **Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©: ØªØ­Ø¯ÙŠØ« Ø·Ù„Ù‚Ø§Øª Ø§Ù„Ù†ÙØ§ÙŠØ§Øª ÙˆØ§ÙƒØªØ´Ø§Ù Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ù„Ø§Ø¹Ø¨**
        function updateWasteProjectiles() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);
            for (let i = wasteProjectiles.length - 1; i >= 0; i--) {
                const projectile = wasteProjectiles[i];
                // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø·Ù„Ù‚Ø© ÙÙŠ Ø§ØªØ¬Ø§Ù‡Ù‡Ø§
                projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.speed));

                // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¨Ø¹ÙŠØ¯Ø© Ø¬Ø¯Ø§Ù‹ØŒ Ù‚Ù… Ø¨Ø¥Ø²Ø§Ù„ØªÙ‡Ø§
                const distanceToOrigin = projectile.position.distanceTo(new THREE.Vector3(0, 0, 0));
                if (distanceToOrigin > 1000) {
                    scene.remove(projectile);
                    wasteProjectiles.splice(i, 1);
                    continue;
                }

                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ù„Ø§Ø¹Ø¨
                const distanceToPlayer = projectile.position.distanceTo(playerPos);
                if (distanceToPlayer < 2) { // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø³Ø§ÙØ© Ø£Ù‚Ù„ Ù…Ù† 2ØŒ ØªØ¹ØªØ¨Ø± Ø§ØµØ·Ø¯Ø§Ù…Ø§Ù‹
                    playerHealth -= projectile.userData.damage;
                    updateUI();
                    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ù‚Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
                    scene.remove(projectile);
                    wasteProjectiles.splice(i, 1);
                    // **Ø¬Ø¯ÙŠØ¯: Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø¨ØµØ±ÙŠ Ø¹Ù†Ø¯ Ø¥ØµØ§Ø¨Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨**
                    effects.push({
                        particles: createExplosionEffect(playerPos, false),
                        createdAt: Date.now()
                    });
                }
            }
        }

        // Ø¥Ø·Ù„Ø§Ù‚ Ù„ÙŠØ²Ø±
        function shootLaser(isCharged) {
            if (!gameStarted || gameOver || isRoundTransition) return;
            const currentTime = Date.now();
            if (!isCharged && currentTime - lastShotTime < normalShotCooldown) return;
            lastShotTime = currentTime;

            // ** ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª Ø¹Ù†Ø¯ Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø± **
            if (isCharged) {
                playChargedShotSound();
            } else {
                playShotSound();
            }

            // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¹Ø§Ø¹ ØªØµÙˆÙŠØ¨ Ù…Ù† Ù…Ø±ÙƒØ² Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            // Ù†Ù‚Ø·Ø© ØªØ£Ø«ÙŠØ± Ø§Ù„Ø·Ù„Ù‚Ø©
            let impactPoint;
            const intersects = raycaster.intersectObjects(
                wastes.map(w => w.children[0]), true
            );
            if (intersects.length > 0) {
                // Ø¥Ø°Ø§ Ø§ØµØ·Ø¯Ù… Ø§Ù„Ù„ÙŠØ²Ø± Ø¨Ù†ÙØ§ÙŠØ©ØŒ ÙØ¥Ù† Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ£Ø«ÙŠØ± Ù‡ÙŠ Ù†Ù‚Ø·Ø© Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
                impactPoint = intersects[0].point;
            } else {
                // Ø¥Ø°Ø§ Ù„Ù… ÙŠØµØ·Ø¯Ù… Ø§Ù„Ù„ÙŠØ²Ø± Ø¨Ø£ÙŠ Ù†ÙØ§ÙŠØ©ØŒ ÙØ¥Ù† Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ£Ø«ÙŠØ± ØªÙƒÙˆÙ† Ø¨Ø¹ÙŠØ¯Ø© ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø°ÙŠ ÙŠØ´ÙŠØ± Ø¥Ù„ÙŠÙ‡ Ø§Ù„Ù„ÙŠØ²Ø±
                impactPoint = raycaster.ray.at(100);
            }

            // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¹Ø§Ø¹ Ø§Ù„Ù„ÙŠØ²Ø±
            laserBeams.push(createLaserBeam(raycaster.ray.origin, impactPoint, isCharged));

            // Ø²ÙŠØ§Ø¯Ø© Ù‚ÙˆØ© Ø§Ù„Ø·Ù„Ù‚Ø© Ø§Ù„Ø®Ø§Ø±Ù‚Ø© Ù„ØªØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø£Ù‚ÙˆÙ‰
            const damage = isCharged ? 250 * round : 50;
            const blastRadius = isCharged ? 10 : 3;
            const wastesToDamage = [];

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø¶Ù…Ù† Ù†Ø·Ø§Ù‚ Ø§Ù„Ø§Ù†ÙØ¬Ø§Ø±
            for (let i = wastes.length - 1; i >= 0; i--) {
                const waste = wastes[i];
                const wastePos = new THREE.Vector3();
                waste.getWorldPosition(wastePos);
                const distance = wastePos.distanceTo(impactPoint);
                if (distance < blastRadius) {
                    wastesToDamage.push(waste);
                }
            }

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¶Ø±Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ù…ØªØ¶Ø±Ø±Ø©
            for (const waste of wastesToDamage) {
                waste.userData.health -= damage;
                if (waste.userData.health <= 0) {
                    scene.remove(waste);
                    const index = wastes.indexOf(waste);
                    if (index > -1) {
                        wastes.splice(index, 1);
                    }
                    coins.push(createCoin(waste.position.x, waste.position.z, waste.userData.value));
                    score += waste.userData.isAggressive ? 25 : 10; // Ù†Ù‚Ø§Ø· Ø£ÙƒØ«Ø± Ù„Ù„Ù†ÙØ§ÙŠØ§Øª Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©
                    playMonsterExplosionSound(); // ØªØ´ØºÙŠÙ„ ØµÙˆØª ØªÙØ¬ÙŠØ± Ø§Ù„ÙˆØ­ÙˆØ´
                }
            }

            // Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø§Ù†ÙØ¬Ø§Ø± Ø¹Ù†Ø¯ Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ£Ø«ÙŠØ±
            if (wastesToDamage.length > 0) {
                effects.push({
                    particles: createExplosionEffect(impactPoint, isCharged),
                    createdAt: Date.now()
                });
            }

            updateUI();
        }

        // ØªØ­Ø¯ÙŠØ« Ø­Ø±ÙƒØ© Ø§Ù„Ø´Ø¹Ø§Ø¹ Ø§Ù„Ù„ÙŠØ²Ø±ÙŠ
        function updateLaserBeams() {
            const now = Date.now();
            for (let i = laserBeams.length - 1; i >= 0; i--) {
                const beam = laserBeams[i];
                const age = now - beam.createdAt;
                if (age > 100) {
                    scene.remove(beam.beam);
                    laserBeams.splice(i, 1);
                }
            }
        }

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ø¨ØµØ±ÙŠØ©
        function updateEffects() {
            const now = Date.now();
            for (let i = effects.length - 1; i >= 0; i--) {
                const effect = effects[i];
                if (now - effect.createdAt > 500) {
                    effect.particles.forEach(particle => {
                        scene.remove(particle);
                    });
                    effects.splice(i, 1);
                } else {
                    effect.particles.forEach(particle => {
                        particle.position.add(particle.userData.velocity);
                        particle.material.opacity = 0.8 * (1 - (now - effect.createdAt) / 500);
                    });
                }
            }
        }

        // ØªØ¯ÙˆÙŠØ± Ø§Ù„Ù†Ù‚ÙˆØ¯ ÙˆØªØ£Ø«ÙŠØ± Ø§Ù„Ø¨Ø±ÙŠÙ‚ (Ù†Ø³Ø®Ø© Ù…Ø¹Ø¯Ù„Ø©)
        function rotateCoins() {
            coins.forEach(coin => {
                coin.rotation.y += coin.userData.spinSpeed;
                // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¨Ø±ÙŠÙ‚Ø§Øª Ù„Ø¬Ø¹Ù„Ù‡Ø§ ØªØªØ£Ù„Ù‚
                coin.children.forEach(child => {
                    if (child.userData && child.userData.angle !== undefined) {
                        child.userData.angle += coin.userData.sparkleSpeed;
                        child.position.set(
                            Math.cos(child.userData.angle) * 0.7,
                            0.1,
                            Math.sin(child.userData.angle) * 0.7
                        );
                        child.material.opacity = 0.5 + 0.5 * Math.sin(child.userData.angle * 2);
                    }
                });
            });
        }

        // ØªØ­Ø¯ÙŠØ« Ø­Ø±ÙƒØ© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ³Ø§Ø±Ø¹ ÙˆØ§Ù„ØªØ¨Ø§Ø·Ø¤ Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
        function movePlayer() {
            if (isRoundTransition) return;
            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„Ø­Ø±ÙƒØ© Ù…Ù† Ø¯ÙˆØ±Ø§Ù† Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ØŒ ÙˆÙ„ÙŠØ³ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            const direction = new THREE.Vector3();
            player.getWorldDirection(direction);
            const forward = new THREE.Vector3().copy(direction).setY(0).normalize();
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ³Ø§Ø±Ø¹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            if (moveForward) {
                // Ø¹ÙƒØ³ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ©
                velocity.add(forward.multiplyScalar(-acceleration));
            }
            if (moveBackward) {
                // Ø¹ÙƒØ³ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø®Ù„ÙÙŠØ©
                velocity.add(forward.multiplyScalar(acceleration));
            }
            if (moveLeft) {
                velocity.add(right.multiplyScalar(-acceleration));
            }
            if (moveRight) {
                velocity.add(right.multiplyScalar(acceleration));
            }

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø§Ø­ØªÙƒØ§Ùƒ (Ø§Ù„ØªØ¨Ø§Ø·Ø¤)
            velocity.multiplyScalar(deceleration);

            // Ø§Ù„Ø­Ø¯ Ù…Ù† Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù‚ØµÙˆÙ‰
            if (velocity.length() > maxSpeed) {
                velocity.normalize().multiplyScalar(maxSpeed);
            }

            let newPosition = player.position.clone().add(velocity);
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù…
            newPosition = checkWorldBounds(newPosition);

            let collisionDetected = false;
            const playerBoundingSphere = new THREE.Sphere(newPosition, 2);
            for (const house of houses) {
                house.children.forEach(child => {
                    const childBox = new THREE.Box3().setFromObject(child);
                    if (childBox.intersectsSphere(playerBoundingSphere)) {
                        collisionDetected = true;
                    }
                });
                if (collisionDetected) break;
            }

            // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ ØªØµØ§Ø¯Ù…ØŒ Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨
            if (!collisionDetected) {
                player.position.copy(newPosition);
            } else {
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ ØªØµØ§Ø¯Ù…ØŒ Ù†ÙˆÙ‚Ù Ø§Ù„Ø­Ø±ÙƒØ©
                velocity.set(0, 0, 0);
            }
        }

        // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„Ù„ÙŠØ²Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© (Ø§Ù„Ø¢Ù† Ù‡Ùˆ Ø«Ø§Ø¨Øª ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ)
        function updateLaserSight() {
            // Ø§Ù„Ù…Ø¤Ø´Ø± Ø«Ø§Ø¨Øª ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙØŒ Ù„Ø°Ø§ Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹Ù‡
        }

        // Ø¬Ù…Ø¹ Ø§Ù„Ù†Ù‚ÙˆØ¯
        function collectCoins() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            for (let i = coins.length - 1; i >= 0; i--) {
                const coinPos = new THREE.Vector3();
                coins[i].getWorldPosition(coinPos);
                const distance = playerPos.distanceTo(coinPos);

                if (distance < 3) {
                    coinsCollected += coins[i].userData.value;
                    showCoinAnimation(coinPos.x, coinPos.y + 2, coinPos.z, coins[i].userData.value);
                    scene.remove(coins[i]);
                    coins.splice(i, 1);
                    updateUI();
                    playCoinSound(); // ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø¬Ù…Ø¹ Ø§Ù„Ø¹Ù…Ù„Ø©
                }
            }
        }

        // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø¹ Ø§Ù„Ù†Ù‚ÙˆØ¯
        function showCoinAnimation(x, y, z, value) {
            const coinDiv = document.createElement('div');
            coinDiv.className = 'coin-animation';
            coinDiv.textContent = `+${value}`;
            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);
            coinDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            coinDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector('.scene-container').appendChild(coinDiv);
            setTimeout(() => {
                coinDiv.remove();
            }, 1500);
        }

        // Ø²ÙŠØ§Ø¯Ø© Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµØ¹ÙˆØ¨Ø©
        function increaseDifficulty() {
            if (score >= level * 100) {
                level++;
                updateUI();
            }
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© (ÙÙˆØ² Ø£Ùˆ Ø®Ø³Ø§Ø±Ø©)
        function checkGameState() {
            // **Ø¬Ø¯ÙŠØ¯: Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØµØ­Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø£Ù‚Ù„ Ù…Ù† Ø£Ùˆ ØªØ³Ø§ÙˆÙŠ ØµÙØ±ØŒ ØªÙ†ØªÙ‡ÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø©**
            if (playerHealth <= 0) {
                gameOverPanel.querySelector('h2').textContent = "Ù„Ù‚Ø¯ Ø®Ø³Ø±Øª!";
                gameOverPanel.querySelector('p').textContent = "ØµØ­ØªÙƒ ÙˆØµÙ„Øª Ù„Ù„ØµÙØ±!";
                endGame();
                return;
            }

            // Ø¥Ø°Ø§ Ø§Ø®ØªÙØª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø´Ø¬Ø§Ø±ØŒ Ø®Ø³Ø± Ø§Ù„Ù„Ø§Ø¹Ø¨
            if (trees.length === 0) {
                gameOverPanel.querySelector('h2').textContent = "Ù„Ù‚Ø¯ Ø®Ø³Ø±Øª!";
                gameOverPanel.querySelector('p').textContent = "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø´Ø¬Ø§Ø± Ø¯Ù…Ø±Øª!";
                endGame();
                return;
            }

            // Ø¥Ø°Ø§ Ø§Ø®ØªÙØª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†ÙØ§ÙŠØ§ØªØŒ ÙØ§Ø² Ø§Ù„Ù„Ø§Ø¹Ø¨
            if (wastes.length === 0 && !isRoundTransition) {
                // Ø¥Ø°Ø§ Ù„Ù… ØªØ¹Ø¯ Ù‡Ù†Ø§Ùƒ Ù†ÙØ§ÙŠØ§ØªØŒ Ø§Ø¸Ù‡Ø± Ø²Ø± Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©
                nextRoundBtn.style.display = 'block';
                nextRoundBtn.disabled = false;
            }
        }

        // Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        function endGame() {
            gameStarted = false;
            gameOver = true;
            finalScore.textContent = score;
            finalCoins.textContent = coinsCollected;
            gameOverPanel.style.display = 'block';
        }

        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©
        function restartGame() {
            // ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù…Ù† Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø¨Ø´ÙƒÙ„ ÙƒØ§Ù…Ù„
            wastes.forEach(waste => scene.remove(waste));
            wastes.length = 0;
            laserBeams.forEach(beam => {
                scene.remove(beam.beam);
            });
            laserBeams.length = 0;
            wasteProjectiles.forEach(p => scene.remove(p)); // **Ø¬Ø¯ÙŠØ¯**
            wasteProjectiles.length = 0; // **Ø¬Ø¯ÙŠØ¯**
            effects.forEach(effect => {
                effect.particles.forEach(particle => {
                    scene.remove(particle);
                });
            });
            effects.length = 0;
            coins.forEach(coin => scene.remove(coin));
            coins.length = 0;
            trees.forEach(tree => scene.remove(tree));
            trees.length = 0;
            treasureBoxes.forEach(box => scene.remove(box));
            treasureBoxes.length = 0;

            score = 0;
            coinsCollected = 0;
            level = 1;
            round = 1;
            gameOver = false;
            playerSpeed = 5.0;
            playerHealth = 100; // **Ø¬Ø¯ÙŠØ¯: Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ØµØ­Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨**

            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù…ÙˆÙ‚Ø¹ ÙˆØ¯ÙˆØ±Ø§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙˆØ§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            player.position.set(0, 0, 0);
            player.rotation.set(0, 0, 0);
            camera.position.set(0, 1.8, 0);
            camera.rotation.set(0, 0, 0);

            updateUI();
            gameOverPanel.style.display = 'none';
            gameStarted = true;

            // Ø¨Ø¯Ø¡ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
            spawnNewTrees();
            spawnWavesForRound();
        }

        // --- ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯ ---
        function getTouchTarget(touch) {
            return document.elementFromPoint(touch.clientX, touch.clientY);
        }

        function isMovementButton(element) {
            return element.classList.contains('movement-btn');
        }

        function isShootButton(element) {
            return element.id === 'shootBtn';
        }

        // --- Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯ ---
        function setupMultiTouchControls() {
            window.addEventListener('touchstart', (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„ Ù„Ù…Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©
                for (const touch of e.changedTouches) {
                    const targetElement = getTouchTarget(touch);
                    if (isMovementButton(targetElement)) {
                        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù„Ù…Ø³Ø© Ø¹Ù„Ù‰ Ø²Ø± Ø­Ø±ÙƒØ©
                        buttonTouchIds.set(touch.identifier, targetElement);
                        switch (targetElement.id) {
                            case 'upBtn':
                                moveForward = true;
                                break;
                            case 'downBtn':
                                moveBackward = true;
                                break;
                            case 'leftBtn':
                                moveRight = true;
                                break;
                            case 'rightBtn':
                                moveLeft = true;
                                break;
                        }
                    } else if (isShootButton(targetElement)) {
                        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù„Ù…Ø³Ø© Ø¹Ù„Ù‰ Ø²Ø± Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±
                        buttonTouchIds.set(touch.identifier, targetElement);
                        startCharging();
                    } else if (!cameraTouchId) {
                        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù„Ù…Ø³Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© ÙˆÙ„Ù… ÙŠØªÙ… ØªØ¹ÙŠÙŠÙ† Ù„Ù…Ø³Ø© Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¨Ø¹Ø¯
                        cameraTouchId = touch.identifier;
                        previousTouchX = touch.clientX;
                        previousTouchY = touch.clientY;
                    }
                }
            }, {
                passive: true
            });

            window.addEventListener('touchmove', (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;
                // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø±ÙƒØ© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù„Ù…Ø³Ø© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù†Ø´Ø·Ø©
                for (const touch of e.changedTouches) {
                    if (touch.identifier === cameraTouchId) {
                        const deltaX = touch.clientX - previousTouchX;
                        const deltaY = touch.clientY - previousTouchY;
                        player.rotation.y -= deltaX * touchSensitivity;
                        camera.rotation.x -= deltaY * touchSensitivity; // Ø§Ø³ØªØ®Ø¯Ø§Ù… touchSensitivity Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§
                        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                        previousTouchX = touch.clientX;
                        previousTouchY = touch.clientY;
                    }
                }
            }, {
                passive: true
            });

            window.addEventListener('touchend', (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;
                for (const touch of e.changedTouches) {
                    if (touch.identifier === cameraTouchId) {
                        // Ø¥Ù†Ù‡Ø§Ø¡ Ù„Ù…Ø³Ø© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
                        cameraTouchId = null;
                    } else if (buttonTouchIds.has(touch.identifier)) {
                        // Ø¥Ù†Ù‡Ø§Ø¡ Ù„Ù…Ø³Ø© Ø²Ø± Ø§Ù„Ø­Ø±ÙƒØ© Ø£Ùˆ Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±
                        const targetElement = buttonTouchIds.get(touch.identifier);
                        if (isMovementButton(targetElement)) {
                            switch (targetElement.id) {
                                case 'upBtn':
                                    moveForward = false;
                                    break;
                                case 'downBtn':
                                    moveBackward = false;
                                    break;
                                case 'leftBtn':
                                    moveRight = false;
                                    break;
                                case 'rightBtn':
                                    moveLeft = false;
                                    break;
                            }
                        } else if (isShootButton(targetElement)) {
                            endCharging();
                        }
                        buttonTouchIds.delete(touch.identifier);
                    }
                }
            });
        }

        // Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø³ØªÙ…Ø¹ÙŠ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„ÙØ£Ø±Ø© (Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±)
        function setupMouseControls() {
            window.addEventListener('mousedown', (e) => {
                if (!gameStarted || e.target !== canvas || gameOver || isRoundTransition) return;
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
                document.body.classList.add('dragging');
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                document.body.classList.remove('dragging');
            });

            window.addEventListener('mousemove', (e) => {
                if (!gameStarted || !isDragging || gameOver || isRoundTransition) return;
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;
                player.rotation.y -= deltaX * mouseSensitivity;
                camera.rotation.x -= deltaY * touchSensitivity; // Ø§Ø³ØªØ®Ø¯Ø§Ù… touchSensitivity Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            });
        }

        // Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
        shootBtn.addEventListener('mousedown', startCharging);
        shootBtn.addEventListener('mouseup', endCharging);

        function startCharging() {
            if (!gameStarted || gameOver || isRoundTransition) return;
            isCharging = true;
            chargeStartTime = Date.now();
            chargeIndicator.style.display = 'block';
        }

        function endCharging() {
            if (!isCharging) return;
            isCharging = false;
            const chargeTime = Date.now() - chargeStartTime;
            const chargePercentage = Math.min(100, (chargeTime / maxChargeTime) * 100);
            shootLaser(chargeTime >= maxChargeTime);
            chargeIndicator.style.display = 'none';
            chargeBar.style.width = '0%';
        }

        // Ø£Ø­Ø¯Ø§Ø« Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ù„Ù„Ø­Ø±ÙƒØ©
        document.addEventListener('keydown', (e) => {
            if (!gameStarted || gameOver || isRoundTransition) return;
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                case 's':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRight = false;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!gameStarted || gameOver || isRoundTransition) return;
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                case 's':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                case 'a':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRight = false;
                    break;
            }
        });

        // Ø£Ø­Ø¯Ø§Ø« Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ø§Ù„Ù„Ù…Ø³ (ØªÙ… Ø¥Ø²Ø§Ù„ØªÙ‡Ø§ Ù„ØµØ§Ù„Ø­ Ù†Ø¸Ø§Ù… Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯)
        restartBtn.addEventListener('click', restartGame);
        nextRoundBtn.addEventListener('click', nextRound);

        // Ø²Ø± "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©"
        startGameBtn.addEventListener('click', () => {
            startScreen.style.display = 'none';
            treeStatsDisplay.style.display = 'flex';
            scoreDisplay.style.display = 'block';
            coinsDisplay.style.display = 'block';
            healthIndicator.style.display = 'block'; // **Ø¬Ø¯ÙŠØ¯**
            roundIndicator.style.display = 'block';
            laserSight.style.display = 'block';
            gameStarted = true;

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠÙˆØª Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©
            spawnHouses();
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø±Ø¦ÙŠØ©
            createWorldBoundsVisual();
            // Ø¨Ø¯Ø¡ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
            spawnNewTrees();
            spawnWavesForRound();
            updateUI();

            // Ø¥Ø¹Ø¯Ø§Ø¯ ØªØ­ÙƒÙ…Ø§Øª Ø§Ù„ÙØ£Ø±Ø© ÙˆØ§Ù„Ù„Ù…Ø³ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯
            setupMouseControls();
            setupMultiTouchControls();
        });

        // Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙƒØ³ÙˆØ± Ø§Ù„Ø¹Ø´Ø±ÙŠØ© Ø§Ù„Ø¯ÙˆØ±ÙŠØ©
        // -------------------------------------------------------------------------------------------------------------------------------------------------
        /**
         * Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚Ø§Ø³Ù… Ø§Ù„Ù…Ø´ØªØ±Ùƒ Ø§Ù„Ø£ÙƒØ¨Ø± (GCD) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø¥Ù‚Ù„ÙŠØ¯Ø³.
         * @param {number} a - Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙˆÙ„.
         * @param {number} b - Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø«Ø§Ù†ÙŠ.
         * @returns {number} Ø§Ù„Ù‚Ø§Ø³Ù… Ø§Ù„Ù…Ø´ØªØ±Ùƒ Ø§Ù„Ø£ÙƒØ¨Ø±.
         */
        function gcd(a, b) {
            // Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø·Ù„Ù‚Ø© Ù„Ø£Ù† Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ù‚Ø¯ ØªÙƒÙˆÙ† Ø³Ø§Ù„Ø¨Ø©ØŒ ÙˆØ®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø¥Ù‚Ù„ÙŠØ¯Ø³ ØªØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…ÙˆØ¬Ø¨Ø©
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        }

        /**
         * ØªØ­ÙˆÙŠÙ„ ÙƒØ³Ø± Ø¹Ø´Ø±ÙŠ Ø¯ÙˆØ±ÙŠ Ø¥Ù„Ù‰ ÙƒØ³Ø± ÙØ¹Ù„ÙŠ Ø£Ùˆ Ø¹Ø¯Ø¯ ÙƒØ³Ø±ÙŠ.
         * @param {string} decimalString - Ø§Ù„ÙƒØ³Ø± Ø§Ù„Ø¹Ø´Ø±ÙŠ Ø§Ù„Ø¯ÙˆØ±ÙŠ ÙƒÙ‚ÙŠÙ…Ø© Ù†ØµÙŠØ© (Ù…Ø«Ø§Ù„: "0.1(6)").
         * @returns {{numerator: number, denominator: number, integerPart: number}} Ø§Ù„ÙƒØ³Ø± Ø§Ù„ÙØ¹Ù„ÙŠ Ø£Ùˆ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙƒØ³Ø±ÙŠ.
         */
        function convertRepeatingDecimal(decimalString) {
            // 1. ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ù†ØµÙŠØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
            const match = decimalString.match(/(\d*)\.((\d*)?\((\d+)\))?/);
            if (!match) {
                throw new Error("ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒØ³Ø± Ø§Ù„Ø¹Ø´Ø±ÙŠ Ø§Ù„Ø¯ÙˆØ±ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­");
            }

            const integerPart = parseInt(match[1]) || 0;
            const nonRepeatingPart = match[3] || '';
            const repeatingPart = match[4] || '';

            // 2. ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„ØªØ­ÙˆÙŠÙ„
            let numerator, denominator;
            if (repeatingPart === '') {
                // Ø­Ø§Ù„Ø© Ø§Ù„ÙƒØ³Ø± Ø§Ù„Ø¹Ø§Ø¯ÙŠ ØºÙŠØ± Ø§Ù„Ø¯ÙˆØ±ÙŠ (Ù„Ø¶Ù…Ø§Ù† Ø¹Ù…Ù„ Ø§Ù„Ø¯Ø§Ù„Ø© Ø­ØªÙ‰ Ù…Ø¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ ØºÙŠØ± Ø§Ù„Ø¯ÙˆØ±ÙŠØ©)
                numerator = parseInt(nonRepeatingPart);
                denominator = Math.pow(10, nonRepeatingPart.length);
            } else {
                // Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©:
                // Ø§Ù„Ø¨Ø³Ø· = (Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ø§Ù„ÙØ§ØµÙ„Ø©) - (Ø§Ù„Ø¬Ø²Ø¡ ØºÙŠØ± Ø§Ù„Ø¯ÙˆØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ø§Ù„ÙØ§ØµÙ„Ø©)
                // Ø§Ù„Ù…Ù‚Ø§Ù… = (Ø¹Ø¯Ø¯ 9s Ø¨Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¯ÙˆØ±ÙŠØ©) + (Ø¹Ø¯Ø¯ 0s Ø¨Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ØºÙŠØ± Ø§Ù„Ø¯ÙˆØ±ÙŠØ©)
                const fullNumber = parseInt(nonRepeatingPart + repeatingPart) || 0;
                const nonRepeatingNumber = parseInt(nonRepeatingPart) || 0;
                numerator = fullNumber - nonRepeatingNumber;
                denominator = (Math.pow(10, nonRepeatingPart.length + repeatingPart.length) - Math.pow(10, nonRepeatingPart.length));
            }

            // 3. ØªØ¨Ø³ÙŠØ· Ø§Ù„ÙƒØ³Ø±
            const commonDivisor = gcd(numerator, denominator);
            numerator /= commonDivisor;
            denominator /= commonDivisor;

            return {
                numerator,
                denominator,
                integerPart
            };
        }
        // -------------------------------------------------------------------------------------------------------------------------------------------------

        // ØªÙˆÙ„ÙŠØ¯ Ø³Ø¤Ø§Ù„ Ø±ÙŠØ§Ø¶ÙŠ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
        function generateMathQuestion() {
            // Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø£Ø³Ø¦Ù„Ø©: ØªØ­ÙˆÙŠÙ„ ÙƒØ³Ø± Ø¯ÙˆØ±ÙŠ Ø¥Ù„Ù‰ ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ Ø£Ùˆ Ø¹Ø¯Ø¯ ÙƒØ³Ø±ÙŠ
            const questionTypes = ['fraction_conversion', 'mixed_number_conversion'];
            const selectedType = questionTypes[Math.floor(Math.random() * questionTypes.length)];

            if (selectedType === 'fraction_conversion') {
                // Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ ÙŠÙˆÙ„Ø¯ Ø³Ø¤Ø§Ù„Ø§Ù‹ Ù„ØªØ­ÙˆÙŠÙ„ ÙƒØ³Ø± Ø¹Ø´Ø±ÙŠ Ø¯ÙˆØ±ÙŠ Ø¨Ø³ÙŠØ· Ù…Ø«Ù„ 0.6
                // Ù†Ø®ØªØ§Ø± Ø±Ù‚Ù…Ù‹Ø§ Ø¹Ø´ÙˆØ§Ø¦ÙŠÙ‹Ø§ Ø¨ÙŠÙ† 1 Ùˆ 9 Ù„ÙŠÙƒÙˆÙ† Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø¯ÙˆØ±ÙŠ
                const repeatingDigit = Math.floor(Math.random() * 8) + 1;
                // Ù†Ø³ØªØ®Ø¯Ù… ØªÙ†Ø³ÙŠÙ‚ LaTeX Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ù†ØµÙŠØ© Ù„Ù„Ø±Ù‚Ù… Ø§Ù„Ø¯ÙˆØ±ÙŠ
                const decimalString = `0.\\overline{${repeatingDigit}}`;
                const numerator = repeatingDigit;
                const denominator = 9;
                // Ù†Ù‚ÙˆÙ… Ø¨ØªØ¨Ø³ÙŠØ· Ø§Ù„ÙƒØ³Ø± Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø¨Ø³Ø· ØµÙˆØ±Ø©
                const commonDivisor = gcd(numerator, denominator);
                const simplifiedNumerator = numerator / commonDivisor;
                const simplifiedDenominator = denominator / commonDivisor;
                // Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ø¨ØªÙ†Ø³ÙŠÙ‚ LaTeX
                const answer = `$$\\frac{${simplifiedNumerator}}{${simplifiedDenominator}}$$`;
                // Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„
                const question = `Ø§ÙƒØªØ¨ Ø§Ù„ÙƒØ³Ø± Ø§Ù„Ø¹Ø´Ø±ÙŠ Ø§Ù„Ø¯ÙˆØ±ÙŠ $$${decimalString}$$ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ.`;
                const options = [answer];
                // ØªÙˆÙ„ÙŠØ¯ Ø®ÙŠØ§Ø±Ø§Øª Ø®Ø§Ø·Ø¦Ø©
                while (options.length < 4) {
                    let wrongNumerator = simplifiedNumerator + Math.floor(Math.random() * 3) - 1;
                    let wrongDenominator = simplifiedDenominator + Math.floor(Math.random() * 3) - 1;
                    if (wrongNumerator <= 0) wrongNumerator = 1;
                    if (wrongDenominator <= 0) wrongDenominator = 1;
                    const wrongAnswer = `$$\\frac{${wrongNumerator}}{${wrongDenominator}}$$`;
                    if (!options.includes(wrongAnswer)) {
                        options.push(wrongAnswer);
                    }
                }
                options.sort(() => Math.random() - 0.5);
                return {
                    question,
                    options,
                    answer
                };
            } else {
                // Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ ÙŠÙˆÙ„Ø¯ Ø³Ø¤Ø§Ù„Ø§Ù‹ Ù„ØªØ­ÙˆÙŠÙ„ Ø¹Ø¯Ø¯ Ø¹Ø´Ø±ÙŠ Ø¯ÙˆØ±ÙŠ Ù…Ø®ØªÙ„Ø· Ù…Ø«Ù„ 1.14
                // Ù†Ø®ØªØ§Ø± Ø±Ù‚Ù…Ù‹Ø§ ØµØ­ÙŠØ­Ù‹Ø§ Ø¹Ø´ÙˆØ§Ø¦ÙŠÙ‹Ø§ Ù…Ù† 1 Ø¥Ù„Ù‰ 4
                const integerPart = Math.floor(Math.random() * 4) + 1;
                // Ù†Ø®ØªØ§Ø± Ø±Ù‚Ù…ÙŠÙ† Ø¹Ø´Ø±ÙŠÙŠÙ† Ø¹Ø´ÙˆØ§Ø¦ÙŠÙŠÙ† Ø¨ÙŠÙ† 10 Ùˆ 99
                let repeatingDigits = Math.floor(Math.random() * 90) + 10;
                // Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù„Ù„ÙƒØ³Ø±
                const numerator = repeatingDigits;
                const denominator = 99;
                // Ù†Ø¨Ø³Ø· Ø§Ù„ÙƒØ³Ø±
                const commonDivisor = gcd(numerator, denominator);
                const simplifiedNumerator = numerator / commonDivisor;
                const simplifiedDenominator = denominator / commonDivisor;
                // Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ø¨ØªÙ†Ø³ÙŠÙ‚ LaTeX Ù„Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙƒØ³Ø±ÙŠ
                const answer = `$$${integerPart}\\frac{${simplifiedNumerator}}{${simplifiedDenominator}}$$`;
                // Ù†Ø³ØªØ®Ø¯Ù… ØªÙ†Ø³ÙŠÙ‚ LaTeX Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ù†ØµÙŠØ© Ù„Ù„Ø±Ù‚Ù… Ø§Ù„Ø¯ÙˆØ±ÙŠ
                const decimalString = `${integerPart}.\\overline{${repeatingDigits}}`;
                // Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„
                const question = `Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ø´Ø±ÙŠ Ø§Ù„Ø¯ÙˆØ±ÙŠ $$${decimalString}$$ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ø¹Ø¯Ø¯ ÙƒØ³Ø±ÙŠ.`;
                const options = [answer];
                // ØªÙˆÙ„ÙŠØ¯ Ø®ÙŠØ§Ø±Ø§Øª Ø®Ø§Ø·Ø¦Ø©
                while (options.length < 4) {
                    let wrongInteger = integerPart + Math.floor(Math.random() * 2) - 1;
                    let wrongNumerator = simplifiedNumerator + Math.floor(Math.random() * 3) - 1;
                    let wrongDenominator = simplifiedDenominator + Math.floor(Math.random() * 3) - 1;
                    if (wrongInteger <= 0) wrongInteger = 1;
                    if (wrongNumerator <= 0) wrongNumerator = 1;
                    if (wrongDenominator <= 0) wrongDenominator = 1;
                    const wrongAnswer = `$$${wrongInteger}\\frac{${wrongNumerator}}{${wrongDenominator}}$$`;
                    if (!options.includes(wrongAnswer)) {
                        options.push(wrongAnswer);
                    }
                }
                options.sort(() => Math.random() - 0.5);
                return {
                    question,
                    options,
                    answer
                };
            }
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØµØ·Ø¯Ø§Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„ØµØ­Ø©
        function checkTreasureBoxCollision() {
            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            for (let i = treasureBoxes.length - 1; i >= 0; i--) {
                const box = treasureBoxes[i];
                const boxPos = new THREE.Vector3();
                box.getWorldPosition(boxPos);
                const distance = playerPos.distanceTo(boxPos);

                if (distance < 3 && box.userData.isHealthBox) {
                    freezeGame();
                    showMathQuestion(box);
                    playBoxSound(); // ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚
                    return;
                }
            }
        }

        // ØªØ¬Ù…ÙŠØ¯ Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
        function freezeGame() {
            isGameFrozen = true;
            cancelAnimationFrame(gameLoopId);
        }

        // Ø§Ø³ØªØ¦Ù†Ø§Ù Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
        function unfreezeGame() {
            isGameFrozen = false;
            animate();
        }

        // Ø¹Ø±Ø¶ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø³Ø¤Ø§Ù„
        function showMathQuestion(box) {
            const questionData = generateMathQuestion();
            questionText.textContent = questionData.question;
            optionsContainer.innerHTML = '';
            questionData.options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'option-btn';
                button.textContent = option;
                button.addEventListener('click', () => {
                    handleAnswer(option, questionData.answer, box);
                });
                optionsContainer.appendChild(button);
            });
            questionPanel.style.display = 'block';

            // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… MathJax
            MathJax.typesetPromise();
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
        function handleAnswer(selectedOption, correctAnswer, box) {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
            const isCorrect = (selectedOption === correctAnswer);
            let prizeMessage = "Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©!"; // Ø±Ø³Ø§Ù„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„Ø®Ø³Ø§Ø±Ø©
            let isWin = false;
            if (isCorrect) {
                isWin = true;
                const rewardType = Math.floor(Math.random() * 3);
                switch (rewardType) {
                    case 0: // ØµØ­Ø©
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 20);
                        prizeMessage = "Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: ØµØ­Ø© Ø¥Ø¶Ø§ÙÙŠØ©!";
                        break;
                    case 1: // Ø´Ø­Ù† ÙƒØ§Ù…Ù„ Ù„Ù„ÙŠØ²Ø± Ø§Ù„Ø®Ø§Ø±Ù‚
                        endCharging(); // Ø¥Ù†Ù‡Ø§Ø¡ Ø£ÙŠ Ø´Ø­Ù† Ø­Ø§Ù„ÙŠ
                        isCharging = false;
                        chargeBar.style.width = '100%';
                        setTimeout(() => {
                            chargeBar.style.width = '0%';
                        }, 1000);
                        prizeMessage = "Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: Ø´Ø­Ù† Ø§Ù„Ù„ÙŠØ²Ø± Ø§Ù„Ø®Ø§Ø±Ù‚!";
                        break;
                    case 2: // Ø´Ø¬Ø±Ø©
                        const treeX = Math.random() * 800 - 400;
                        const treeZ = Math.random() * 800 - 400;
                        trees.push(createTree(treeX, treeZ));
                        totalTrees++;
                        prizeMessage = "Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: Ø´Ø¬Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø­Ø¯ÙŠÙ‚Ø©!";
                        break;
                }
                playGiftSound(); // ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‡Ø¯ÙŠØ©
            }
            // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ù…Ø®ØµØµØ© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† alert()
            showAnswerMessage(isWin, prizeMessage);
            // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚ Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
            scene.remove(box);
            const boxIndex = treasureBoxes.indexOf(box);
            if (boxIndex > -1) {
                treasureBoxes.splice(boxIndex, 1);
            }
            questionPanel.style.display = 'none';
            unfreezeGame();
            updateUI();
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
        function showAnswerMessage(isCorrect, message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'answer-message';
            if (!isCorrect) {
                messageDiv.classList.add('incorrect');
            }
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ø¹Ø¯ ÙØªØ±Ø© Ø²Ù…Ù†ÙŠØ©
            setTimeout(() => {
                messageDiv.remove();
            }, 1500); // 1.5 Ø«Ø§Ù†ÙŠØ©
        }

        // Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
        function animate() {
            gameLoopId = requestAnimationFrame(animate);
            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…ØªØ¬Ù…Ø¯Ø©ØŒ Ù„Ø§ ØªÙ‚Ù… Ø¨Ø£ÙŠ ØªØ­Ø¯ÙŠØ«
            if (isGameFrozen) {
                return;
            }

            if (gameStarted && !gameOver) {
                if (isCharging) {
                    const chargeTime = Date.now() - chargeStartTime;
                    const chargePercentage = Math.min(100, (chargeTime / maxChargeTime) * 100);
                    chargeBar.style.width = `${chargePercentage}%`;
                }
                movePlayer();
                moveWastes();
                updateWasteProjectiles();
                rotateCoins();
                collectCoins();
                checkTreasureBoxCollision(); // **Ø¬Ø¯ÙŠØ¯: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ†Ø§Ø¯ÙŠÙ‚**
                updateLaserBeams();
                updateEffects();
                increaseDifficulty();
                checkGameState();
                updateUI();
            }
            renderer.render(scene, camera);
        }

        // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            updateLaserSight();
        });

        window.onload = function () {
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø£ÙˆÙ„ÙŠ Ù„Ù„ÙˆØ­Ø© Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            animate();
        };
    </script>
</body>
</html>