<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subway Surfers ثلاثية الأبعاد - كاميرا محسّنة وموسيقى</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MathJax for rendering LaTeX mathematical expressions -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Tone.js CDN for audio synthesis and sequencing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script> 
    <style>
        /* Reset default margins and paddings for all elements */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* Body styling */
        body {
            overflow: hidden; /* Hide any content overflow */
            background: linear-gradient(to bottom, #1a2980, #26d0ce); /* Gradient background */
            height: 100vh; /* Full screen height */
            perspective: 1000px; /* 3D perspective effect */
            color: white; /* Default text color */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Main game container */
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        /* Three.js Canvas */
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Top UI */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            pointer-events: none; /* Allow clicks to pass through */
        }
        
        /* Score and coins container */
        #score-container, #coins-container {
            font-size: 2.5vh;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.4);
            padding: 1.5vh 3vh;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 1vh;
            pointer-events: auto; /* Allow clicks on these elements */
        }

        /* Coin icon (SVG) */
        .coin-icon {
            width: 3.5vh;
            height: 3.5vh;
            display: inline-block;
            vertical-align: middle;
        }
        .coin-icon svg {
            width: 100%;
            height: 100%;
            fill: gold;
            filter: drop-shadow(0 0 5px gold);
        }
        
        /* Start screen and game over screen */
        #start-screen, #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85); /* Semi-transparent background */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
            padding: 20px;
        }
        
        /* Game title */
        h1 {
            font-size: 8vh;
            margin-bottom: 3vh;
            color: #ffcc00; /* Gold color */
            text-shadow: 0 0 15px #ff6600, 0 0 25px rgba(255, 102, 0, 0.7); /* Glowing text shadow */
            letter-spacing: 0.3vh;
            animation: pulse 2s infinite alternate; /* Pulse effect */
        }

        /* Pulse effect definition */
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }
        
        /* Game over screen title */
        h2 {
            font-size: 6vh;
            margin-bottom: 4vh;
            color: #ff9900; /* Orange-gold color */
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        /* Subtitle */
        .subtitle {
            font-size: 2.5vh;
            margin-bottom: 5vh;
            max-width: 80%;
            line-height: 1.6;
            color: #ddd;
        }
        
        /* Game buttons */
        .btn {
            background: linear-gradient(to bottom, #ffcc00, #ff6600); /* Gradient color */
            color: white;
            font-size: 3vh;
            font-weight: bold;
            border: none;
            padding: 2vh 6vh;
            border-radius: 50px; /* Rounded buttons */
            cursor: pointer;
            margin: 1.5vh;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); /* Smooth transition */
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4); /* Button shadow */
            text-transform: uppercase;
            letter-spacing: 0.1vh;
            position: relative;
            overflow: hidden;
        }
        
        /* Button hover effects */
        .btn:hover {
            transform: translateY(-5px); /* Lift button slightly */
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to bottom, #ffd633, #ff8533);
        }
        
        /* Button click effects */
        .btn:active {
            transform: translateY(1px); /* Lower button slightly */
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        /* Ripple effect on click */
        .btn:after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }

        .btn:focus:not(:active)::after {
            animation: ripple 1s ease-out forwards;
        }

        /* Ripple effect definition */
        @keyframes ripple {
            0% { transform: scale(0) translate(-50%, -50%); opacity: 0.5; }
            100% { transform: scale(200) translate(-50%, -50%); opacity: 0; }
        }
        
        /* Controls section (keyboard) */
        #controls {
            margin-top: 4vh;
            background: rgba(255, 255, 255, 0.15);
            padding: 3vh;
            border-radius: 15px;
            text-align: center;
            max-width: 90%;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #controls h3 {
            font-size: 3vh;
            margin-bottom: 2vh;
            color: #ffcc00;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }
        
        /* Individual key style */
        .key {
            display: inline-block;
            background: rgba(0, 0, 0, 0.6);
            padding: 1vh 2vh;
            margin: 0.5vh;
            border-radius: 8px;
            font-weight: bold;
            border: 2px solid #ffcc00;
            min-width: 5vh;
        }
        
        /* Character selection container */
        #characters {
            display: flex;
            margin: 4vh 0;
            gap: 3vh;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        /* Individual character style */
        .character {
            width: 15vh;
            height: 22vh;
            background: linear-gradient(to bottom, #ff6600, #cc5200);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            border: 3px solid transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10vh; /* Large size for character representation */
            /* Icons or images can be added here later */
        }
        
        /* Different background colors for characters */
        .character:nth-child(1) { background: linear-gradient(to bottom, #ff6600, #cc5200); }
        .character:nth-child(2) { background: linear-gradient(to bottom, #3366ff, #0033cc); }
        .character:nth-child(3) { background: linear-gradient(to bottom, #33cc33, #009900); }

        /* Inner glow effect for character */
        .character::before {
            content: "";
            position: absolute;
            top: 20%;
            left: 20%;
            width: 60%;
            height: 30%;
            background: rgba(255, 204, 0, 0.3);
            border-radius: 50%;
            opacity: 0.7;
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }
        
        /* Selected character style */
        .character.selected {
            box-shadow: 0 0 25px #ffcc00, 0 0 40px rgba(255, 204, 0, 0.7); /* Glowing shadow */
            transform: scale(1.15); /* Enlarge character */
            border-color: #ffcc00;
        }
        .character.selected::before {
            transform: scale(1);
        }
        
        /* Final score style */
        #final-score {
            font-size: 7vh;
            color: #ffcc00;
            margin: 3vh 0;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        /* New addition: Swipe instructions */
        .swipe-instructions {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            color: #fff; /* Text color inside instructions */
        }
        
        .swipe-row {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin: 10px 0;
        }
        
        .swipe-demo {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }
        
        .swipe-arrow {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .swipe-text {
            font-size: 16px;
        }
        
        /* Math Question Modal Styles */
        #math-question-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Darker overlay */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30; /* Above game over screen */
            text-align: center;
            padding: 10px; /* Reduced padding for smaller screens */
        }

        .modal-content {
            background: linear-gradient(to bottom, #2c3e50, #4a69bd); /* Dark blue to lighter blue gradient */
            padding: 20px; /* Reduced padding for smaller screens */
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 95%; /* Increased max-width for better use of space */
            width: 500px; /* Still a target width for larger screens */
            transform: scale(0.9);
            animation: modalPopIn 0.3s forwards ease-out;
            border: 2px solid #ffcc00; /* Gold border */
        }

        @keyframes modalPopIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        #math-question-modal h3 {
            font-size: 3.5vh; /* Adjusted for responsiveness */
            margin-bottom: 2vh; /* Adjusted for responsiveness */
            color: #ffcc00;
            text-shadow: 1px 1px 5px rgba(255, 204, 0, 0.5);
        }

        #question-text {
            font-size: 3vh; /* Adjusted for responsiveness */
            margin-bottom: 3vh; /* Adjusted for responsiveness */
            color: #e0e0e0;
            direction: ltr; /* Ensure math is left-to-right */
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px; /* Adjusted for responsiveness */
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            word-wrap: break-word; /* Ensure long equations wrap */
            overflow-wrap: break-word; /* Modern equivalent */
        }

        #answer-input {
            width: 90%; /* Increased width for better mobile usability */
            padding: 1.5vh; /* Adjusted for responsiveness */
            margin-bottom: 2.5vh; /* Adjusted for responsiveness */
            border-radius: 10px;
            border: 2px solid #ffcc00;
            font-size: 2.2vh; /* Adjusted for responsiveness */
            text-align: center;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            outline: none;
            transition: border-color 0.3s ease;
        }

        #answer-input:focus {
            border-color: #ff6600;
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
        }

        #feedback-message {
            font-size: 2.2vh; /* Adjusted for responsiveness */
            font-weight: bold;
            margin-top: 1.5vh; /* Adjusted for responsiveness */
            min-height: 3vh; /* Reserve space */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }

        /* Responsive design for tablets (max-width 768px) */
        @media (max-width: 768px) {
            h1 { font-size: 6vh; }
            h2 { font-size: 4.5vh; }
            .subtitle { font-size: 2vh; }
            .btn { padding: 1.5vh 4vh; font-size: 2.5vh; }
            #characters { flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 2vh; }
            .character { width: 12vh; height: 18vh; }
            #controls { display: none; /* Hide keyboard controls on small devices */ }
            #score-container, #coins-container { font-size: 2vh; padding: 1vh 2vh; }
            .coin-icon { width: 3vh; height: 3vh; }
            #final-score { font-size: 5vh; }

            /* Modal adjustments for tablets */
            .modal-content { padding: 25px; max-width: 90%; } /* Slightly reduced padding */
            #math-question-modal h3 { font-size: 3vh; }
            #question-text { font-size: 2.5vh; }
            #answer-input { font-size: 2vh; }
            #feedback-message { font-size: 2vh; }
        }

        /* Responsive design for small mobile devices (max-width 480px) */
        @media (max-width: 480px) {
            h1 { font-size: 5vh; }
            h2 { font-size: 4vh; }
            .subtitle { font-size: 1.8vh; }
            .btn { padding: 1.2vh 3.5vh; font-size: 2.2vh; }
            .character { width: 10vh; height: 15vh; }
            #score-container, #coins-container { font-size: 1.8vh; padding: 0.8vh 1.5vh; }
            
            /* Modal adjustments for mobile */
            #math-question-modal { padding: 5px; } /* Minimal padding for modal container */
            .modal-content { padding: 15px; border-radius: 15px; max-width: 98%; } /* More aggressive adjustments */
            #math-question-modal h3 { font-size: 2.8vh; margin-bottom: 1.5vh; }
            #question-text { font-size: 2.2vh; padding: 8px; margin-bottom: 2vh; }
            #answer-input { font-size: 1.6vh; padding: 1.2vh; margin-bottom: 2vh; }
            #feedback-message { font-size: 1.6vh; margin-top: 1vh; }
            .btn { font-size: 2vh; padding: 1vh 3vh; } /* Adjust button size within modal */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui">
            <div id="score-container">النقاط: <span id="score">0</span></div>
            <div id="coins-container">
                <span id="coins">0</span>
                <div class="coin-icon">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v2h-2zm0 4h2v6h-2z"/>
                    </svg>
                </div>
            </div>
        </div>
        
        <div id="start-screen">
            <h1>SUBWAY SURFERS</h1>
            <p class="subtitle">اللعبة ثلاثية الأبعاد الأكثر إثارة! اهرب من حارس المحطة واجمع العملات واكسر الأرقام القياسية!</p>
            
            <div id="characters">
                <div class="character selected"></div>
                <div class="character"></div>
                <div class="character"></div>
            </div>
            
            <!-- Updated swipe instructions -->
            <div class="swipe-instructions">
                <h3>إرشادات السحب</h3>
                <div class="swipe-row">
                    <div class="swipe-demo">
                        <div class="swipe-arrow">⬅️</div>
                        <div class="swipe-text">سحب لليسار للتحرك لليسار</div>
                    </div>
                    <div class="swipe-demo">
                        <div class="swipe-arrow">➡️</div>
                        <div class="swipe-text">سحب لليمين للتحرك لليمين</div>
                    </div>
                </div>
                <div class="swipe-row">
                    <div class="swipe-demo">
                        <div class="swipe-arrow">⬆️</div>
                        <div class="swipe-text">سحب لأعلى للقفز</div>
                    </div>
                    <div class="swipe-demo">
                        <div class="swipe-arrow">⬇️</div>
                        <div class="swipe-text">سحب لأسفل للانزلاق</div>
                    </div>
                </div>
            </div>
            
            <button id="start-btn" class="btn">ابدأ اللعبة</button>
            
            <div id="controls">
                <h3>أزرار التحكم</h3>
                <p>
                    <span class="key">←</span> يسار
                    <span class="key">→</span> يمين
                    <span class="key">مسافة</span> قفز
                    <span class="key">أسفل</span> انزل
                </p>
            </div>
        </div>
        
        <div id="game-over">
            <h2>انتهت اللعبة!</h2>
            <div id="final-score">النقاط: 0</div>
            <button id="restart-btn" class="btn">العب مرة أخرى</button>
        </div>

        <!-- Math Question Modal -->
        <div id="math-question-modal" style="display: none;">
            <div class="modal-content">
                <h3>سؤال الرياضيات</h3>
                <p id="question-text">سؤال عن أولويات العمليات الحسابية للصف السابع منهاج الأردن</p>
                <input type="text" id="answer-input" placeholder="أدخل إجابتك هنا">
                <button id="submit-answer-btn" class="btn">إرسال الإجابة</button>
                <p id="feedback-message"></p>
            </div>
        </div>
        
        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        // UI elements
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const scoreElement = document.getElementById('score');
        const finalScoreElement = document.getElementById('final-score');
        const coinsElement = document.getElementById('coins');
        const characters = document.querySelectorAll('.character');
        
        // Math Question Modal elements
        const mathQuestionModal = document.getElementById('math-question-modal');
        const questionTextElement = document.getElementById('question-text');
        const answerInputElement = document.getElementById('answer-input');
        const submitAnswerBtn = document.getElementById('submit-answer-btn');
        const feedbackMessageElement = document.getElementById('feedback-message');

        // Game variables
        let scene, camera, renderer; // Three.js scene, camera, and renderer
        let player; // Player object (now a THREE.Group)
        let playerBodyMesh; // Reference to the player's body mesh for color changes
        let playerHeadMesh; // Reference to the player's head mesh
        let playerHatMesh; // Reference to the player's hat mesh
        let playerLeftLeg, playerRightLeg; // References to player's leg meshes
        let playerLeftArm, playerRightArm; // References to player's arm meshes
        let groundSegments = []; // Repeating ground segments (for the road)
        let sideGroundSegments = []; // Repeating ground segments for the sides
        let railSegments = []; // Rail segments
        let buildingGroups = []; // Side building groups
        let treeGroups = []; // Side tree groups
        let obstacles = []; // Obstacles
        let coins = []; // Coins
        
        let score = 0, coinsCount = 0; // Score and collected coins
        let gameActive = false; // Game active state
        let speed = 0.1; // Game speed - Initial speed
        let lane = 1; // Current player lane (0: left, 1: center, 2: right)
        const lanePositions = [-2, 0, 2]; // X positions for lanes
        
        const SEGMENT_LENGTH = 50; // Length of one ground segment
        const NUM_SEGMENTS = 10; // Number of ground segments
        const GROUND_Z_OFFSET = -SEGMENT_LENGTH * (NUM_SEGMENTS / 2); // Initial Z offset for ground
        
        // Constants for side elements positioning
        const ROAD_HALF_WIDTH = 5; // نصف عرض الطريق
        const SIDE_GROUND_WIDTH = 20; // عرض الأرض الجانبية
        const SIDE_GROUND_OFFSET_X = ROAD_HALF_WIDTH + SIDE_GROUND_WIDTH / 2; // إزاحة X للأرض الجانبية
        
        const BUILDING_SPACING = 15; // المسافة بين المباني
        const NUM_BUILDINGS_PER_SIDE = 20; // عدد المباني على كل جانب
        const BUILDING_X_POSITION_ON_SIDE = ROAD_HALF_WIDTH + 3; // موضع X للمباني على الأرض الجانبية (أقرب للطريق)

        const TREE_SPACING = 10; // المسافة بين الأشجار
        const NUM_TREES_PER_SIDE = 30; // عدد الأشجار على كل جانب
        const TREE_X_POSITION_ON_SIDE = ROAD_HALF_WIDTH + 8; // موضع X للأشجار على الأرض الجانبية (أبعد عن الطريق)
        
        // Player movement states
        let playerBaseY = 0.85; // Base Y position (center of player model)
        const playerActualHeight = 1.7; // Actual height of the new player model from feet to head top
        let isJumping = false; // Is player jumping?
        let jumpStartTime = 0; // Jump start time
        const jumpDuration = 500; // Jump duration in milliseconds
        const jumpHeight = 2; // Max jump height
        
        let isSliding = false; // Is player sliding?
        let slideStartTime = 0; // Slide start time
        const slideDuration = 800; // Slide duration in milliseconds

        let runAnimationTime = 0; // Time for running animation
        const runSpeedFactor = 0.1; // Controls how fast legs swing during run
        const jumpLegRotationFactor = 0.8; // How much more legs rotate during jump
        const armSwingAmplitude = 0.4; // Amplitude of arm swing during run
        const armJumpRotation = 0.5; // Rotation of arms during jump
        
        // Touch control variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const swipeThreshold = 50; // Minimum distance for a swipe

        // Math Question Variables
        const mathQuestions = [
            {
                question: "$$ 5 + 3 \\times (8 - 2)^2 \\div 4 $$",
                answer: 32,
                explanation: "ترتيب العمليات: الأقواس أولاً، ثم الأسس، ثم الضرب والقسمة من اليسار لليمين، ثم الجمع والطرح من اليسار لليمين."
            },
            {
                question: "$$ 10 - 2^3 + (6 \\div 2) \\times 5 $$",
                answer: 17,
                explanation: "ترتيب العمليات: الأقواس أولاً، ثم الأسس، ثم الضرب والقسمة من اليسار لليمين، ثم الجمع والطرح من اليسار لليمين."
            },
            {
                question: "$$ (12 + 8) \\div 4 - 3^2 \\times 1 $$",
                answer: -4,
                explanation: "ترتيب العمليات: الأقواس أولاً، ثم الأسس، ثم الضرب والقسمة من اليسار لليمين، ثم الجمع والطرح من اليسار لليمين."
            },
            {
                question: "$$ 7 \\times 2^2 - (15 \\div 3) + 1 $$",
                answer: 24,
                explanation: "ترتيب العمليات: الأقواس أولاً، ثم الأسس، ثم الضرب والقسمة من اليسار لليمين، ثم الجمع والطرح من اليسار لليمين."
            },
            {
                question: "$$ 4^2 + (20 - 5) \\div 3 - 10 $$",
                answer: 11,
                explanation: "ترتيب العمليات: الأقواس أولاً، ثم الأسس، ثم الضرب والقسمة من اليسار لليمين، ثم الجمع والطرح من اليسار لليمين."
            },
            {
                question: "$$ 100 \\div 5^2 + (10 - 2) \\times 3 $$",
                answer: 28,
                explanation: "ترتيب العمليات: الأقواس أولاً، ثم الأسس، ثم الضرب والقسمة من اليسار لليمين، ثم الجمع والطرح من اليسار لليمين."
            },
            {
                question: "$$ (7 + 3)^2 - 5 \\times 4 + 1 $$",
                answer: 81,
                explanation: "ترتيب العمليات: الأقواس أولاً، ثم الأسس، ثم الضرب والقسمة من اليسار لليمين، ثم الجمع والطرح من اليسار لليمين."
            },
            {
                question: "$$ 3 \\times (4^2 - 6) \\div 2 $$",
                answer: 15,
                explanation: "ترتيب العمليات: الأقواس أولاً، ثم الأسس، ثم الضرب والقسمة من اليسار لليمين، ثم الجمع والطرح من اليسار لليمين."
            }
        ];
        let currentQuestion = null;
        let collidedObstacle = null; // To keep track of the obstacle that caused the collision
        
        // Global variables for Tone.js instruments and loops
        let melodySynth;
        let bassSynth;
        let kickDrum;
        let snareDrum;
        let hiHat;
        let padSynth;
        let leadSynth;
        let arpeggioSynth; 

        // Tone.Channels for individual instrument mixing and routing to effects
        let melodyChannel;
        let bassChannel;
        let drumChannel; // Shared for all drums (kick, snare, hi-hat)
        let padChannel;
        let leadChannel;
        let arpeggioChannel; 

        // Tone.Part instances for sequencing musical patterns
        let melodyLoop;
        let bassLoop;
        let drumLoop;
        let padLoop;
        let leadLoop;
        let arpeggioLoop; 

        let isToneInitialized = false; // Flag to ensure Tone.js components are initialized only once 

        /**
         * Initializes all Tone.js instruments, effects, and musical loops.
         * This function is designed to be called only once after the user's first interaction,
         * ensuring the audio context is properly started by the browser.
         */
        function initializeToneComponents() {
            if (isToneInitialized) return; // Prevent re-initialization if already done 

            try {
                console.log('Initializing Tone.js components...'); 

                // --- Master Effects Chain for overall sound shaping and clarity ---
                // All instruments will eventually route through this chain. 

                // 1. Highpass Filter: Cuts out unwanted low-end rumble (below 120Hz) to clean up the mix.
                // Adjusted from 80Hz to 120Hz for a cleaner low end.
                const highpassFilter = new Tone.Filter(120, "highpass"); 

                // 2. Compressor: Reduces the dynamic range, making the track sound louder and more cohesive ("glued").
                const compressor = new Tone.Compressor({
                    threshold: -24, // Softer threshold to catch more of the signal
                    ratio: 4,      // Moderate compression ratio
                    attack: 0.01,  // Fast attack to catch transients
                    release: 0.2   // Moderate release
                }); 

                // 3. Lowpass Filter: Gently rolls off harsh high frequencies (above 8000Hz) for a smoother sound.
                // Adjusted from 16000Hz to 8000Hz to reduce harsh highs.
                const lowpassFilter = new Tone.Filter(8000, "lowpass"); 

                // 4. Limiter: Prevents the master output from exceeding -1dB, avoiding digital clipping and distortion.
                const limiter = new Tone.Limiter(-1).toDestination(); // Connects directly to your speakers/headphones 

                // Connect the master effects chain in sequence:
                // highpassFilter -> compressor -> lowpassFilter -> limiter -> Destination
                highpassFilter.connect(compressor);
                compressor.connect(lowpassFilter);
                lowpassFilter.connect(limiter);
                console.log('Master effects chain connected.');
                
                // --- Auxiliary Effects (Reverb, Chorus, Delay) ---
                // These effects are sent to the highpassFilter, meaning their output also goes through the master chain. 

                // Reverb: Adds spaciousness and depth to the sound.
                // Decay and wetness reduced for a lighter, less muddy reverb.
                const reverb = new Tone.Reverb({
                    decay: 1.2,    // Shorter decay for a less muddy sound (was 2.0)
                    preDelay: 0.005, // Small pre-delay (was 0.01)
                    wet: 0.1       // Low wetness to keep the mix clear (was 0.2)
                }).connect(highpassFilter); // Route reverb output to the master highpass filter
                console.log('Reverb initialized and connected.');


                // Chorus: Creates a thicker, richer sound by slightly detuning and delaying copies of the signal.
                // Settings adjusted for a softer, less obtrusive effect.
                const chorus = new Tone.Chorus(2, 1.5, 0.1).connect(highpassFilter); // (was 4, 2.5, 0.3)
                console.log('Chorus initialized and connected.'); 

                // Delay: Creates echoes.
                const delay = new Tone.FeedbackDelay("8n", 0.3).connect(highpassFilter); // Short delay time, low feedback
                console.log('Delay initialized and connected.'); 

                // --- Instruments and their Tone.Channels ---
                // Each instrument has its own Tone.Channel for volume control and sending to effects. 

                // Melody Synth: Bright sawtooth wave for a clear, cutting melody.
                melodySynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.02, decay: 0.4, sustain: 0.1, release: 0.8 }
                });
                // Volume adjusted lower to sit better in the mix (was -7dB).
                melodyChannel = new Tone.Channel(-10, 0).connect(highpassFilter); // Connect to master chain
                melodySynth.connect(melodyChannel); // Synth -> Channel
                melodyChannel.send(reverb, 0.2); // Send some melody to reverb
                melodyChannel.send(chorus, 0.5); // Send some melody to chorus
                console.log('Melody Synth initialized and connected.'); 

                // Bass Synth: Smooth triangle wave for a solid, non-aggressive bassline.
                bassSynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0.2, release: 1.2 }
                });
                // Volume adjusted lower for a more subtle bass presence (was -8dB).
                bassChannel = new Tone.Channel(-12, 0).connect(highpassFilter); // Lower volume for bass
                bassSynth.connect(bassChannel);
                console.log('Bass Synth initialized and connected.'); 

                // Drum Channel: A single channel for all drums to control their collective volume and send to effects.
                drumChannel = new Tone.Channel(-4, 0).connect(highpassFilter); // Connect to master chain
                console.log('Drum Channel initialized and connected.'); 

                // Kick Drum: Deep, punchy kick sound.
                kickDrum = new Tone.MembraneSynth({
                    pitchDecay: 0.05, octaves: 8,
                    envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.2, attackCurve: "exponential" }
                });
                kickDrum.connect(drumChannel); // Kick -> Drum Channel
                console.log('Kick Drum initialized and connected.'); 

                // Snare Drum: Sharp white noise snare.
                snareDrum = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.12 }
                });
                snareDrum.connect(drumChannel); // Snare -> Drum Channel
                console.log('Snare Drum initialized and connected.'); 

                // Hi-Hat: Crisp metal synth for rhythmic accents. Parameters are tuned for less harshness.
                hiHat = new Tone.MetalSynth({
                    frequency: 180, // Slightly lower frequency for a softer sound
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0.0, release: 0.06 }, // Shorter release for tighter sound
                    harmonicity: 4.5, // Reduced for less metallic harshness
                    modulationIndex: 25, // Reduced for less metallic harshness
                    resonance: 2500, // Reduced for less metallic harshness
                    octaves: 1.2 // Reduced for a more focused sound
                });
                hiHat.connect(drumChannel); // Hi-Hat -> Drum Channel
                console.log('Hi-Hat initialized and connected.'); 

                // Pad Synth: FM synth for a sustained, atmospheric background.
                padSynth = new Tone.FMSynth({
                    harmonicity: 3.01, modulationIndex: 14,
                    envelope: { attack: 2, decay: 0.3, sustain: 0.9, release: 3.0 }, // Long attack and release for a soft pad
                    modulation: { type: "square" },
                    modulationEnvelope: { attack: 0.5, decay: 0.01, sustain: 1, release: 0.5 }
                });
                padChannel = new Tone.Channel(-12, 0).connect(highpassFilter); // Very low volume for background
                padSynth.connect(padChannel);
                padChannel.send(reverb, 0.7); // More reverb for an airy pad sound
                console.log('Pad Synth initialized and connected.'); 

                // Lead Synth: DuoSynth for a rich, expressive lead melody.
                leadSynth = new Tone.DuoSynth({
                    vibratoAmount: 0.5, vibratoRate: 5, harmonicity: 1.5,
                    voice0: { volume: -10, oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.5, release: 0.8 } },
                    voice1: { volume: -15, oscillator: { type: "sine" }, envelope: { attack: 0.05, decay: 0.1, sustain: 0.3, release: 0.6 } },
                    filterEnvelope: { baseFrequency: 200, octaves: 2, attack: 0.01, decay: 0.2, sustain: 1, release: 0.7 }
                });
                // Volume adjusted lower for a more balanced lead (was -5dB).
                leadChannel = new Tone.Channel(-8, 0).connect(highpassFilter);
                leadSynth.connect(leadChannel);
                leadChannel.send(delay, 0.4); // Send to delay
                leadChannel.send(reverb, 0.4); // Send to reverb
                console.log('Lead Synth initialized and connected.'); 

                // Arpeggio Synth: Triangle wave for a clean, rhythmic arpeggio.
                arpeggioSynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 }
                });
                arpeggioChannel = new Tone.Channel(-11, 0).connect(highpassFilter);
                arpeggioSynth.connect(arpeggioChannel); 
                arpeggioChannel.send(reverb, 0.5);
                console.log('Arpeggio Synth initialized and connected.');


                // --- Musical Composition: Defining the patterns and tempo --- 

                // Set a fast tempo for an energetic feel
                Tone.Transport.bpm.value = 140; // Beats Per Minute
                console.log('Tempo set to 140 BPM.'); 

                // Define a common chord progression (C Major, G Major, A minor, F Major) for 4 measures
                const chordsProgression = [
                    ['C4', 'E4', 'G4', 'C5'], // C Major chord
                    ['G4', 'B4', 'D5', 'G5'], // G Major chord
                    ['A4', 'C5', 'E5', 'A5'], // A minor chord
                    ['F4', 'A4', 'C5', 'F5']  // F Major chord
                ]; 

                // Melody notes pattern, following the chord progression
                const melodyNotesPattern = [
                    // Measure 1 - Revised for a more active, higher-pitched feel
                    { time: '0:0:0', notes: ['C5'] }, // Start strong and high
                    { time: '0:0:2', notes: ['E5'] },
                    { time: '0:1:0', notes: ['G5'] },
                    { time: '0:1:2', notes: ['C6'] }, // Even higher for impact
                    { time: '0:2:0', notes: ['G5'] }, // Descend into the next chord
                    { time: '0:2:2', notes: ['B4'] },
                    { time: '0:3:0', notes: ['D5'] },
                    { time: '0:3:2', notes: ['C5'] }, 

                    // Measure 2 (unchanged, as it was successful)
                    { time: '1:0:0', notes: chordsProgression[2] },
                    { time: '1:1:2', notes: ['E5', 'D5'] },
                    { time: '1:2:0', notes: chordsProgression[3] },
                    { time: '1:3:2', notes: ['C5', 'A4'] }, 

                    // Measure 3 (unchanged)
                    { time: '2:0:0', notes: chordsProgression[0] },
                    { time: '2:1:2', notes: ['G4', 'A4'] },
                    { time: '2:2:0', notes: chordsProgression[1] },
                    { time: '2:3:2', notes: ['B4', 'C5'] }, 

                    // Measure 4 (unchanged)
                    { time: '3:0:0', notes: chordsProgression[2] },
                    { time: '3:1:2', notes: ['G4', 'F4'] },
                    { time: '3:2:0', notes: chordsProgression[3] },
                    { time: '3:3:2', notes: ['E4', 'D4'] }
                ]; 

                // Bass line pattern, playing the root notes of the progression
                const bassNotesPattern = [
                    { time: '0:0:0', note: 'C2' }, { time: '0:2:0', note: 'G2' },
                    { time: '1:0:0', note: 'A2' }, { time: '1:2:0', note: 'F2' },
                    { time: '2:0:0', note: 'C2' }, { time: '2:2:0', note: 'G2' },
                    { time: '3:0:0', note: 'A2' }, { time: '3:2:0', note: 'F2' }
                ]; 

                // Pad chords pattern, sustained for harmony
                const padChordsPattern = [
                    { time: '0:0:0', chords: ['C3', 'E3', 'G3'] },
                    { time: '1:0:0', chords: ['G3', 'B3', 'D4'] },
                    { time: '2:0:0', chords: ['A3', 'C4', 'E4'] },
                    { time: '3:0:0', chords: ['F3', 'A3', 'C4'] }
                ]; 

                // Lead melody pattern, expressive and varied
                const leadMelodyNotesPattern = [
                    { time: '0:0:0', note: 'C5' },
                    { time: '0:1:0', note: 'D5' },
                    { time: '0:2:0', note: 'E5' },
                    { time: '0:3:0', note: 'G5' }, 

                    { time: '1:0:0', note: 'A5' },
                    { time: '1:1:0', note: 'G5' },
                    { time: '1:2:0', note: 'E5' },
                    { time: '1:3:0', note: 'D5' }, 

                    { time: '2:0:0', note: 'C5' },
                    { time: '2:1:0', note: 'E5' },
                    { time: '2:2:0', note: 'G5' },
                    { time: '2:3:0', note: 'A5' }, 

                    { time: '3:0:0', note: 'G5' },
                    { time: '3:1:0', note: 'F5' },
                    { time: '3:2:0', note: 'E5' },
                    { time: '3:3:0', note: 'D4' }
                ]; 

                // Arpeggio pattern, based on the chord progression, played quickly
                const arpeggioPattern = [
                    { time: '0:0:0', notes: ['C4', 'E4', 'G4', 'C5'] },
                    { time: '0:1:0', notes: ['G4', 'B4', 'D5', 'G5'] },
                    { time: '0:2:0', notes: ['A4', 'C5', 'E5', 'A5'] },
                    { time: '0:3:0', notes: ['F4', 'A4', 'C5', 'F5'] }
                ]; 

                // Drum pattern, providing a dynamic beat with a simple fill at the end of the 4th measure
                const drumPattern = [
                    // Measure 1
                    { time: '0:0:0', instrument: 'kick' },
                    { time: '0:0:2', instrument: 'hihat' },
                    { time: '0:1:0', instrument: 'snare' },
                    { time: '0:1:2', instrument: 'hihat' },
                    { time: '0:2:0', instrument: 'kick' },
                    { time: '0:2:2', instrument: 'hihat' },
                    { time: '0:3:0', instrument: 'snare' },
                    { time: '0:3:2', instrument: 'hihat' }, 

                    // Measure 2
                    { time: '1:0:0', instrument: 'kick' },
                    { time: '1:0:2', instrument: 'hihat' },
                    { time: '1:1:0', instrument: 'snare' },
                    { time: '1:1:2', instrument: 'hihat' },
                    { time: '1:2:0', instrument: 'kick' },
                    { time: '1:2:2', instrument: 'hihat' },
                    { time: '1:3:0', instrument: 'snare' },
                    { time: '1:3:2', instrument: 'hihat' }, 

                    // Measure 3
                    { time: '2:0:0', instrument: 'kick' },
                    { time: '2:0:2', instrument: 'hihat' },
                    { time: '2:1:0', instrument: 'snare' },
                    { time: '2:1:2', instrument: 'hihat' },
                    { time: '2:2:0', instrument: 'kick' },
                    { time: '2:2:2', instrument: 'hihat' },
                    { time: '2:3:0', instrument: 'snare' },
                    { time: '2:3:2', instrument: 'hihat' }, 

                    // Measure 4 (with a simple fill)
                    { time: '3:0:0', instrument: 'kick' },
                    { time: '3:0:2', instrument: 'hihat' },
                    { time: '3:1:0', instrument: 'snare' },
                    { time: '3:1:2', instrument: 'hihat' },
                    { time: '3:2:0', instrument: 'kick' },
                    { time: '3:2:2', instrument: 'hihat' },
                    { time: '3:3:0', instrument: 'snare' },
                    { time: '3:3:1', instrument: 'hihat' }, // Faster hi-hat for fill
                    { time: '3:3:2', instrument: 'kick' },  // Quick kick for fill
                    { time: '3:3:3', instrument: 'snare' }  // Quick snare for fill
                ];


                // Create Tone.Part instances for each musical section
                // These parts loop continuously once started with Tone.Transport 

                melodyLoop = new Tone.Part((time, value) => {
                    melodySynth.triggerAttackRelease(value.notes, '8n', time);
                }, melodyNotesPattern);
                melodyLoop.loop = true; // Loop the pattern indefinitely
                melodyLoop.start(0); // Start at the beginning of the transport
                console.log('Melody loop created and started.'); 

                bassLoop = new Tone.Part((time, value) => {
                    bassSynth.triggerAttackRelease(value.note, '4n', time);
                }, bassNotesPattern);
                bassLoop.loop = true;
                bassLoop.start(0);
                console.log('Bass loop created and started.'); 

                padLoop = new Tone.Part((time, value) => {
                    padSynth.triggerAttackRelease(value.chords, '2n', time);
                }, padChordsPattern);
                padLoop.loop = true;
                padLoop.start(0);
                console.log('Pad loop created and started.'); 

                leadLoop = new Tone.Part((time, value) => {
                    leadSynth.triggerAttackRelease(value.note, '8n', time);
                }, leadMelodyNotesPattern);
                leadLoop.loop = true;
                leadLoop.start(0);
                console.log('Lead loop created and started.'); 

                arpeggioLoop = new Tone.Part((time, value) => {
                    const chord = value.notes;
                    if (chord && chord.length > 0) {
                        const duration = '16n'; // Play each note as a 16th note
                        // Trigger each note in the chord sequentially to create the arpeggio effect
                        for (let i = 0; i < chord.length; i++) {
                            arpeggioSynth.triggerAttackRelease(chord[i], duration, time + Tone.Time(duration).toSeconds() * i);
                        }
                    }
                }, arpeggioPattern);
                arpeggioLoop.loop = true;
                arpeggioLoop.start(0);
                console.log('Arpeggio loop created and started.'); 

                drumLoop = new Tone.Part((time, value) => {
                    // Trigger the appropriate drum sound based on the pattern
                    if (value.instrument === 'kick') {
                        kickDrum.triggerAttackRelease('C2', '8n', time);
                    } else if (value.instrument === 'snare') {
                        snareDrum.triggerAttackRelease('8n', time);
                    } else if (value.instrument === 'hihat') {
                        hiHat.triggerAttackRelease('C5', '16n', time, 0.5); // C5 is a common arbitrary note for hi-hats
                    }
                }, drumPattern);
                drumLoop.loop = true;
                drumLoop.start(0);
                console.log('Drum loop created and started.'); 

                isToneInitialized = true; // Mark components as initialized
                console.log('Tone.js components initialized successfully.'); 

            } catch (error) {
                console.error('Error initializing Tone.js components:', error);
                // No need for showMessage here, as it's an internal error.
            }
        }

        // Initialize Three.js scene
        function initThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200); // Add fog for distance
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 5); // Set camera position
            // camera.lookAt(0, 0, 0); // Point camera towards origin - This will be updated in animate loop
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('game-canvas'),
                antialias: true // Anti-aliasing
            });
            renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer size to fit window
            renderer.setPixelRatio(window.devicePixelRatio); // Adjust device pixel ratio
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Ambient light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Directional light (sun)
            directionalLight.position.set(10, 20, 15);
            scene.add(directionalLight);
            
            // Create player (now a group of meshes)
            player = new THREE.Group(); // Player is now a group of shapes
            player.name = 'playerGroup'; // Group name for easy tracking

            // Material for fixed parts (head, arms, legs)
            const limbMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc }); // Light gray color

            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.5);
            const playerMaterial = new THREE.MeshPhongMaterial({ color: 0xff6600 }); // Default orange body material
            playerBodyMesh = new THREE.Mesh(bodyGeometry, playerMaterial); // Store reference to body mesh
            playerBodyMesh.position.y = 0; // Center of the body relative to group origin
            playerBodyMesh.name = 'playerBody'; // Name for easy retrieval
            player.add(playerBodyMesh);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 32, 16);
            playerHeadMesh = new THREE.Mesh(headGeometry, limbMaterial); // Store reference to head mesh
            playerHeadMesh.position.y = playerBodyMesh.position.y + 0.4 + 0.25; // On top of the body
            player.add(playerHeadMesh);

            // Hat - Added a simple hat (cylinder)
            const hatCylinderGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 32); // Top part of the hat
            const hatBrimGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.05, 32); // Brim of the hat
            const hatMaterial = new THREE.MeshPhongMaterial({ color: playerMaterial.color.getHex() }); // Match player body color
            
            const hatCylinder = new THREE.Mesh(hatCylinderGeometry, hatMaterial);
            hatCylinder.position.y = playerHeadMesh.position.y + 0.15; // Position on top of the head

            const hatBrim = new THREE.Mesh(hatBrimGeometry, hatMaterial);
            hatBrim.position.y = playerHeadMesh.position.y + 0.05; // Position just above the head

            playerHatMesh = new THREE.Group(); // Group hat parts
            playerHatMesh.add(hatCylinder);
            playerHatMesh.add(hatBrim);
            playerHatMesh.name = 'playerHat';
            player.add(playerHatMesh); // Add hat group to player group

            // Arms - Store references for animation
            const armGeometry = new THREE.BoxGeometry(0.2, 0.7, 0.2);
            playerLeftArm = new THREE.Mesh(armGeometry, limbMaterial);
            playerLeftArm.position.set(-0.35, playerBodyMesh.position.y, 0);
            player.add(playerLeftArm);

            playerRightArm = new THREE.Mesh(armGeometry, limbMaterial);
            playerRightArm.position.set(0.35, playerBodyMesh.position.y, 0);
            player.add(playerRightArm);

            // Legs - Store references for animation
            const legGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            playerLeftLeg = new THREE.Mesh(legGeometry, limbMaterial);
            playerLeftLeg.position.set(-0.15, -0.45, 0); // Base of leg at -0.85 relative to group center
            player.add(playerLeftLeg);

            playerRightLeg = new THREE.Mesh(legGeometry, limbMaterial);
            playerRightLeg.position.set(0.15, -0.45, 0); // Base of leg at -0.85 relative to group center
            player.add(playerRightLeg);
            
            scene.add(player);
            
            // Create multiple ground segments for the road (black)
            const roadGeometry = new THREE.PlaneGeometry(10, SEGMENT_LENGTH); 
            const roadMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x000000, // لون أسود للطريق
                side: THREE.DoubleSide // Display both sides
            });
            for (let i = 0; i < NUM_SEGMENTS; i++) {
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = Math.PI / 2; // Rotate road to be horizontal
                road.position.z = GROUND_Z_OFFSET + i * SEGMENT_LENGTH; // Position each road piece
                scene.add(road);
                groundSegments.push(road);
            }

            // Create multiple side ground segments (brown)
            const sideGroundGeometry = new THREE.PlaneGeometry(SIDE_GROUND_WIDTH, SEGMENT_LENGTH);
            const sideGroundMaterial = new THREE.MeshPhongMaterial({
                color: 0xA0522D, // لون بني للأرض الجانبية
                side: THREE.DoubleSide
            });
            for (let i = 0; i < NUM_SEGMENTS; i++) {
                // Left side ground
                const leftSideGround = new THREE.Mesh(sideGroundGeometry, sideGroundMaterial);
                leftSideGround.rotation.x = Math.PI / 2;
                leftSideGround.position.set(-SIDE_GROUND_OFFSET_X, 0, GROUND_Z_OFFSET + i * SEGMENT_LENGTH);
                scene.add(leftSideGround);
                sideGroundSegments.push(leftSideGround);

                // Right side ground
                const rightSideGround = new THREE.Mesh(sideGroundGeometry, sideGroundMaterial);
                rightSideGround.rotation.x = Math.PI / 2;
                rightSideGround.position.set(SIDE_GROUND_OFFSET_X, 0, GROUND_Z_OFFSET + i * SEGMENT_LENGTH);
                scene.add(rightSideGround);
                sideGroundSegments.push(rightSideGround);
            }
            
            // Create multiple rail segments
            for (let j = 0; j < 3; j++) { // 3 lanes
                for (let i = 0; i < NUM_SEGMENTS; i++) {
                    const railGeometry = new THREE.BoxGeometry(0.1, 0.1, SEGMENT_LENGTH); // Rail shape
                    const railMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc }); // Light gray color
                    const rail = new THREE.Mesh(railGeometry, railMaterial);
                    rail.position.set(lanePositions[j], 0.05, GROUND_Z_OFFSET + i * SEGMENT_LENGTH); // Position rail
                    scene.add(rail);
                    railSegments.push(rail);
                }
            }
            
            // Generate initial obstacles and coins
            generateObstacles(25); // Reduced number of obstacles
            generateCoins(60); 

            // Generate buildings on the sides
            generateBuildings(NUM_BUILDINGS_PER_SIDE); 

            // Generate trees on the sides
            generateTrees(NUM_TREES_PER_SIDE);
            
            // Start game loop
            animate();
        }
        
        // Generate obstacles
        function generateObstacles(count) {
            for (let i = 0; i < count; i++) {
                // Changed obstacle height to be thinner
                const obstacleGeometry = new THREE.BoxGeometry(1, 0.7, 1); // Cube shape for obstacle, thinner height
                const obstacleMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 }); // Red color
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.name = 'obstacle'; // Object name
                obstacle.visible = false; // Hide obstacle initially
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
            resetObstacles(); // Reset obstacle positions
        }
        
        // Generate coins
        function generateCoins(count) {
            for (let i = 0; i < count; i++) {
                const coinGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 32); // Cylinder shape for coin
                const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700 }); // Gold color
                const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                coin.rotation.x = Math.PI / 2; // Rotate coin to be horizontal
                coin.name = 'coin'; // Object name
                coin.visible = false; // Hide coin initially
                scene.add(coin);
                coins.push(coin);
            }
            resetCoins(); // Reset coin positions
        }

        // Generate buildings (houses) - Modified for new positioning and windows
        function generateBuildings(count) {
            for (let i = 0; i < count; i++) {
                const buildingHeight = 2 + Math.random() * 4; // Random building height
                const buildingWidth = 1 + Math.random() * 1; // Random building width
                const buildingDepth = 10; // Depth of the building

                const buildingGeometry = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
                const buildingMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color(Math.random() * 0xffffff) // Random building color
                });
                const buildingMesh = new THREE.Mesh(buildingGeometry, buildingMaterial);
                buildingMesh.position.y = buildingHeight / 2; // Position building on the ground

                const roofGeometry = new THREE.ConeGeometry(buildingWidth * 0.7, buildingWidth * 0.5, 4); // Cone roof shape
                const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Brown roof color
                const roofMesh = new THREE.Mesh(roofGeometry, roofMaterial);
                roofMesh.position.y = buildingHeight + roofGeometry.parameters.height / 2; // Position roof above building

                const buildingGroup = new THREE.Group(); // Group building and roof
                buildingGroup.add(buildingMesh);
                buildingGroup.add(roofMesh);

                // Add blue rectangular windows
                const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x00BFFF }); // DeepSkyBlue color for windows
                const windowDepth = 0.1; // Thin window
                const windowWidth = buildingWidth * 0.2;
                const windowHeight = buildingHeight * 0.15;

                // Add multiple windows on the front face (positive Z)
                const numWindowsX = Math.max(1, Math.floor(buildingWidth / (windowWidth * 1.5)));
                const numWindowsY = Math.max(1, Math.floor(buildingHeight / (windowHeight * 1.5)));

                for (let wx = 0; wx < numWindowsX; wx++) {
                    for (let wy = 0; wy < numWindowsY; wy++) {
                        if (Math.random() > 0.2) { // Randomly skip some windows for variety
                            const windowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);
                            const windowMeshFront = new THREE.Mesh(windowGeometry, windowMaterial);

                            // Position windows on the front face of the building
                            windowMeshFront.position.x = (wx - (numWindowsX - 1) / 2) * (buildingWidth / numWindowsX);
                            windowMeshFront.position.y = (wy - (numWindowsY - 1) / 2) * (buildingHeight / numWindowsY) + buildingHeight / 2;
                            windowMeshFront.position.z = buildingDepth / 2 + windowDepth / 2; // On the front face

                            buildingGroup.add(windowMeshFront);

                            // Add windows on the back face (negative Z)
                            const windowMeshBack = new THREE.Mesh(windowGeometry, windowMaterial);
                            windowMeshBack.position.x = (wx - (numWindowsX - 1) / 2) * (buildingWidth / numWindowsX);
                            windowMeshBack.position.y = (wy - (numWindowsY - 1) / 2) * (buildingHeight / numWindowsY) + buildingHeight / 2;
                            windowMeshBack.position.z = -buildingDepth / 2 - windowDepth / 2; // On the back face
                            
                            buildingGroup.add(windowMeshBack);
                        }
                    }
                }

                buildingGroup.name = 'building';
                buildingGroup.visible = false; // Hide group initially
                scene.add(buildingGroup);
                buildingGroups.push(buildingGroup);
            }
            resetBuildings(); // Reset building positions
        }

        // Generate trees
        function generateTrees(count) {
            for (let i = 0; i < count; i++) {
                const trunkHeight = 2 + Math.random() * 2; // Random trunk height
                const trunkRadius = 0.2 + Math.random() * 0.1; // Random trunk radius

                const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius, trunkHeight, 8);
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Brown trunk color

                const leavesHeight = 1.5 + Math.random() * 1.5; // Random leaves height
                const leavesRadius = 1 + Math.random() * 0.5; // Random leaves radius

                const leavesGeometry = new THREE.ConeGeometry(leavesRadius, leavesHeight, 16); // Cone for tree leaves
                const leavesMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 }); // Forest green leaves color

                const trunkMesh = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunkMesh.position.y = trunkHeight / 2; // Position trunk on the ground

                const leavesMesh = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leavesMesh.position.y = trunkHeight + leavesHeight / 2 - 0.2; // Position leaves above trunk

                const treeGroup = new THREE.Group(); // Group trunk and leaves
                treeGroup.add(trunkMesh);
                treeGroup.add(leavesMesh);
                treeGroup.name = 'tree';
                treeGroup.visible = false; // Hide group initially
                scene.add(treeGroup);
                treeGroups.push(treeGroup);
            }
            resetTrees(); // Reset tree positions
        }

        // Reset obstacle positions - Increased initial spacing
        function resetObstacles() {
            obstacles.forEach((obstacle, i) => {
                const laneIndex = Math.floor(Math.random() * 3); // Choose random lane
                // Obstacle position adjusted for new thinner height
                obstacle.position.set(lanePositions[laneIndex], 0.35, -50 - i * (10 + Math.random() * 10)); // Position obstacle with more spacing
                obstacle.visible = true;
            });
        }

        // Reset coin positions
        function resetCoins() {
            coins.forEach((coin, i) => {
                const laneIndex = Math.floor(Math.random() * 3); // Choose random lane
                coin.position.set(lanePositions[laneIndex], 1, -30 - i * (3 + Math.random() * 3)); // Position coin
                coin.visible = true;
            });
        }

        // Reset building positions - Modified to place buildings closer to the road on side ground
        function resetBuildings() {
            buildingGroups.forEach((building, i) => {
                const side = Math.random() < 0.5 ? -1 : 1; // Choose random side (-1: left, 1: right)
                // Position buildings on the brown side ground, closer to the road
                const xPosition = side * (BUILDING_X_POSITION_ON_SIDE + Math.random() * 1); // إضافة عشوائية بسيطة للموضع
                building.position.set(xPosition, 0, -50 - i * BUILDING_SPACING + Math.random() * 10); // Position building
                building.visible = true;
            });
        }

        // Reset tree positions - Modified to place trees further out on side ground
        function resetTrees() {
            treeGroups.forEach((tree, i) => {
                const side = Math.random() < 0.5 ? -1 : 1; // Choose random side (-1: left, 1: right)
                // Position trees on the brown side ground, further from the road
                const xPosition = side * (TREE_X_POSITION_ON_SIDE + Math.random() * 2); // إضافة عشوائية بسيطة للموضع
                tree.position.set(xPosition, 0, -50 - i * TREE_SPACING + Math.random() * 10); // Position tree
                tree.visible = true;
            });
        }
        
        // Handle player movement (position and scale)
        function handlePlayerMovement() {
            // Horizontal movement (smooth lane change using Lerp)
            player.position.x = THREE.MathUtils.lerp(player.position.x, lanePositions[lane], 0.2);
            
            // Jump movement
            if (isJumping) {
                const elapsed = performance.now() - jumpStartTime; // Time elapsed since jump start
                let progress = elapsed / jumpDuration; // Jump progress (0 to 1)
                
                if (progress < 1) {
                    // Calculate player height using a quadratic function for a smooth jump
                    player.position.y = playerBaseY + jumpHeight * (4 * progress * (1 - progress));
                } else {
                    player.position.y = playerBaseY; // Return player to base height
                    isJumping = false; // End jump state
                }
            }
            
            // Slide movement
            if (isSliding) {
                const elapsed = performance.now() - slideStartTime; // Time elapsed since slide start
                let progress = elapsed / slideDuration; // Slide progress (0 to 1)

                if (progress < 1) {
                    // Change player's vertical scale for sliding
                    player.scale.y = THREE.MathUtils.lerp(1, 0.5, Math.sin(progress * Math.PI));
                    // Adjust player's Y position to keep its base on the ground
                    player.position.y = playerBaseY - (playerActualHeight / 2) * (1 - player.scale.y);
                } else {
                    player.scale.y = 1; // Reset player's original scale
                    player.position.y = playerBaseY; // Return player to base height
                    isSliding = false; // End slide state
                }
            }
        }

        // Handle player leg and arm animation (running, jumping, sliding)
        function handlePlayerAnimation(deltaTime) {
            if (!playerLeftLeg || !playerRightLeg || !playerLeftArm || !playerRightArm) return; // Ensure all limbs exist

            // Reset leg and arm rotations for normal state
            playerLeftLeg.rotation.x = 0;
            playerRightLeg.rotation.x = 0;
            playerLeftArm.rotation.x = 0;
            playerRightArm.rotation.x = 0;
            playerLeftArm.position.y = playerBodyMesh.position.y;
            playerRightArm.position.y = playerBodyMesh.position.y;

            if (isJumping) {
                const elapsed = performance.now() - jumpStartTime;
                let progress = elapsed / jumpDuration;
                // Legs extend more during jump
                const jumpRotation = Math.sin(progress * Math.PI) * Math.PI * jumpLegRotationFactor;
                playerLeftLeg.rotation.x = jumpRotation;
                playerRightLeg.rotation.x = -jumpRotation;

                // Arms raise slightly during jump
                const armJumpRotationValue = Math.sin(progress * Math.PI) * armJumpRotation;
                playerLeftArm.rotation.x = -armJumpRotationValue; // Arms might swing back
                playerRightArm.rotation.x = armJumpRotationValue; // Arms might swing forward
                playerLeftArm.position.y = playerBodyMesh.position.y + armJumpRotationValue * 0.5;
                playerRightArm.position.y = playerBodyMesh.position.y + armJumpRotationValue * 0.5;

            } else if (isSliding) {
                // Legs go horizontal for sliding
                playerLeftLeg.rotation.x = Math.PI / 2; // Rotate to be flat
                playerRightLeg.rotation.x = Math.PI / 2; // Rotate to be flat
                // Adjust position slightly to align with flattened body
                playerLeftLeg.position.y = -0.45 - (0.8 * (1 - player.scale.y));
                playerRightLeg.position.y = -0.45 - (0.8 * (1 - player.scale.y));

                // Arms come closer to body for sliding
                playerLeftArm.rotation.x = Math.PI / 4; // Arms forward
                playerRightArm.rotation.x = Math.PI / 4;
                playerLeftArm.position.y = playerBodyMesh.position.y - (0.8 * (1 - player.scale.y));
                playerRightArm.position.y = playerBodyMesh.position.y - (0.8 * (1 - player.scale.y));

            } else {
                // Running animation
                runAnimationTime += deltaTime * runSpeedFactor * speed * 10; // Speed up animation with game speed
                const legSwing = Math.sin(runAnimationTime) * Math.PI * 0.2; // Swing amplitude
                playerLeftLeg.rotation.x = legSwing;
                playerRightLeg.rotation.x = -legSwing;
                // Reset leg Y position if not sliding
                playerLeftLeg.position.y = -0.45;
                playerRightLeg.position.y = -0.45;

                // Arm swing during run (opposite to legs for natural movement)
                const armSwing = Math.sin(runAnimationTime + Math.PI) * armSwingAmplitude; // Opposite phase to legs
                playerLeftArm.rotation.x = armSwing;
                playerRightArm.rotation.x = -armSwing;
                // Reset arm Y position if not sliding
                playerLeftArm.position.y = playerBodyMesh.position.y;
                playerRightArm.position.y = playerBodyMesh.position.y;
            }
        }
        
        // Update game state
        function updateGame(deltaTime) {
            if (!gameActive) {
                return; // Do nothing if game is not active
            }
            
            // Move ground segments (road)
            groundSegments.forEach(segment => {
                segment.position.z += speed; // Move towards camera
                if (segment.position.z > camera.position.z + (SEGMENT_LENGTH * NUM_SEGMENTS / 2)) {
                    segment.position.z -= SEGMENT_LENGTH * NUM_SEGMENTS; // Recycle segment after passing camera
                }
            });

            // Move side ground segments
            sideGroundSegments.forEach(segment => {
                segment.position.z += speed; // Move towards camera
                if (segment.position.z > camera.position.z + (SEGMENT_LENGTH * NUM_SEGMENTS / 2)) {
                    segment.position.z -= SEGMENT_LENGTH * NUM_SEGMENTS; // Recycle segment after passing camera
                }
            });

            // Move rail segments
            railSegments.forEach(segment => {
                segment.position.z += speed; // Move towards camera
                if (segment.position.z > camera.position.z + (SEGMENT_LENGTH * NUM_SEGMENTS / 2)) {
                    segment.position.z -= SEGMENT_LENGTH * NUM_SEGMENTS; // Recycle rail
                }
            });

            // Move building groups
            buildingGroups.forEach(group => {
                group.position.z += speed; // Move towards camera
                if (group.position.z > camera.position.z + (BUILDING_SPACING * NUM_BUILDINGS_PER_SIDE / 2)) {
                    const side = group.position.x > 0 ? 1 : -1; // Determine current side
                    group.position.z -= BUILDING_SPACING * NUM_BUILDINGS_PER_SIDE; // Recycle building
                    // Reposition building on the same side, maintaining its X offset
                    const xPosition = side * (BUILDING_X_POSITION_ON_SIDE + Math.random() * 1);
                    group.position.x = xPosition; 
                }
            });

            // Move tree groups
            treeGroups.forEach(group => {
                group.position.z += speed; // Move towards camera
                if (group.position.z > camera.position.z + (TREE_SPACING * NUM_TREES_PER_SIDE / 2)) {
                    const side = group.position.x > 0 ? 1 : -1; // Determine current side
                    group.position.z -= TREE_SPACING * NUM_TREES_PER_SIDE; // Recycle tree
                    // Reposition tree on the same side, maintaining its X offset
                    const xPosition = side * (TREE_X_POSITION_ON_SIDE + Math.random() * 2);
                    group.position.x = xPosition;
                }
            });
            
            // Move obstacles
            obstacles.forEach(obstacle => {
                obstacle.position.z += speed; // Move towards camera
                
                // If obstacle passed camera, recycle it - now appears further away
                if (obstacle.position.z > player.position.z + 5) {
                    const laneIndex = Math.floor(Math.random() * 3); // Choose new lane
                    // Obstacle position adjusted for new thinner height
                    obstacle.position.set(lanePositions[laneIndex], 0.35, camera.position.z - 150 - Math.random() * 100); // Position obstacle far away
                    obstacle.visible = true;
                }
                
                // Collision detection
                if (obstacle.visible &&
                    Math.abs(player.position.x - obstacle.position.x) < 0.7 && // Proximity in X axis
                    Math.abs(player.position.z - obstacle.position.z) < 0.7) { // Proximity in Z axis
                    
                    // Calculate player's top and bottom based on its actual height and current scale
                    const playerTop = player.position.y + playerActualHeight * player.scale.y / 2;
                    const playerBottom = player.position.y - playerActualHeight * player.scale.y / 2;
                    // Obstacle top and bottom adjusted for new thinner height
                    const obstacleTop = obstacle.position.y + 0.35; // Assuming obstacle is 0.7 unit tall, centered at 0.35
                    const obstacleBottom = obstacle.position.y - 0.35;

                    // Check for Y-axis overlap (jumping or sliding)
                    if (!(playerTop < obstacleBottom || playerBottom > obstacleTop)) {
                        endGame(obstacle); // End game on collision, passing the collided obstacle
                    }
                }
            });
            
            // Move coins
            coins.forEach(coin => {
                coin.position.z += speed; // Move towards camera
                coin.rotation.y += 0.1; // Rotate coin
                
                // If coin passed camera, recycle it
                if (coin.position.z > player.position.z + 5) {
                    const laneIndex = Math.floor(Math.random() * 3); // Choose new lane
                    coin.position.set(lanePositions[laneIndex], 1, camera.position.z - 80 - Math.random() * 40); // Position coin far away
                    coin.visible = true;
                }
                
                // Collect coins
                if (coin.visible &&
                    Math.abs(player.position.x - coin.position.x) < 0.7 && // Proximity in X axis
                    Math.abs(player.position.z - coin.position.z) < 0.7 && // Proximity in Z axis
                    Math.abs(player.position.y - coin.position.y) < 1) { // Proximity in Y axis
                    coin.visible = false; // Hide collected coin
                    coinsCount++;
                    coinsElement.textContent = coinsCount; // Update coin counter
                    score += 50; // Increase score
                    scoreElement.textContent = score; // Update score counter
                }
            });
            
            // Increase score and speed
            score++;
            scoreElement.textContent = score;
            // Adjusted speed increment for medium speed
            speed = 0.1 + Math.floor(score / 1000) * 0.05; 
        }
        
        // Start game
        async function startGame() {
            gameActive = true;
            startScreen.style.display = 'none'; // Hide start screen
            gameOverScreen.style.display = 'none'; // Hide game over screen
            mathQuestionModal.style.display = 'none'; // Hide question modal
            score = 0;
            coinsCount = 0;
            speed = 0.1; // Reset speed to initial value
            lane = 1; // Reset player to center lane
            player.position.x = lanePositions[lane];
            player.position.y = playerBaseY; // Set initial Y position for the group
            player.scale.y = 1; // Reset player scale
            isJumping = false;
            isSliding = false;
            runAnimationTime = 0; // Reset run animation time

            scoreElement.textContent = score;
            coinsElement.textContent = coinsCount;
            
            // Reset obstacle, coin, and building positions
            resetObstacles();
            resetCoins();
            resetBuildings();
            resetTrees(); 

            // Initialize Tone.js components and start music
            if (Tone.context.state !== 'running') {
                await Tone.start(); // Ensure audio context is running
            }
            if (!isToneInitialized) {
                initializeToneComponents();
            }
            Tone.Transport.start(); // Start all scheduled music events
            console.log('Music started with game.');
        }
        
        // End game
        function endGame(obstacle = null) { // Pass the collided obstacle
            gameActive = false; // Pause the game
            Tone.Transport.stop(); // Stop the music
            console.log('Music stopped due to game over.');

            if (obstacle) {
                collidedObstacle = obstacle; // Store the collided obstacle
                showQuestionModal();
            } else {
                // Normal game over (e.g., if player falls off the map, though not implemented here)
                gameOverScreen.style.display = 'flex';
                finalScoreElement.textContent = `النقاط: ${score}`;
            }
        }

        // Show Math Question Modal
        function showQuestionModal() {
            const randomIndex = Math.floor(Math.random() * mathQuestions.length);
            currentQuestion = mathQuestions[randomIndex];

            questionTextElement.textContent = currentQuestion.question;
            answerInputElement.value = '';
            feedbackMessageElement.textContent = '';
            mathQuestionModal.style.display = 'flex';

            // Render LaTeX after setting the text
            // MathJax.typesetPromise() is used to ensure rendering happens after the element is visible
            MathJax.typesetPromise([questionTextElement]);
        }

        // Check Answer for Math Question
        function checkAnswer() {
            const userAnswer = parseFloat(answerInputElement.value);
            
            if (!isNaN(userAnswer) && userAnswer === currentQuestion.answer) {
                feedbackMessageElement.textContent = 'إجابة صحيحة! استمر في اللعب.';
                feedbackMessageElement.style.color = 'lightgreen';
                setTimeout(() => {
                    mathQuestionModal.style.display = 'none';
                    gameActive = true; // Resume game
                    Tone.Transport.start(); // Resume music
                    if (collidedObstacle) {
                        // Recycle the obstacle immediately upon correct answer
                        const laneIndex = Math.floor(Math.random() * 3);
                        collidedObstacle.position.set(lanePositions[laneIndex], 0.35, camera.position.z - 150 - Math.random() * 100);
                        collidedObstacle.visible = true; // Make it visible again for future use
                        collidedObstacle = null; // Clear reference
                    }
                    score += 100; // Bonus for correct answer
                    scoreElement.textContent = score;
                }, 1500); // Give player a moment to read feedback
            } else {
                feedbackMessageElement.textContent = `إجابة خاطئة. الإجابة الصحيحة هي: ${currentQuestion.answer}. انتهت اللعبة.`;
                feedbackMessageElement.style.color = 'red';
                setTimeout(() => {
                    mathQuestionModal.style.display = 'none';
                    // Game over if answer is incorrect
                    gameOverScreen.style.display = 'flex';
                    finalScoreElement.textContent = `النقاط: ${score}`;
                    // Game state will be reset when restart button is clicked
                }, 2000); // Give player a moment to read feedback before game over screen
            }
        }
        
        let lastFrameTime = 0;
        // Animation loop
        function animate(currentTime) {
            requestAnimationFrame(animate); // Request next frame
            
            const deltaTime = currentTime - lastFrameTime; // Calculate time elapsed between frames
            lastFrameTime = currentTime;

            // Only update game and player animation if game is active
            if (gameActive) {
                handlePlayerMovement(); // Update player movement (position and scale)
                handlePlayerAnimation(deltaTime); // Update player leg and arm animation
                updateGame(deltaTime); // Update game state
            }
            
            // --- Camera movement improvements ---
            // Smoothly move camera's X position towards a target influenced by player's lane
            // The 0.5 factor keeps the camera somewhat centered but still shifts with the player for a wider view
            const targetCameraX = player.position.x * 0.5; 
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, targetCameraX, 0.05); // Smooth transition speed

            // Adjust camera's lookAt target to encompass more of the street
            // Look slightly above the player and slightly ahead to see upcoming obstacles
            const lookAtX = player.position.x; // Still focus on player's X for central alignment
            const lookAtY = player.position.y + 0.5; // Look slightly above the player
            const lookAtZ = player.position.z - 5; // Look slightly ahead of the player

            camera.lookAt(lookAtX, lookAtY, lookAtZ);
            // --- End camera movement improvements ---
            
            renderer.render(scene, camera); // Render scene
        }
        
        // Handle keyboard input
        function handleKeyDown(e) {
            if (!gameActive) return; // Do nothing if game is not active
            
            switch(e.key) {
                // For RTL: ArrowLeft moves player left (increase lane)
                case 'ArrowLeft':
                    if (lane > 0) lane--; // Move left
                    break;
                // For RTL: ArrowRight moves player right (decrease lane)
                case 'ArrowRight':
                    if (lane < 2) lane++; // Move right
                    break;
                case ' ': // Space key for jump
                    if (!isJumping && !isSliding) {
                        isJumping = true;
                        jumpStartTime = performance.now();
                    }
                    break;
                case 'ArrowDown': // Down arrow key for slide
                    if (!isSliding && !isJumping) {
                        isSliding = true;
                        slideStartTime = performance.now();
                    }
                    break;
            }
        }

        // Handle touch input for mobile devices
        function handleTouchStart(e) {
            touchStartX = e.touches[0].clientX; // Record touch start X position
            touchStartY = e.touches[0].clientY; // Record touch start Y position
        }

        function handleTouchEnd(e) {
            if (!gameActive) return; // Do nothing if game is not active

            touchEndX = e.changedTouches[0].clientX; // Record touch end X position
            touchEndY = e.changedTouches[0].clientY; // Record touch end Y position

            const deltaX = touchEndX - touchStartX; // Distance difference in X axis
            const deltaY = touchEndY - touchStartY; // Distance difference in Y axis

            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > swipeThreshold) {
                // Horizontal swipe - corrected here
                if (deltaX > 0) {
                    // Swipe right - move right
                    if (lane < 2) lane++;
                } else {
                    // Swipe left - move left
                    if (lane > 0) lane--;
                }
            } else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > swipeThreshold) {
                // Vertical swipe
                if (deltaY < 0) {
                    // Swipe up (jump)
                    if (!isJumping && !isSliding) {
                        isJumping = true;
                        jumpStartTime = performance.now();
                    }
                } else {
                    // Swipe down (slide)
                    if (!isSliding && !isJumping) {
                        isSliding = true;
                        slideStartTime = performance.now();
                    }
                }
            }
        }
        
        // Initialize game
        function initGame() {
            initThreeJS(); // Initialize Three.js
            
            // Event listeners for buttons
            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', startGame);
            submitAnswerBtn.addEventListener('click', checkAnswer); // Event listener for math question submit button
            
            // Event listeners for keyboard input
            window.addEventListener('keydown', handleKeyDown);
            
            // Event listeners for touch input (for mobile devices)
            window.addEventListener('touchstart', handleTouchStart);
            window.addEventListener('touchend', handleTouchEnd);

            // Add a listener to resume audio context if tab becomes visible again
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && Tone.context.state !== 'running' && gameActive) {
                    console.log('Tab became visible. Attempting to resume Tone.js audio context...');
                    Tone.start().then(() => {
                        console.log('Tone.js audio context resumed successfully on visibility change.');
                    }).catch(error => {
                        console.error('Failed to resume Tone.js audio context on visibility change:', error);
                    });
                }
            });
            
            // Character selection
            characters.forEach((char, index) => {
                char.addEventListener('click', () => {
                    characters.forEach(c => c.classList.remove('selected')); // Remove selection from all
                    char.classList.add('selected'); // Select chosen character
                    
                    let color;
                    switch(index) {
                        case 0: color = 0xff6600; break; // Orange color
                        case 1: color = 0x3366ff; break; // Blue color
                        case 2: color = 0x33cc33; break; // Green color
                    }
                    // Change the color of the player's body mesh and hat
                    if (playerBodyMesh) {
                        playerBodyMesh.material.color.setHex(color); 
                    }
                    if (playerHatMesh) {
                        // Access the hat meshes and update their material color
                        playerHatMesh.children.forEach(mesh => {
                            if (mesh.material) {
                                mesh.material.color.setHex(color);
                            }
                        });
                    }
                });
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; // Update camera aspect ratio
                camera.updateProjectionMatrix(); // Update camera projection matrix
                renderer.setSize(window.innerWidth, window.innerHeight); // Update renderer size
            });
        }
        
        // Start game when window loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>

