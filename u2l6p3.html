<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Waves - لعبة الموجات الفضائية</title>
    <!-- تم إزالة مكتبة MathJax لأن الأسئلة أصبحت نصية وليست معادلات رياضية -->
    <style>
        /* أنماط CSS الأساسية للجسم والتنسيق العام */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #fff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        /* خلفية النجوم المتحركة */
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="1" fill="white" opacity="0.1"/></svg>');
            background-size: 150px 150px;
            opacity: 0.3;
            z-index: -1;
        }

        #gameCanvas {
            background: #000428;
            display: block;
            touch-action: none;
            width: 100vw;
            height: 100vh;
            cursor: none; /* إخفاء مؤشر الفأرة داخل اللعبة */
        }
        
        /* الطبقات الشفافة التي تظهر فوق اللعبة (شاشة البداية، الأسئلة، إلخ) */
        .game-overlay, .question-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.85);
            text-align: center;
            padding: 20px;
            z-index: 50;
            transition: opacity 0.5s ease;
        }

        .game-overlay.hidden, .question-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .game-overlay h1 {
            font-size: clamp(2rem, 8vw, 4rem);
            color: #4fc3f7;
            text-shadow: 0 0 15px rgba(79, 195, 247, 0.9);
            letter-spacing: 2px;
            margin-bottom: 20px;
        }

        .game-overlay p {
            font-size: clamp(1rem, 4vw, 1.5rem);
            color: #bbdefb;
            margin-bottom: 30px;
        }

        .game-overlay .btn {
            background: linear-gradient(to right, #1a2980, #26d0ce);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: clamp(1rem, 4vw, 1.5rem);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), 0 0 10px #26d0ce;
            margin-top: 10px;
        }

        .game-overlay .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4), 0 0 15px #26d0ce;
        }

        .game-overlay .btn:active {
            transform: translateY(1px);
        }

        /* شريط الإحصائيات في الأعلى */
        .stats {
            position: absolute;
            top: 15px;
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 0 20px;
            z-index: 10;
        }

        .stat-item {
            font-size: clamp(1rem, 3vw, 1.3rem);
            background: rgba(0, 30, 60, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(79, 195, 247, 0.5);
        }

        .stat-value {
            font-weight: bold;
            color: #4fc3f7;
            text-shadow: 0 0 5px #4fc3f7;
        }
        
        #soundToggle {
            background: rgba(26, 41, 128, 0.7);
            color: white;
            border: none;
            padding: 8px 15px;
            font-size: clamp(0.8rem, 2.5vw, 1.2rem);
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(79, 195, 247, 0.5);
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        #soundToggle:hover {
            background: rgba(38, 208, 206, 0.7);
        }
        
        #levelUpMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2rem, 10vw, 5rem);
            color: #26d0ce;
            text-shadow: 0 0 20px #26d0ce, 0 0 40px #26d0ce;
            opacity: 0;
            animation: fadeInOut 2s forwards;
            z-index: 100;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            25% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            75% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }
        
        .difficulty-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(0.8rem, 3vw, 1.2rem);
            background: rgba(255, 50, 50, 0.7);
            padding: 5px 15px;
            border-radius: 20px;
            text-align: center;
            z-index: 20;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(255, 50, 50, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 50, 50, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 50, 50, 0.5); }
        }

        /* --- Question Overlay Styles --- */
        .question-overlay {
            justify-content: center;
            padding: 20px;
        }

        .question-overlay .question-content {
            background: rgba(15, 32, 39, 0.95);
            padding: clamp(20px, 5vw, 40px);
            border-radius: 20px;
            max-width: 90%;
            width: 600px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 15px #4fc3f7;
            border: 2px solid #2c5364;
        }

        .question-overlay h2 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #4fc3f7;
        }
        
        .question-overlay .answer-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }

        .question-overlay .answer-btn {
            background: linear-gradient(to right, #005aa7, #fffde4);
            color: #0f2027;
            border: none;
            padding: 15px;
            font-size: clamp(1rem, 4vw, 1.2rem);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            text-align: center;
            font-weight: bold;
        }

        .question-overlay .answer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .question-overlay .answer-btn:active {
            transform: translateY(0);
        }

        .question-overlay .answer-btn.correct {
            background: linear-gradient(to right, #00b09b, #96c93d);
            color: white;
        }

        .question-overlay .answer-btn.incorrect {
            background: linear-gradient(to right, #c04848, #d84545);
            color: white;
        }

        .question-overlay .message-box {
            margin-top: 20px;
            font-size: clamp(1rem, 4vw, 1.3rem);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="gameOverlay" class="game-overlay">
        <h1 id="overlayTitle">Space Waves</h1>
        <p id="overlayMessage">العب وتجنب الاصطدام بالجدران</p>
        <button id="overlayBtn" class="btn">بدء اللعبة</button>
    </div>
    
    <!-- Question Overlay -->
    <div id="questionOverlay" class="question-overlay hidden">
        <div class="question-content">
            <h2 id="questionText"></h2>
            <div id="answerOptions" class="answer-options">
                <!-- أزرار الإجابات يتم إدراجها هنا -->
            </div>
            <p id="feedbackMessage" class="message-box"></p>
        </div>
    </div>

    <div id="levelUpMessage" style="display:none;"></div>

    <div class="stats">
        <div class="stat-item">المستوى: <span id="level" class="stat-value">1</span></div>
        <div class="stat-item">النقاط: <span id="score" class="stat-value">0</span></div>
        <div class="stat-item">الزمن: <span id="time" class="stat-value">0</span> ثانية</div>
        <button id="soundToggle">الصوت: تشغيل</button>
    </div>
    
    <div class="difficulty-indicator">مسار جبلي حاد وعقبات داخلية!</div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const timeElement = document.getElementById('time');
            const levelElement = document.getElementById('level');
            const overlay = document.getElementById('gameOverlay');
            const overlayTitle = document.getElementById('overlayTitle');
            const overlayMessage = document.getElementById('overlayMessage');
            const overlayBtn = document.getElementById('overlayBtn');
            const soundToggleBtn = document.getElementById('soundToggle');
            const levelUpMessageElement = document.getElementById('levelUpMessage');

            // عناصر لوحة الأسئلة
            const questionOverlay = document.getElementById('questionOverlay');
            const questionTextElement = document.getElementById('questionText');
            const answerOptionsContainer = document.getElementById('answerOptions');
            const feedbackMessageElement = document.getElementById('feedbackMessage');
            
            let GAME_WIDTH;
            let GAME_HEIGHT;
            
            // حالة اللعبة
            let gameState = {
                level: 1,
                currentLevelScore: 0, 
                totalScore: 0,
                gameTime: 0,
                gameOver: false,
                gameStarted: false,
                paused: true,
                isLevelComplete: false,
                isQuestionActive: false,
                pathPoints: [],
                pathWidth: 150,
                pathSpeed: 1,
                targetPathSpeed: 4,
                lastTime: 0,
                
                obstacles: [],
                obstacleGenerationInterval: 1000,
                
                // إضافة حالة أزرار لوحة المفاتيح
                keys: {
                    ArrowUp: false,
                    ArrowDown: false,
                    w: false,
                    s: false
                }
            };
            
            // مصفوفة ألوان العوائق لكل مستوى
            const levelColors = ['#ff6b6b', '#ffd166', '#06d6a0', '#118ab2', '#073b4c'];

            // حالة التحكم باللمس
            let touchState = {
                isTouched: false,
                lastY: null
            };

            // مصفوفة نجوم الخلفية
            let stars = [];
            const numStars = 200;
            const starSpeed = 0.7;
            
            // متغير التحكم بالصوت
            let soundEnabled = true;

            // إعداد الصوت
            let audioContext;
            let thrusterOscillator = null;
            let backgroundMelodyTimeoutId = null;
            let isBackgroundMelodyPlaying = false;
            
            const gMajorScale = {
                'G3': 196.00, 'A3': 220.00, 'B3': 246.94, 'D4': 293.66,
                'E4': 329.63, 'F#4': 369.99, 'G4': 392.00, 'A4': 440.00,
                'B4': 493.88, 'D5': 587.33, 'E5': 659.25, 'G5': 783.99
            };

            const cheerfulPianoMelody = [
                { main: 'G4', bass: 'G3', duration: 0.2 },
                { main: 'B4', duration: 0.2 },
                { main: 'D5', duration: 0.2 },
                { main: 'E5', bass: 'G3', duration: 0.4 },
                { main: 'D5', duration: 0.2 },
                { main: 'B4', bass: 'A3', duration: 0.4 },
                { main: 'A4', duration: 0.2 },
                { main: 'G4', bass: 'G3', duration: 0.8 },

                { main: 'G4', bass: 'G3', duration: 0.2 },
                { main: 'D5', duration: 0.2 },
                { main: 'B4', duration: 0.2 },
                { main: 'E5', bass: 'G3', duration: 0.4 },
                { main: 'D5', duration: 0.2 },
                { main: 'B4', bass: 'A3', duration: 0.4 },
                { main: 'A4', duration: 0.2 },
                { main: 'G4', bass: 'G3', duration: 0.8 },
            ];

            // قائمة الأسئلة الجديدة الخاصة بدرس "التخمين والتحقق"
            const questions = [
                {
                    question: "عمر أحمد يزيد عن عمر أخيه بـ 3 سنوات، وإذا كان مجموع عمريهما 25 سنة، فكم عمر كل منهما؟",
                    options: ["14 سنة و 11 سنة", "13 سنة و 10 سنوات", "15 سنة و 12 سنة", "12 سنة و 9 سنوات"],
                    correctAnswerIndex: 0
                },
                {
                    question: "قطعة أرض مستطيلة طولها يزيد عن عرضها بـ 5 أمتار، وإذا كان محيطها 50 مترًا، فما طولها وعرضها؟",
                    options: ["15 مترًا و 10 أمتار", "20 مترًا و 5 أمتار", "18 مترًا و 13 مترًا", "22 مترًا و 17 مترًا"],
                    correctAnswerIndex: 0
                },
                {
                    question: "لدى يوسف 15 ورقة نقدية من فئة 1 دينار و 5 دنانير، وكان مجموع المبلغ 43 دينارًا، فكم ورقة من كل فئة معه؟",
                    options: ["8 ورقات من فئة 1 و 7 ورقات من فئة 5", "10 ورقات من فئة 1 و 5 ورقات من فئة 5", "5 ورقات من فئة 1 و 10 ورقات من فئة 5", "9 ورقات من فئة 1 و 6 ورقات من فئة 5"],
                    correctAnswerIndex: 0
                },
                {
                    question: "اشترى سامي 4 دفاتر و 3 أقلام بمبلغ 14 دينارًا، وإذا كان ثمن القلم الواحد 2 دينار، فما ثمن الدفتر الواحد؟",
                    options: ["2 دينار", "3 دنانير", "4 دنانير", "5 دنانير"],
                    correctAnswerIndex: 0
                },
                {
                    question: "في بطولة كرة السلة، يحصل الفريق على نقطتين للفوز ونقطة واحدة للتعادل. إذا جمع فريق 17 نقطة بعد 10 مباريات، فكم مرة فاز وكم مرة تعادل؟",
                    options: ["7 انتصارات و 3 تعادلات", "5 انتصارات و 5 تعادلات", "8 انتصارات و 2 تعادل", "6 انتصارات و 4 تعادلات"],
                    correctAnswerIndex: 0
                },
                {
                    question: "لدى سارة 10 دنانير اشترت بها 15 قطعة (دفاتر وأقلام). إذا كان ثمن الدفتر 1 دينار وثمن القلم 0.5 دينار، فما عدد الدفاتر والأقلام؟",
                    options: ["5 دفاتر و 10 أقلام", "6 دفاتر و 9 أقلام", "8 دفاتر و 7 أقلام", "10 دفاتر و 5 أقلام"],
                    correctAnswerIndex: 0
                },
                {
                    question: "في حديقة مستطيلة الشكل، طولها ضعف عرضها، وكان محيطها 36 مترًا، فما طولها وعرضها؟",
                    options: ["12 مترًا و 6 أمتار", "10 أمتار و 8 أمتار", "14 مترًا و 7 أمتار", "16 مترًا و 8 أمتار"],
                    correctAnswerIndex: 0
                },
                {
                    question: "في معرض فني، ثمن تذكرة الكبار 3 دنانير وثمن تذكرة الصغار 2 دينار. إذا باع المعرض 50 تذكرة بمبلغ 120 دينارًا، فكم تذكرة من كل نوع بيعت؟",
                    options: ["20 تذكرة للكبار و 30 للصغار", "25 تذكرة للكبار و 25 للصغار", "15 تذكرة للكبار و 35 للصغار", "30 تذكرة للكبار و 20 للصغار"],
                    correctAnswerIndex: 0
                },
                {
                    question: "ربح فريق كرة القدم 3 نقاط في الفوز، و 1 نقطة في التعادل. إذا لعب 8 مباريات وجمع 20 نقطة، فكم مرة فاز وكم مرة تعادل؟",
                    options: ["6 انتصارات و 2 تعادل", "5 انتصارات و 3 تعادلات", "7 انتصارات و 1 تعادل", "4 انتصارات و 4 تعادلات"],
                    correctAnswerIndex: 0
                },
                {
                    question: "لدى محمد وعلي مبلغ 90 دينارًا، نصيب محمد أكبر من نصيب علي بـ 10 دنانير، فكم مع كل منهما؟",
                    options: ["50 دينارًا لمحمد و 40 لعلي", "45 دينارًا لمحمد و 45 لعلي", "60 دينارًا لمحمد و 30 لعلي", "55 دينارًا لمحمد و 35 لعلي"],
                    correctAnswerIndex: 0
                },
                {
                    question: "قطعة أرض مستطيلة طولها يزيد عن عرضها بـ 8 أمتار، ومحيطها 64 مترًا، فما أبعادها؟",
                    options: ["20 مترًا و 12 مترًا", "24 مترًا و 16 مترًا", "18 مترًا و 10 أمتار", "26 مترًا و 18 مترًا"],
                    correctAnswerIndex: 0
                },
                {
                    question: "اشترت ندى 4 كتب و 3 دفاتر بمبلغ 26 دينارًا، وكان ثمن الدفتر الواحد 2 دينار، فما ثمن الكتاب الواحد؟",
                    options: ["5 دنانير", "4 دنانير", "6 دنانير", "7 دنانير"],
                    correctAnswerIndex: 0
                },
                {
                    question: "في مكتبة، سعر الكتاب 5 دنانير وسعر القلم 1 دينار. إذا دفع شخص 23 دينارًا مقابل 7 قطع (كتب وأقلام)، فكم كتابًا وكم قلمًا اشترى؟",
                    options: ["4 كتب و 3 أقلام", "5 كتب و 2 قلم", "3 كتب و 4 أقلام", "6 كتب و 1 قلم"],
                    correctAnswerIndex: 0
                },
                {
                    question: "إذا كان مجموع عددين 50 وأحدهما أكبر من الآخر بـ 12، فما العددان؟",
                    options: ["31 و 19", "30 و 20", "28 و 22", "32 و 18"],
                    correctAnswerIndex: 0
                },
                {
                    question: "في حديقة حيوانات، تذكرة الكبار بـ 6 دنانير وتذكرة الصغار بـ 4 دنانير. إذا بلغ عدد الزوار 100 ودخل الحديقة 480 دينارًا، فكم تذكرة من كل نوع بيعت؟",
                    options: ["40 تذكرة للكبار و 60 تذكرة للصغار", "50 تذكرة للكبار و 50 تذكرة للصغار", "60 تذكرة للكبار و 40 تذكرة للصغار", "30 تذكرة للكبار و 70 تذكرة للصغار"],
                    correctAnswerIndex: 0
                }
            ];
            let currentQuestion = null;
            // إضافة متغير جديد لحفظ الفهرس الصحيح للخيارات بعد خلطها
            let shuffledCorrectIndex = -1;

            function playSound(frequency, type = 'sine', duration = 0.5, volume = 0.5) {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                if (!soundEnabled) return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = type;
                oscillator.frequency.value = frequency;

                const currentTime = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, currentTime + 0.02);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, currentTime + duration);

                oscillator.start(currentTime);
                oscillator.stop(currentTime + duration);
            }

            function playNoteOrChord(notes, duration, volume) {
                if (Array.isArray(notes)) {
                    notes.forEach(note => {
                        const frequency = gMajorScale[note];
                        if (frequency) {
                            playSound(frequency, 'sine', duration, volume);
                        }
                    });
                } else {
                    const frequency = gMajorScale[notes];
                    if (frequency) {
                        playSound(frequency, 'sine', duration, volume);
                    }
                }
            }
            
            function playContinuousMelody(melody, index = 0) {
                if (!isBackgroundMelodyPlaying) {
                    return;
                }

                const noteData = melody[index];
                const nextIndex = (index + 1) % melody.length;
                const delay = noteData.duration * 1000;
                
                playNoteOrChord(noteData.main, noteData.duration, 0.4);

                if (noteData.bass) {
                    playSound(gMajorScale[noteData.bass], 'sine', noteData.duration, 0.4);
                }

                backgroundMelodyTimeoutId = setTimeout(() => {
                    playContinuousMelody(melody, nextIndex);
                }, delay);
            }
            
            function startBackgroundMelody() {
                if (!soundEnabled) return;
                if (isBackgroundMelodyPlaying) return;
                
                isBackgroundMelodyPlaying = true;
                playContinuousMelody(cheerfulPianoMelody);
            }
            
            function stopBackgroundMelody() {
                if (isBackgroundMelodyPlaying) {
                    clearTimeout(backgroundMelodyTimeoutId);
                    isBackgroundMelodyPlaying = false;
                }
            }

            function playLevelUpSound() {
                playSound(880, 'sine', 0.1, 0.4);
                setTimeout(() => playSound(1320, 'sine', 0.1, 0.4), 100);
            }

            function playCollisionSound() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const now = audioContext.currentTime;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.linearRampToValueAtTime(100, now + 0.3);
                
                gainNode.gain.setValueAtTime(0.6, now);
                gainNode.gain.linearRampToValueAtTime(0.001, now + 0.4);
                
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }

            // صوت الإجابة الصحيحة
            function playCorrectSound() {
                playSound(1000, 'sine', 0.2, 0.6);
                setTimeout(() => playSound(1500, 'sine', 0.2, 0.6), 100);
            }

            // صوت الإجابة الخاطئة
            function playIncorrectSound() {
                playSound(400, 'triangle', 0.3, 0.5);
                setTimeout(() => playSound(200, 'triangle', 0.3, 0.5), 100);
            }

            function startThrusterSound() {
                if (!soundEnabled) return;
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (thrusterOscillator) return;
                
                thrusterOscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                thrusterOscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                thrusterOscillator.type = 'sine';
                thrusterOscillator.frequency.value = 80;
                gainNode.gain.value = 0.1;
                
                thrusterOscillator.start();
            }

            function stopThrusterSound() {
                if (thrusterOscillator) {
                    thrusterOscillator.stop();
                    thrusterOscillator.disconnect();
                    thrusterOscillator = null;
                }
            }
            
            let thrusterParticles = [];

            const ship = {
                x: 0,
                y: 0,
                width: 30,
                height: 50,
                velocity: { x: 0, y: 0 },
                maxSpeed: 8,
                rotation: Math.PI / 2,
                color: '#4fc3f7',
                draw: function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);

                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(0, -this.height / 2);
                    ctx.lineTo(-this.width / 2, this.height / 2);
                    ctx.lineTo(-this.width / 4, this.height / 4);
                    ctx.lineTo(this.width / 4, this.height / 4);
                    ctx.lineTo(this.width / 2, this.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#e1f5fe';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(0, -this.height / 4, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            };

            function generateThrusterParticles() {
                const particleCount = 3;
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.PI;
                    const spread = Math.random() * Math.PI / 8 - Math.PI / 16;
                    const pAngle = angle + spread;
                    const pSpeed = Math.random() * 3 + 2;
                    
                    thrusterParticles.push({
                        x: ship.x,
                        y: ship.y,
                        vx: Math.cos(pAngle) * pSpeed,
                        vy: Math.sin(pAngle) * pSpeed,
                        size: Math.random() * 8 + 3,
                        life: 60,
                        color: `rgba(255, 100, 50, ${Math.random() * 0.7 + 0.3})`
                    });
                }
            }

            function updateThrusterParticles() {
                thrusterParticles = thrusterParticles.filter(p => p.life > 0);
                thrusterParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    p.size *= 0.95;
                });
            }

            function drawThrusterParticles() {
                thrusterParticles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.shadowColor = 'rgba(255, 100, 50, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            }

            function createStars() {
                stars = [];
                for (let i = 0; i < numStars; i++) {
                    stars.push({
                        x: Math.random() * GAME_WIDTH,
                        y: Math.random() * GAME_HEIGHT,
                        size: Math.random() * 2,
                        speed: Math.random() * starSpeed + 0.1,
                        color: `rgba(255, 255, 255, ${Math.random() * 0.7 + 0.3})`
                    });
                }
            }

            function drawStars() {
                stars.forEach(star => {
                    ctx.fillStyle = star.color;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function updateStars() {
                stars.forEach(star => {
                    star.x -= star.speed * gameState.pathSpeed / 2;
                    if (star.x < 0) {
                        star.x = GAME_WIDTH;
                        star.y = Math.random() * GAME_HEIGHT;
                    }
                });
            }
            
            function getSawtoothPathY(x, timeOffset) {
                const period = 500;
                const amplitude = 150;
                const speedFactor = 0.5;

                const adjustedX = x + timeOffset * gameState.pathSpeed * speedFactor;
                const normalizedX = (adjustedX % period) / period;

                let yOffset;
                if (normalizedX < 0.5) {
                    yOffset = normalizedX * 2;
                } else {
                    yOffset = (1 - normalizedX) * 2;
                }

                return yOffset * amplitude - amplitude / 2;
            }
            
            // تم تعديل هذه الدالة لحل المشكلة الأساسية.
            // الآن يتم إنشاء المسار ليغطي الشاشة بأكملها من البداية.
            function initializePath() {
                gameState.pathPoints = [];
                // زيادة عدد النقاط لتحسين سلاسة المسار
                const segments = 100;
                // تحديد عرض كل مقطع من المسار بحيث يغطي الشاشة
                const segmentWidth = GAME_WIDTH / 20; 
                const initialYOffset = GAME_HEIGHT / 2;
                
                // بدء توليد النقاط من موقع بعيد على يسار الشاشة لضمان أن
                // المركبة تكون دائمًا على المسار عند البدء.
                for (let i = -20; i <= segments; i++) {
                    const x = i * segmentWidth;
                    const y = getSawtoothPathY(x, gameState.gameTime) + initialYOffset;
                    gameState.pathPoints.push({ x: x, y: y });
                }
            }
            
            function updatePath() {
                gameState.pathPoints.forEach(point => {
                    point.x -= gameState.pathSpeed;
                });

                // إضافة نقطة جديدة عند نهاية المسار عند الحاجة
                if (gameState.pathPoints[0].x < -GAME_WIDTH) {
                    gameState.pathPoints.shift();
                    const lastPoint = gameState.pathPoints[gameState.pathPoints.length - 1];
                    
                    const newX = lastPoint.x + (GAME_WIDTH / 20); // استخدام نفس عرض المقطع
                    const newY = getSawtoothPathY(newX, gameState.gameTime) + GAME_HEIGHT / 2;
                    gameState.pathPoints.push({ x: newX, y: newY });
                }
            }
            
            function drawPath() {
                ctx.strokeStyle = 'rgba(79, 195, 247, 0.4)';
                ctx.lineWidth = gameState.pathWidth;
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
                
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 4;
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y - gameState.pathWidth / 2);
                    } else {
                        ctx.lineTo(point.x, point.y - gameState.pathWidth / 2);
                    }
                });
                ctx.stroke();
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y + gameState.pathWidth / 2);
                    } else {
                        ctx.lineTo(point.x, point.y + gameState.pathWidth / 2);
                    }
                });
                ctx.stroke();
                
                ctx.strokeStyle = '#26d0ce';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 10]);
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y - gameState.pathWidth / 4);
                    } else {
                        ctx.lineTo(point.x, point.y - gameState.pathWidth / 4);
                    }
                });
                ctx.stroke();
                
                ctx.beginPath();
                gameState.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y + gameState.pathWidth / 4);
                    } else {
                        ctx.lineTo(point.x, point.y + gameState.pathWidth / 4);
                    }
                });
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            let lastObstacleTime = 0;
            function generateObstacles(timestamp) {
                if (timestamp - lastObstacleTime > gameState.obstacleGenerationInterval) {
                    const pathPoint = gameState.pathPoints.find(p => p.x > GAME_WIDTH * 0.9);
                    
                    if (pathPoint) {
                        // تعديل: زيادة حجم العوائق بعد الثانية 16
                        let obstacleRadius;
                        if (gameState.gameTime >= 16) {
                            // حجم أكبر بعد 16 ثانية
                            obstacleRadius = Math.random() * 10 + 15; // حجم بين 15 و 25
                        } else {
                            // الحجم الأصلي
                            obstacleRadius = Math.random() * 5 + 10; // حجم بين 10 و 15
                        }

                        let randomY;
                        
                        // وضع العوائق على حدود المسار
                        if (Math.random() > 0.5) {
                            // على الحد العلوي للمسار
                            randomY = pathPoint.y - gameState.pathWidth / 2 + obstacleRadius;
                        } else {
                            // على الحد السفلي للمسار
                            randomY = pathPoint.y + gameState.pathWidth / 2 - obstacleRadius;
                        }

                        const colorIndex = (gameState.level - 1) % levelColors.length;
                        const obstacleColor = levelColors[colorIndex];

                        gameState.obstacles.push({
                            x: GAME_WIDTH,
                            y: randomY,
                            radius: obstacleRadius,
                            color: obstacleColor
                        });
                    }
                    
                    lastObstacleTime = timestamp;
                    // تقليل الفاصل الزمني لتوليد العوائق مع تقدم المستوى لزيادة الصعوبة
                    gameState.obstacleGenerationInterval = Math.max(500, 1000 - gameState.level * 50);
                }
            }
            
            function drawObstacles() {
                gameState.obstacles.forEach(obstacle => {
                    ctx.fillStyle = obstacle.color; 
                    ctx.shadowColor = obstacle.color;
                    ctx.shadowBlur = 20;

                    const spikes = 8;
                    const outerRadius = obstacle.radius * 1.5;
                    const innerRadius = obstacle.radius * 0.7;
                    const rotationAngle = gameState.gameTime * 0.5;

                    ctx.save();
                    ctx.translate(obstacle.x, obstacle.y);
                    ctx.rotate(rotationAngle);
                    
                    ctx.beginPath();
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (Math.PI / spikes) * i;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(0, 0, innerRadius * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                });
            }

            function updateObstacles() {
                gameState.obstacles.forEach(obstacle => {
                    obstacle.x -= gameState.pathSpeed;
                });
                gameState.obstacles = gameState.obstacles.filter(obstacle => obstacle.x + obstacle.radius > 0);
            }

            function checkPathCollision() {
                let minDistance = Infinity;
                
                for (let i = 0; i < gameState.pathPoints.length - 1; i++) {
                    const pointA = gameState.pathPoints[i];
                    const pointB = gameState.pathPoints[i + 1];
                    
                    const dx = pointB.x - pointA.x;
                    const dy = pointB.y - pointA.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    
                    if (length === 0) continue;

                    const t = Math.max(0, Math.min(1, 
                        ((ship.x - pointA.x) * dx + (ship.y - pointA.y) * dy) / (length * length)
                    ));
                    
                    const projectionX = pointA.x + t * dx;
                    const projectionY = pointA.y + t * dy;
                    
                    const distance = Math.sqrt(
                        Math.pow(ship.x - projectionX, 2) + 
                        Math.pow(ship.y - projectionY, 2)
                    );
                    
                    minDistance = Math.min(minDistance, distance);
                }
                
                if (minDistance > gameState.pathWidth / 2 - 25) { 
                    return true;
                }
                
                return false;
            }
            
            function checkObstacleCollision() {
                for (const obstacle of gameState.obstacles) {
                    const distance = Math.sqrt(
                        Math.pow(ship.x - obstacle.x, 2) + 
                        Math.pow(ship.y - obstacle.y, 2)
                    );
                    if (distance < (ship.height / 2) + obstacle.radius) {
                        return true;
                    }
                }
                return false;
            }

            // تحقق من الاصطدام: إذا حدث أي اصطدام، سيتم إظهار السؤال.
            function checkCollision() {
                if (checkPathCollision() || checkObstacleCollision()) {
                    handleQuestionCollision();
                }
            }

            // دالة لإدارة الاصطدام وإظهار السؤال
            function handleQuestionCollision() {
                playCollisionSound();
                gameState.paused = true;
                gameState.isQuestionActive = true;
                stopThrusterSound();
                stopBackgroundMelody();

                // اختيار سؤال عشوائي
                const questionIndex = Math.floor(Math.random() * questions.length);
                currentQuestion = questions[questionIndex];

                // تمرير الفهرس الأصلي للسؤال إلى دالة showQuestion
                showQuestion(currentQuestion, currentQuestion.correctAnswerIndex);
            }

            // دالة لخلط عناصر مصفوفة
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // دالة لإظهار السؤال على الشاشة
            // تم تعديل الدالة لتستقبل الفهرس الصحيح الأصلي
            function showQuestion(question, originalCorrectIndex) {
                questionTextElement.textContent = question.question;
                answerOptionsContainer.innerHTML = '';
                feedbackMessageElement.textContent = '';
                
                const correctAnswerText = question.options[originalCorrectIndex];
                const shuffledOptions = shuffleArray([...question.options]);
                
                // البحث عن الفهرس الصحيح الجديد بعد الخلط
                const newCorrectAnswerIndex = shuffledOptions.findIndex(option => option === correctAnswerText);
                
                shuffledOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.classList.add('answer-btn');
                    button.textContent = option;
                    // تمرير الفهرس الصحيح الجديد إلى دالة handleAnswer
                    button.addEventListener('click', () => handleAnswer(index, newCorrectAnswerIndex));
                    answerOptionsContainer.appendChild(button);
                });
                
                questionOverlay.classList.remove('hidden');
            }

            // دالة للتعامل مع الإجابة
            // تم تعديل الدالة لتستقبل الفهرس الصحيح الجديد
            function handleAnswer(selectedIndex, correctIndex) {
                const isCorrect = (selectedIndex === correctIndex);
                const buttons = answerOptionsContainer.querySelectorAll('.answer-btn');
                
                buttons.forEach((btn, index) => {
                    btn.disabled = true;
                    if (index === correctIndex) {
                        btn.classList.add('correct');
                    } else if (index === selectedIndex) {
                        btn.classList.add('incorrect');
                    }
                });

                if (isCorrect) {
                    playCorrectSound();
                    feedbackMessageElement.textContent = "إجابة صحيحة! استمر في اللعب.";
                    feedbackMessageElement.style.color = "#00b09b";
                    
                    // إضافة نقاط إضافية للإجابة الصحيحة إلى نقاط المستوى الحالي
                    gameState.currentLevelScore += 50; 
                    scoreElement.textContent = gameState.totalScore + gameState.currentLevelScore;

                    setTimeout(() => {
                        questionOverlay.classList.add('hidden');
                        gameState.isQuestionActive = false;
                        gameState.paused = false;
                        
                        // إعادة سرعة المركبة إلى السرعة البطيئة ثم تزداد تدريجياً
                        gameState.pathSpeed = 1;
                        
                        // إفراغ مصفوفة العوائق
                        gameState.obstacles = [];
                        
                        // إعادة وضع المركبة في مكان آمن بعد الإجابة الصحيحة
                        positionShipOnPath();
                        gameState.lastTime = performance.now(); // إعادة ضبط الوقت عند استئناف اللعبة
                        startBackgroundMelody(); // استئناف الموسيقى الخلفية
                        startThrusterSound(); // استئناف صوت الدفع
                    }, 1500);
                } else {
                    // التغيير المطلوب: إنهاء اللعبة عند الإجابة الخاطئة
                    playIncorrectSound();
                    feedbackMessageElement.textContent = "إجابة خاطئة. انتهت اللعبة!";
                    feedbackMessageElement.style.color = "#c04848";
                    setTimeout(() => {
                        questionOverlay.classList.add('hidden');
                        gameState.gameOver = true; // إنهاء اللعبة
                    }, 1500);
                }
            }

            // دالة لوضع المركبة في منتصف المسار الآمن
            function positionShipOnPath() {
                const shipX = GAME_WIDTH * 0.2;
                let foundSegment = false;
                
                for (let i = 0; i < gameState.pathPoints.length - 1; i++) {
                    const pointA = gameState.pathPoints[i];
                    const pointB = gameState.pathPoints[i + 1];
                    
                    if (pointA.x <= shipX && pointB.x >= shipX) {
                        const t = (shipX - pointA.x) / (pointB.x - pointA.x);
                        ship.y = pointA.y + t * (pointB.y - pointA.y);
                        ship.x = shipX;
                        foundSegment = true;
                        break;
                    }
                }
                
                if (!foundSegment && gameState.pathPoints.length > 0) {
                    ship.x = gameState.pathPoints[0].x;
                    ship.y = gameState.pathPoints[0].y;
                }
            }

            function resizeCanvas() {
                GAME_WIDTH = window.innerWidth;
                GAME_HEIGHT = window.innerHeight;
                
                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;

                if (gameState.gameStarted) {
                    initializePath();
                    positionShipOnPath();
                }
            }

            // إضافة معالج أحداث حركة الفأرة لتحريك المركبة
            canvas.addEventListener('mousemove', (e) => {
                // التحكم بالماوس متاح فقط إذا لم يكن الجهاز يدعم اللمس
                if (!('ontouchstart' in window || navigator.maxTouchPoints > 0) && gameState.gameStarted && !gameState.paused && !gameState.isQuestionActive) {
                    // تصحيح: بدلاً من القفز مباشرة إلى موضع الماوس،
                    // اجعل المركبة تتحرك بسلاسة نحوه.
                    const targetY = e.clientY;
                    const easingFactor = 0.1; // عامل التخفيف، قيمة أصغر تعني حركة أبطأ وأكثر سلاسة
                    ship.y += (targetY - ship.y) * easingFactor;
                }
            });

            // معالجات أحداث اللمس
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);

            function handleTouchStart(e) {
                if (gameState.paused || gameState.gameOver || !gameState.gameStarted || gameState.isLevelComplete) return;
                e.preventDefault();
                touchState.isTouched = true;
                const touch = e.changedTouches[0];
                touchState.lastY = touch.clientY;
            }

            function handleTouchMove(e) {
                if (!touchState.isTouched) return;
                e.preventDefault();
                const touch = e.changedTouches[0];
                const deltaY = touch.clientY - touchState.lastY;
                ship.y += deltaY;
                touchState.lastY = touch.clientY;
                ship.y = Math.max(30, Math.min(GAME_HEIGHT - 30, ship.y));
            }
            
            function handleTouchEnd(e) {
                touchState.isTouched = false;
                touchState.lastY = null;
            }

            function draw() {
                ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                updateStars();
                drawStars();
                
                drawPath();
                
                drawObstacles();

                generateThrusterParticles();
                updateThrusterParticles();
                drawThrusterParticles();
                
                ship.draw();
            }
            
            // دالة للبدء بالمستوى التالي
            function nextLevel() {
                // إضافة نقاط المستوى الحالي إلى النقاط الإجمالية
                gameState.totalScore += gameState.currentLevelScore;
                
                // زيادة الصعوبة للمستوى التالي
                gameState.level++;
                gameState.gameTime = 0;
                gameState.isLevelComplete = false;
                gameState.paused = false;
                
                // إعادة تعيين نقاط المستوى الحالي
                gameState.currentLevelScore = 0;
                
                // تحديث سرعة المسار لزيادة الصعوبة
                gameState.pathSpeed = 1 + (gameState.level - 1) * 0.5; // سرعة ابتدائية أسرع
                gameState.targetPathSpeed = gameState.pathSpeed + 3 + (gameState.level - 1) * 1; // سرعة مستهدفة أعلى
                
                // تضييق المسار
                gameState.pathWidth = 150 - (gameState.level - 1) * 10;
                gameState.pathWidth = Math.max(50, gameState.pathWidth);
                
                levelElement.textContent = gameState.level;
                scoreElement.textContent = gameState.totalScore;
                timeElement.textContent = gameState.gameTime;
                
                gameState.obstacles = []; // إعادة تعيين العوائق
                
                initializePath();
                positionShipOnPath();
                
                gameState.lastTime = performance.now();
                
                startThrusterSound();
                startBackgroundMelody();
            }

            function update(timestamp) {
                if (gameState.paused || gameState.gameOver || !gameState.gameStarted || gameState.isQuestionActive) return;
                
                const deltaTime = timestamp - gameState.lastTime;
                gameState.lastTime = timestamp;
                
                gameState.gameTime += deltaTime / 1000;
                timeElement.textContent = Math.floor(gameState.gameTime);

                // زيادة سرعة المركبة تدريجياً حتى تصل للسرعة المستهدفة
                if (gameState.pathSpeed < gameState.targetPathSpeed) {
                    gameState.pathSpeed += 0.01;
                }

                // التحقق من انتهاء المستوى بعد 25 ثانية
                if (Math.floor(gameState.gameTime) >= 25 && !gameState.isLevelComplete) {
                    gameState.paused = true;
                    gameState.isLevelComplete = true;
                    playLevelUpSound();
                    stopThrusterSound();
                    stopBackgroundMelody();
                    return; // إيقاف تحديث اللعبة
                }
                
                // نقاط الوقت للمستوى الحالي
                gameState.currentLevelScore = Math.floor(gameState.gameTime * 10);
                scoreElement.textContent = gameState.totalScore + gameState.currentLevelScore;
                
                // === هذا الجزء من الكود هو ما يضمن أن المركبة لا تتحرك تلقائياً ===
                // تحديث موقع المركبة بناءً على ضغط المفاتيح فقط.
                // إذا لم يضغط اللاعب على أي مفتاح، فإن قيمة dy ستكون صفرًا، وبالتالي لن تتحرك المركبة.
                let dy = 0;
                const speed = 5; // سرعة الحركة بالأسهم
                if (gameState.keys.ArrowUp || gameState.keys.w) {
                    dy = -speed;
                }
                if (gameState.keys.ArrowDown || gameState.keys.s) {
                    dy = speed;
                }
                ship.y += dy;
                // =================================================================

                // التأكد من أن المركبة لا تخرج عن حدود الشاشة
                ship.y = Math.max(30, Math.min(GAME_HEIGHT - 30, ship.y));

                // تحديث المسار والعوائق
                updatePath();
                updateObstacles();
                generateObstacles(timestamp);
                
                // التحقق من الاصطدامات
                checkCollision();
            }
            
            function gameLoop(timestamp) {
                if (!gameState.gameStarted) {
                    // اللعبة لم تبدأ بعد، لا تفعل شيئًا
                    requestAnimationFrame(gameLoop);
                    return;
                }

                update(timestamp);
                draw();
                
                if (gameState.gameOver) {
                    overlayTitle.textContent = 'انتهت اللعبة!';
                    overlayMessage.textContent = `نقاطك الإجمالية: ${gameState.totalScore}`;
                    overlayBtn.textContent = 'إعادة التشغيل';
                    overlay.classList.remove('hidden');
                    stopThrusterSound();
                    stopBackgroundMelody();
                } else if (gameState.isLevelComplete) { // حالة جديدة لانتهاء المستوى
                    overlayTitle.textContent = 'انتهى المستوى!';
                    overlayMessage.textContent = `لقد جمعت ${gameState.currentLevelScore} نقطة في هذا المستوى.\nنقاطك الإجمالية: ${gameState.totalScore + gameState.currentLevelScore}`;
                    overlayBtn.textContent = 'المستوى التالي';
                    overlay.classList.remove('hidden');
                } else if (gameState.paused && !gameState.isQuestionActive) {
                    overlayTitle.textContent = 'إيقاف مؤقت';
                    overlayMessage.textContent = 'اللعبة في وضع الإيقاف المؤقت';
                    overlayBtn.textContent = 'استمرار';
                    overlay.classList.remove('hidden');
                    stopThrusterSound();
                    stopBackgroundMelody();
                } else {
                    overlay.classList.add('hidden');
                    if (gameState.gameStarted && !gameState.isQuestionActive) {
                        startThrusterSound();
                        startBackgroundMelody();
                    }
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            function startGame() {
                gameState = {
                    level: 1,
                    currentLevelScore: 0,
                    totalScore: 0,
                    gameTime: 0,
                    gameOver: false,
                    gameStarted: true,
                    paused: false,
                    isLevelComplete: false,
                    isQuestionActive: false,
                    pathPoints: [],
                    pathWidth: 150,
                    pathSpeed: 1, // سرعة المسار الابتدائية
                    targetPathSpeed: 4, // السرعة المستهدفة
                    lastTime: performance.now(), // تحديث الوقت عند البدء
                    
                    obstacles: [],
                    obstacleGenerationInterval: 1000,
                    keys: {
                        ArrowUp: false,
                        ArrowDown: false,
                        w: false,
                        s: false
                    }
                };
                
                initializePath();
                positionShipOnPath();
                
                scoreElement.textContent = '0';
                timeElement.textContent = '0';
                levelElement.textContent = '1';
                
                thrusterParticles = [];
                
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                startThrusterSound();
                startBackgroundMelody();
                
                // إخفاء الشاشة الرئيسية
                overlay.classList.add('hidden');
            }
            
            overlayBtn.addEventListener('click', () => {
                if (gameState.gameOver || !gameState.gameStarted) {
                    startGame();
                } else if (gameState.isLevelComplete) { // التعامل مع زر "المستوى التالي"
                    nextLevel();
                } else if (gameState.paused) {
                    gameState.paused = false;
                    gameState.lastTime = performance.now();
                }
            });

            soundToggleBtn.addEventListener('click', () => {
                soundEnabled = !soundEnabled;
                soundToggleBtn.textContent = `الصوت: ${soundEnabled ? 'تشغيل' : 'إيقاف'}`;

                if (soundEnabled && gameState.gameStarted && !gameState.gameOver && !gameState.paused) {
                    startThrusterSound();
                    startBackgroundMelody();
                } else {
                    stopThrusterSound();
                    stopBackgroundMelody();
                }
            });
            
            window.addEventListener('blur', () => {
                if (gameState.gameStarted && !gameState.gameOver && !gameState.isQuestionActive) {
                    gameState.paused = true;
                    stopThrusterSound();
                    stopBackgroundMelody();
                }
            });
            
            // إضافة معالجات أحداث لوحة المفاتيح
            window.addEventListener('keydown', (e) => {
                // تحقق من المفاتيح المسموحة فقط
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'ArrowDown' || e.key === 's') {
                    e.preventDefault();
                    gameState.keys[e.key] = true;
                }
            });
            
            window.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'ArrowDown' || e.key === 's') {
                    gameState.keys[e.key] = false;
                }
            });
            
            // إضافة معالج حدث لتغيير حجم النافذة
            window.addEventListener('resize', () => {
                resizeCanvas();
                createStars();
            });
            
            resizeCanvas();
            createStars();
            
            // استدعاء gameLoop لبدء حلقة اللعبة بعد تحميل الصفحة
            requestAnimationFrame(gameLoop);
            
            // لا تبدأ اللعبة تلقائيًا، بل انتظر ضغط زر "بدء اللعبة"
        });
    </script>
</body>
</html>
